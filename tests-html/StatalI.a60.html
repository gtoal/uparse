<html><head><meta charset="utf-8"></head><body><pre><u>code</u> 41000;
<u>real</u> <u>procedure</u> BIN(X, N, P);
   <u>value</u> X, N, P; <u>real</u> X, N, P;
<u>begin</u> <u>integer</u> IX;

   IX ≔ ENTIER(X);
   <u>if</u> N &lt; 0 ∨ N &gt; ENTIER(N) <u>then</u>
     BIN ≔ STATAL3 ERROR(“BIN”, 2, N) <u>else</u>
   <u>if</u> P &lt; 0 ∨ P &gt; 1 <u>then</u>
     BIN ≔ STATAL3 ERROR(“BIN”, 3, P) <u>else</u>
   <u>if</u> IX &lt; 0 <u>then</u> BIN ≔ 0 <u>else</u>
   <u>if</u> IX &GreaterSlantEqual; N <u>then</u> BIN ≔ 1 <u>else</u>
   <u>if</u> P = 0 <u>then</u> BIN ≔ 1 <u>else</u>
   <u>if</u> P = 1 <u>then</u> BIN ≔ 0 <u>else</u>
   <u>if</u> N &gt; 1000 <u>then</u>
   <u>begin</u> <u>real</u> B;
      B ≔ 1 - INCOMPLETE BETA(P, IX + 1, N - IX, &#9192;-12);
      BIN ≔ <u>if</u> B &lt; 0 <u>then</u> 0 <u>else</u> B;
   <u>end</u>   <u>else</u>
   <u>begin</u> <u>real</u> <u>procedure</u> TAIL;
      <u>begin</u> <u>integer</u> I; <u>real</u> PROB, CUM, LAST;
         PROB ≔ CUM ≔ BINPROB(IX, N, P);
         <u>for</u> I ≔ IX - 1, I - 1 <u>while</u> CUM &gt; LAST <u>do</u>
            <u>begin</u> PROB ≔                  PROB × (1 - P) / P × (I + 1) / (N - I);
               LAST ≔ CUM; CUM ≔ CUM + PROB
            <u>end</u>;
         TAIL ≔ CUM
      <u>end</u>;
      <u>if</u> X &gt; ENTIER(N / 2) <u>then</u>
      <u>begin</u> IX ≔ N - IX - 1; P ≔ 1 - P;
         BIN ≔ 1 - TAIL
      <u>end</u> <u>else</u> BIN ≔ TAIL
   <u>end</u>;
<u>end</u> BIN;
<u>eop</u>
<u>code</u> 41001;
<u>real</u> <u>procedure</u> BININV(PROB, N, P, LEFT);
   <u>value</u> PROB, N, P, LEFT;
   <u>real</u> PROB, N, P; <u>Boolean</u> LEFT;
<u>begin</u> <u>integer</u> X; <u>real</u> PX, PCUM;

   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“BININV”, 1, PROB) <u>else</u>
   <u>if</u> N &gt; ENTIER(N) ∨ N &lt; 0 <u>then</u>
     STATALS ERROR(“BININV”, 2, N) <u>else</u>
   <u>if</u> P &lt; 0 ∨ P &gt; 1 <u>then</u>
     STATAL3 ERROR(“BININV”, 3, P);

   <u>if</u> P = 0 ∨ N = 0 <u>then</u>
     BININV ≔ (<u>if</u> LEFT <u>then</u> -1 <u>else</u> 1)
     <u>else</u> <u>if</u> P = 1 <u>then</u>
     BININV ≔ (<u>if</u> LEFT <u>then</u> N - 1 <u>else</u> N + 1)
     <u>else</u> <u>if</u> LEFT <u>then</u>
   <u>begin</u> X ≔ PHINV(PROB) ×
        SQRT(N × P × (1 - P)) - 0·5 + N × P;
      <u>if</u> X &lt; 0 <u>then</u> X ≔ 0
        <u>else</u> <u>if</u> X &gt; N <u>then</u> X ≔ N;
      <u>if</u> PROB &lt; (1 - P) ⭡ N <u>then</u> BININV ≔ -1 <u>else</u>
      <u>begin</u> PX ≔ BINPROB(X, N, P); PCUM ≔ BIN(X, N, P);
         <u>if</u> PCUM &gt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × X × (1 - P) /
                    (N - X + 1) / P;
                  X ≔ X - 1
               <u>end</u>; X ≔ X - 1
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PX ≔               PX × (N - X) / (X + 1) × P / (1 - P)
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u>  X ≔ X + 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u>;
         BININV ≔ X
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ PHINV(1 - PROB) ×
        SQRT(N × P × (1 - P)) + 0·5 + N × P;
      <u>if</u> X &lt; 0 <u>then</u> X ≔ 0 <u>else</u>
      <u>if</u> X &gt; N <u>then</u> X ≔ N;
      <u>if</u> PROB &lt; P ⭡ N <u>then</u> BININV ≔ N + 1 <u>else</u>
      <u>begin</u> PCUM ≔ 1 - BIN(X - 1, N, P);
         PX ≔ BINPROB(X, N, P);
         <u>if</u> PCUM &lt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PX ≔               PX × X × (1 - P) / (N - X + 1) /P
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u> X ≔ X - 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × (N - X) × P /
                    (X + 1) / (1 - P);
                  X ≔ X + 1
               <u>end</u>; X ≔ X + 1
         <u>end</u>;
         BININV ≔ X
      <u>end</u>
   <u>end</u>
<u>end</u> BININV;
<u>eop</u>
<u>code</u> 41004;
<u>real</u> <u>procedure</u> HYPERG(X, N, R, NN);
   <u>value</u> X, N, R, NN; <u>real</u> X, N, R, NN;

<u>begin</u> <u>integer</u> I; <u>real</u> SUM, LAST, TERM; <u>Boolean</u> LEFT;
   <u>if</u> N &lt; 0 ∨ N &gt; NN ∨ N - ENTIER(N) ≠ 0 <u>then</u>
     STATAL3 ERROR(“HYPERG”, 2, N);
   <u>if</u> R &lt;0 ∨ R &gt; NN ∨ R - ENTIER(R) ≠ 0 <u>then</u>
     STATAL3 ERROR(“HYPERG”, 3, R);
   <u>if</u> NN - ENTIER(NN) ≠ 0 <u>then</u>
     STATAL3 ERROR(“HYPERG”, 4, NN);
   LEFT ≔ <u>true</u>;
   <u>if</u> N &gt; NN / 2 <u>then</u>
   <u>begin</u> LEFT ≔ <u>false</u>; N ≔ NN - N; X ≔ R - X - 1 <u>end</u>;
   <u>if</u> R &gt; NN / 2 <u>then</u>
   <u>begin</u> LEFT ≔ ¬ LEFT; R ≔ NN - R;
      X ≔ N - X - 1
   <u>end</u>;
   <u>if</u> N &gt; R <u>then</u> <u>begin</u> I ≔ N; N ≔ R; R ≔ I <u>end</u>;
   <u>if</u> X &lt;  0 <u>then</u> HYPERG ≔ <u>if</u> LEFT <u>then</u> 0 <u>else</u> 1
     <u>else</u>
   <u>if</u> X &GreaterSlantEqual; N <u>then</u> HYPERG ≔ <u>if</u> LEFT <u>then</u> 1 <u>else</u> 0
     <u>else</u> <u>if</u> NN &gt; &#9192;5 <u>then</u>
   <u>begin</u> <u>real</u> BETA, TAU, CHI;
      TAU ≔ SQRT(R × N × (NN - N) × (NN - R) / NN) / NN;
      CHI ≔ (X + ·5 - N × R / NN) / TAU;
      BETA ≔ (CHI × CHI + 2) / 12;
      X ≔ <u>if</u> R &LessSlantEqual; NN / 4 <u>then</u>
        2 × (SQRT((X + ·5 + BETA)× (NN - R - N + X + ·5 + BETA))
        - SQRT((N - X - ·5 + BETA) ×
        (R - X - ·5 + BETA))) /
        SQRT(NN + 1·5 - NN × NN / 2 / N / (NN - N))
      <u>else</u>
        CHI + (CHI × CHI - 1) ×
        (2 × N - NN) × (NN - 2 × R)
        / 6 / TAU / NN / NN + CHI ×
        (1 - 3 × (NN - N) × N / NN / NN)
        / 48 / TAU / TAU;
      HYPERG ≔ PHI(<u>if</u> LEFT <u>then</u> X <u>else</u> -X)
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ ENTIER(X);
      TERM ≔ SUM ≔ HYPERGPROB(X, N, R, NN);
      <u>if</u> X &gt; (N + 1) × (R + 1) / (NN + 2) <u>then</u>
      <u>begin</u> LEFT ≔ ¬ LEFT; SUM ≔ 0;
         <u>for</u> I ≔ X + 1, I + 1 <u>while</u> LAST &lt; SUM <u>do</u>
            <u>begin</u> TERM ≔ TERM × (N - I + 1) × (R - I + 1)
                 / I / (NN - R - N + I);
               LAST ≔ SUM; SUM ≔ SUM + TERM
            <u>end</u>
      <u>end</u> <u>else</u>
        <u>for</u> I ≔ X, I - 1 <u>while</u> LAST &lt; SUM <u>do</u>
         <u>begin</u> TERM ≔ TERM × I × (NN - N - R + I)
              / (N - I + 1) / (R - I + 1);
            LAST ≔ SUM; SUM ≔ SUM + TERM
         <u>end</u>;
      HYPERG ≔ <u>if</u> LEFT <u>then</u> SUM <u>else</u> 1 - SUM
   <u>end</u>
<u>end</u> HYPERG;
<u>eop</u>
<u>code</u> 41005;
<u>real</u> <u>procedure</u> HYPERGINV(PROB, N, R, M, LEFT);
   <u>value</u> PROB, N, R, M, LEFT;
   <u>real</u> PROB, N, R, M; <u>Boolean</u> LEFT;
<u>begin</u> <u>integer</u> X; <u>real</u> PX, PCUM, LOW, UP;

   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“HYPERGINV”, 1, PROB) <u>else</u>
   <u>if</u> N &gt; ENTIER(N) ∨ N &lt; 0 ∨ N &gt; M <u>then</u>
     STATAL3 ERROR(“HYPERGINV”, 2, N) <u>else</u>
   <u>if</u> R &gt; ENTIER(R) ∨ R &lt; 0 ∨ R &gt; M <u>then</u>
     STATAL3 ERROR(“HYPERGINV”, 3, R) <u>else</u>
   <u>if</u> M &gt; ENTIER(M) ∨ M &lt; 0 <u>then</u>
     STATAL3 ERROR(“HYPERGINV”, 4, M);
   LOW ≔ <u>if</u> N + R - M &gt; 0 <u>then</u> N + R - M <u>else</u> 0;
   UP ≔ <u>if</u> N &lt; R <u>then</u> N <u>else</u> R;
   <u>if</u> N = 0 ∨ R = 0 <u>then</u>
     HYPERGINV ≔ (<u>if</u> LEFT <u>then</u> -1 <u>else</u> +1)
     <u>else</u> <u>if</u> N = M ∨ R = M <u>then</u>
     HYPERGINV ≔ (<u>if</u> LEFT <u>then</u> M - 1 <u>else</u> M + 1)
     <u>else</u> <u>if</u> LEFT <u>then</u>
   <u>begin</u> X ≔ PHINV(PROB) × SQRT((M - N) × N × R ×
        (M - R) / (M × M × (M - 1))) + R × N / M + 0·5;
      <u>if</u> X &lt; LOW <u>then</u> X ≔ LOW <u>else</u>
      <u>if</u> X &gt; UP <u>then</u> X ≔ UP;
      <u>if</u> PROB &lt; HYPERGPROB(LOW, N, R, M) <u>then</u>
        HYPERGINV ≔ LOW - 1
      <u>else</u>
      <u>begin</u> PX ≔ HYPERGPROB(X, N, R, M);
         PCUM ≔ HYPERG(X, N, R, M);
         <u>if</u> PCUM &gt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × X × (M - N - R + X) /
                    (N - X + 1) / (R - X + 1); X ≔ X - 1
               <u>end</u>; X ≔ X - 1
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PX ≔ PX × (N - X) × (R - X) /
              (X + 1) / (R - X + 1)
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u> X ≔ X + 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u>;
         HYPERGINV ≔ X
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ PHINV(1 - PROB) × SQRT((M - N) × N × R ×
        (M - R) / (M × M × (M - 1))) + R × N / M - 0·5;
      <u>if</u> X &lt; LOW <u>then</u> X ≔ LOW <u>else</u>
      <u>if</u> X &gt; UP <u>then</u> X ≔ UP;
      <u>if</u> PROB &lt; HYPERGPROB(UP, N, R, M) <u>then</u>
        HYPERGINV ≔ UP + 1
      <u>else</u>
      <u>begin</u> PCUM ≔ 1 - HYPERG(X - 1, N, R, M);
         PX ≔ HYPERGPROB(X, N, R, M);
         <u>if</u> PCUM &lt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PX ≔ PX × X × (M - N - R + X) /
              (N - X + 1) / (R - X + 1)
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u> X ≔ X - 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × (N - X) × (R - X) /
                    (X + 1) / (M - N - R + X + 1);
                  X ≔ X + 1
               <u>end</u>; X ≔ X + 1
         <u>end</u>;
         HYPERGINV ≔ X
      <u>end</u>
   <u>end</u>
<u>end</u> HYPERGINV;
<u>eop</u>
<u>code</u> 41009;
<u>real</u> <u>procedure</u> NEGBIN(X, K, P);
   <u>value</u> X, K, P; <u>real</u> X, K, P;
   NEGBIN ≔ <u>if</u> K &lt; 0 ∨ K &gt; ENTIER(K)
     <u>then</u> STATAL3 ERROR(“NEGBIN”, 2, K)
   <u>else</u> <u>if</u> P &LessSlantEqual; 0 ∨ P &gt; 1
     <u>then</u> STATAL3 ERROR(“NEGBIN”, 3, P)
   <u>else</u> <u>if</u> X &GreaterSlantEqual; K <u>then</u>
     1 - BIN(K - 1, ENTIER(X), P)
   <u>else</u> 0;
<u>eop</u>
<u>code</u> 41010;
<u>real</u> <u>procedure</u> NEGBININV(PROB, K, P, LEFT);
   <u>value</u> PROB, K, P, LEFT;
   <u>real</u> PROB, K, P; <u>Boolean</u> LEFT;
<u>begin</u> <u>integer</u> X; <u>real</u> PX, PCUM;

   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“NEGBININV”, 1, PROB) <u>else</u>
   <u>if</u> K &gt; ENTIER(K) ∨ K &lt; 0 <u>then</u>
     STATAL3 ERROR(“NEGBININV”, 2, K) <u>else</u>
   <u>if</u> P &LessSlantEqual; 0 ∨ P &gt; 1 <u>then</u>
     STATAL3 ERROR(“NEGBININV”, 3, P);

   <u>if</u> P = 1 ∨ K = 0 <u>then</u>
     NEGBININV ≔ (<u>if</u> LEFT <u>then</u> K - 1 <u>else</u> K + 1)
     <u>else</u> <u>if</u> LEFT <u>then</u>
   <u>begin</u> X ≔ (PHINV(PROB) ×
        SQRT(K × (1 - P)) + K - P / 2) / P;
      <u>if</u> X &lt; K <u>then</u> X ≔ K;
      <u>if</u> PROB &lt; P ⭡ K <u>then</u> NEGBININV ≔ K - 1 <u>else</u>
      <u>begin</u> PX ≔ NEGBINPROB(X, K, P);
         PCUM ≔ NEGBIN(X, K, P);
         <u>if</u> PCUM &gt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × (X - K) / (1 - P)
                    / (X - 1);
                  X ≔ X - 1
               <u>end</u>; X ≔ X - 1
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PX ≔ PX × (1- P) × X / (X - K + 1)
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u> X ≔ X + 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u>;
         NEGBININV ≔ X
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ (PHINV(1 - PROB) ×
        SQRT(K × (1 - P)) + K + P / 2) / P;
      <u>if</u> X &gt; K <u>then</u> X ≔ K;
      PCUM ≔ 1 - NEGBIN(X - 1, K, P);
      PX ≔ NEGBINPROB(X, K, P);
      <u>if</u> PCUM &lt; PROB <u>then</u>
      <u>begin</u> <u>for</u> PX ≔ PX × (X - K) / (1 - P) / (X - 1)
           <u>while</u> PCUM + PX &lt; PROB <u>do</u>
            <u>begin</u> X ≔ X - 1; PCUM ≔ PCUM + PX <u>end</u>
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
           <u>while</u> PCUM &gt; PROB <u>do</u>
            <u>begin</u> PX ≔ PX × (1 - P) × X / (X - K + 1);
               X ≔ X + 1
            <u>end</u>; X ≔ X + 1
      <u>end</u>
   <u>end</u>;
   NEGBININV ≔ X
<u>end</u> NEGBININV;
<u>eop</u>
<u>code</u> 41013;
<u>real</u> <u>procedure</u> POISSON(X, MU);
   <u>value</u> X, MU; <u>real</u> X, MU;
<u>begin</u> <u>integer</u> IX;
   <u>real</u> <u>procedure</u> KSI(K, L);
      <u>value</u> K, L; <u>real</u> L; <u>integer</u> K;
   <u>begin</u> <u>real</u> U, U2, W; W ≔ SQRT(L);
      U ≔ 2 × (SQRT(K + 1) - W);
      U2 ≔ U × U; KSI ≔         U + (U2 - 4) / 12 / W + (-U2 × U + 10 × U) / 72 /
        L + (21 × U2 × U2 - 371 × U2 - 52) / 6480 / L / W
   <u>end</u>;

   IX ≔ ENTIER(X);
   <u>if</u> IX &lt; 0 <u>then</u> POISSON ≔ 0 <u>else</u>
   <u>if</u> MU &LessSlantEqual; 0 <u>then</u>
     POISSON ≔ STATAL3 ERROR(“POISSON”,2,MU)
     <u>else</u>
   <u>if</u> MU &gt; 1000 <u>then</u> POISSON ≔ PHI(KSI(IX, MU))
   <u>else</u>
   <u>begin</u> <u>integer</u> I, MODUS; <u>real</u> MODUSPROB, PROB, CUM;
      MODUS ≔ ENTIER(MU) + 1; <u>if</u> IX &lt; MODUS <u>then</u>
      <u>begin</u> PROB ≔ CUM ≔ POISSONPROB(IX, MU);
         <u>for</u> I ≔ IX <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> PROB ≔ PROB × I / MU;
               CUM ≔ CUM + PROB
            <u>end</u>
      <u>end</u> <u>else</u>
      <u>begin</u> MODUSPROB ≔ PROB ≔ CUM ≔            POISSONPROB(MODUS, MU);
         <u>for</u> I ≔ MODUS <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> PROB ≔ PROB × I / MU;
               CUM ≔ CUM + PROB
            <u>end</u>;  PROB ≔ MODUSPROB;
         <u>for</u> I ≔ MODUS + 1 <u>step</u> 1 <u>until</u> IX <u>do</u>
            <u>begin</u> PROB ≔ PROB × MU / I;
               CUM ≔ CUM + PROB
            <u>end</u>
      <u>end</u>;
      POISSON ≔ CUM
   <u>end</u>
<u>end</u> POISSON;
<u>eop</u>
<u>code</u> 41014;
<u>real</u> <u>procedure</u> POISSONINV(PROB, MU, LEFT);
   <u>value</u> PROB, MU, LEFT;
   <u>real</u> PROB, MU; <u>Boolean</u> LEFT;
<u>begin</u> <u>integer</u> X; <u>real</u> PX, PCUM;

   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“POISSONINV”, 1, PROB) <u>else</u>
   <u>if</u> MU &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“POISSONINV”, 2, MU);

   <u>if</u> LEFT <u>then</u>
   <u>begin</u> X ≔ (PHINV(PROB) / 2 + SQRT(MU)) ⭡ 2 - 1;
      <u>if</u> X &lt; 0 <u>then</u> X ≔ 0;
      <u>if</u> PROB &lt; EXP(-MU) <u>then</u> POISSONINV ≔ -1 <u>else</u>
      <u>begin</u> PX ≔ POISSONPROB(X, MU);
         PCUM ≔ POISSON(X, MU);
         <u>if</u> PCUM &gt; PROB <u>then</u>
         <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
              <u>while</u> PCUM &gt; PROB <u>do</u>
               <u>begin</u> PX ≔ PX × X / MU; X ≔ X - 1 <u>end</u>;
            X ≔  - 1
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> PX ≔ PX × MU / (X + 1)
              <u>while</u> PCUM + PX &lt; PROB <u>do</u>
               <u>begin</u> X ≔ X + 1; PCUM ≔ PCUM + PX <u>end</u>
         <u>end</u>;
         POISSONINV ≔ X
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ (PHINV(1 - PROB) / 2 + SQRT(MU)) ⭡ 2 + 1;
      <u>if</u> X &lt; 0 <u>then</u> X ≔ 0;
      PCUM ≔ 1 - POISSON(X - 1, MU);
      PX ≔ POISSONPROB(X, MU);
      <u>if</u> PCUM &lt; PROB <u>then</u>
      <u>begin</u> <u>for</u> PX ≔ PX × X / MU
           <u>while</u> PCUM + PX &lt; PROB <u>do</u>
            <u>begin</u> X ≔ X - 1; PCUM ≔ PCUM + PX <u>end</u>
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> PCUM ≔ PCUM - PX
           <u>while</u> PCUM &gt; PROB <u>do</u>
            <u>begin</u> PX ≔ PX × MU / (X + 1); X ≔ X + 1 <u>end</u>;
         X ≔ X + 1
      <u>end</u>;
      POISSONINV ≔ X
   <u>end</u>
<u>end</u> POISSONINV;
<u>eop</u>
<u>code</u> 41020;
<u>real</u> <u>procedure</u> WILCOX(X,M,N);
   <u>value</u> X,M,N; <u>real</u> X,M,N;
<u>begin</u>
   <u>integer</u> <u>procedure</u> MIN(A,B);
      <u>value</u> A,B; <u>integer</u> A,B;
      MIN ≔ <u>if</u> A &gt; B <u>then</u> B <u>else</u> A;
   <u>integer</u> <u>procedure</u> MAX(A,B);
      <u>value</u> A,B; <u>integer</u> A,B;
      MAX ≔ <u>if</u> A &gt; B <u>then</u> A <u>else</u> B;
   <u>real</u> WP1;    <u>Boolean</u> X EVEN, RIGHT;
   <u>integer</u> MN;
   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“WILCOX”, 2, M);
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“WILCOX”, 3, N);
   MN ≔ M × N;
   X ≔ ENTIER(X/2);
   <u>if</u> X &lt; MN/2 <u>then</u> RIGHT ≔ <u>false</u> <u>else</u>
   <u>begin</u> RIGHT ≔ <u>true</u>; X ≔ MN-X-1 <u>end</u>;
   X EVEN ≔ ENTIER(X/2) × 2 = X;
   M ≔ MIN(M,N); N ≔ MN/M;
   <u>if</u> X &lt; 0 <u>then</u> WP1 ≔ 0 <u>else</u>
   <u>if</u> M = 1 <u>then</u> WP1 ≔ (X+1) / (N+1) <u>else</u>
   <u>if</u> M = 2 <u>then</u> WP1 ≔ (<u>if</u> X EVEN <u>then</u>
     (X+2)×(X+2) / (2×(N+1)×(N+2)) <u>else</u>
     (X+1)×(X+3) / (2×(N+1)×(N+2)) )     <u>else</u>
   <u>if</u> 2×X = MN - 1 <u>then</u> WP1 ≔ ·5 <u>else</u>
   <u>if</u> MN &gt; 400 <u>then</u>
   <u>begin</u> <u>integer</u> NOEM, N2, N3, N4, M2, M3, M4;
      <u>real</u> F0Y, F3Y, F5Y, F7Y, T3, T5, T7, Y, Y2;
      Y ≔ (2×X + 1 - MN) / SQRT(MN × (M + N + 1) / 3);
      Y2 ≔ Y × Y;
      NOEF ≔ 10 × MN × (M + N + 1); F0Y ≔ PHIDENS(Y);
      N2 ≔ N × N; N3 ≔ N2 × N; N4 ≔ N2 × N2;
      M2 ≔ M × M; M3 ≔ M2 × M; M4 ≔ M2 × M2;
      F3Y ≔ Y × (3 - Y2);
      F5Y ≔ Y × (-15 + Y2 × (10 - Y2));
      F7Y ≔ Y × (105 - Y2 × (105 - Y2 × (21 - Y2)));
      T3 ≔ (M2 + N2 + MN + M + N) / NOEM / 2;
      T5 ≔ ( 2 × (M4 + N4) + 4 +
        (M3 × N + N3 × M + M3 + N3) +
        6 × M2 × N2 + 7 × MN × (M + N) + M2 + N2 +
        2 × MN - M - N) / (NOEM × NOEM × 2·1);
      T7 ≔ (M2 + N2 + MN + M + N) ⭡ 2
        / (NOEM × NOEM × 8);
      WP1 ≔ MAX(PHI(Y) - F0Y ×
        (T3 × F3Y - T5 × F5Y - T7 × F7Y), 0);
   <u>end</u> <u>else</u>
   <u>begin</u> <u>integer</u> I,J,W,UP,UP1,UP2; <u>real</u> H1,H2;
      <u>if</u> N × (X+1) &LessSlantEqual; 12000 <u>then</u>
      <u>begin</u> M ≔ N; N ≔ MN / M <u>end</u>;
      <u>begin</u> <u>real</u> <u>array</u> WP[0:X, 1:M];
         UP2 ≔ MIN(M, ENTIER((MN-X-1)/(N-1)));
         <u>for</u> I ≔ MAX(2, -ENTIER(X/2-M)) <u>step</u> 1
           <u>until</u> UP2 <u>do</u>
            <u>begin</u> UP ≔ X-(M-I)×2; UP1 ≔ MIN(UP,I-1);
               H1 ≔ 1/(I+1);
               <u>for</u> W ≔ MAX(0, X-(M-I)×N) <u>step</u> 1
                 <u>until</u> UP1 <u>do</u>
                    WP[W,I] ≔ H1 × (W+1);
            <u>end</u>;
         <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> UP ≔ MIN(X-(M-1)×J , J-1);
               H2 ≔ 1/(J+1);
               <u>for</u> W ≔ MAX(0, X-(M-2)×N-J) <u>step</u> 1
                 <u>until</u> UP <u>do</u>
                    WP[W,1] ≔ H2 × (W+1);
               UP2 ≔ (<u>if</u> J×M &lt; X+1 <u>then</u>
                 ENTIER((MN-X-1)/(N-J)) <u>else</u> M);
               <u>for</u> I ≔ MAX(2,-ENTIER(X/J-M)) <u>step</u> 1
                 <u>until</u> UP2 <u>do</u>
                  <u>begin</u> UP ≔ X - (M-I)×J;
                     H1 ≔ J/(I+J); H2 ≔ I/(I+J);
                     UP1 ≔ MIN(UP,J-1);
                     <u>for</u>  W ≔ MAX(0, X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,I]×H1;
                     UP1 ≔ MIN(UP,I×J-I-1);
                     <u>for</u>  W ≔ MAX(J, X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,I]×H1 + WP[W-J,I-1]×H2;
                     UP1 ≔ MIN(UP,I×J-1);
                     <u>for</u> W ≔ MAX(I×J-I, X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ H1 + WP[W-J,I-1]×H2;
                  <u>end</u>
            <u>end</u>;
         WP1 ≔ WP[X,M];
      <u>end</u>;
   <u>end</u>;
   WILCOX ≔ <u>if</u> RIGHT <u>then</u> 1-WP1 <u>else</u> WP1;
<u>end</u> WILCOXCDF;
<u>eop</u>
<u>code</u> 41021;
<u>real</u> <u>procedure</u> WILCOXINV(PROB, M, N, LEFT);
   <u>value</u> PROB, M, N, LEFT; <u>real</u> PROB, M, N; <u>Boolean</u> LEFT;
<u>begin</u>
   <u>integer</u> X, W, WI, MN; <u>real</u> Z; <u>Boolean</u> MN EVEN;
   MN ≔ M × N;
   MN EVEN ≔ ENTIER(MN/2) × 2 = MN;
   X ≔ <u>if</u> MN EVEN <u>then</u> MN/2 - 1 <u>else</u> MN/2 - 1·5;
   PROB ≔ PROB + &#9192;-13×(1-PROB);
   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“WILCOXINV”, 1, PROB) <u>else</u>
   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“WILCOXINV”, 2, M) <u>else</u>
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“WILCOXINV”, 2, N) <u>else</u>
   <u>if</u> MN = 0 <u>then</u> WI ≔ -2 <u>else</u>
   <u>if</u> PROB = ·5 <u>then</u> WI ≔ ENTIER((MN-1)/2) × 2 <u>else</u>
   <u>if</u> M = 1 <u>then</u> WI ≔ ENTIER(PROB×(N+1)) × 2 - 2
     <u>else</u>
   <u>if</u> N = 1 <u>then</u> WI ≔ ENTIER(PROB×(M+1)) × 2 - 2
     <u>else</u> <u>if</u> MN &gt; 400 ∨ M=2 ∨ N=2 <u>then</u>
   <u>begin</u> Z ≔ PHINV(PROB) × SQRT(MN×(M+N+1)/3) + MN;
      WI ≔ W ≔ ENTIER(Z/2) × 2;
      <u>if</u> WI &lt; 0 <u>then</u> WI ≔ W ≔ 0;
      <u>if</u> WI &gt; 2×MN <u>then</u> WI ≔ W ≔ 2×MN;
      <u>if</u> WILCOX(W, M, N) &LessSlantEqual; PROB <u>then</u>
      <u>begin</u> <u>for</u> W ≔ W + 2
           <u>while</u> WILCOX(W, M, N) &LessSlantEqual; PROB <u>do</u> WI ≔ W
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> W ≔ W - 2
           <u>while</u> WILCOX(W, M, N) &gt; PROB <u>do</u> WI ≔ W;
         WI ≔ WI - 2;
      <u>end</u>;
   <u>end</u> <u>else</u>
   <u>begin</u> <u>integer</u> I,J,UP,UP1; <u>real</u> H1,H2;
      <u>Boolean</u> RIGHT, EQUAL; <u>real</u> <u>array</u> WCMN[-1:X+2];
      <u>integer</u> <u>procedure</u> MAX(A,B);
         <u>value</u> A,B; <u>integer</u> A,B;
         MAX ≔ <u>if</u> A &gt; B <u>then</u> A <u>else</u> B;
      <u>integer</u> <u>procedure</u> MIN(A,B);
         <u>value</u> A,B; <u>integer</u> A,B;
         MIN ≔ <u>if</u> A &gt; B <u>then</u> B <u>else</u> A;
      RIGHT ≔ PROB &gt; ·5;
      <u>if</u> RIGHT <u>then</u> PROB ≔ 1 - PROB;
      I ≔ MAX(M,N); J ≔ MIN(M,N);
      <u>if</u> I × (X+1) &gt; 12000 <u>then</u>
      <u>begin</u> M ≔ J; N ≔ I <u>end</u> <u>else</u>
      <u>begin</u> M ≔ I; N ≔ J <u>end</u>;
      <u>begin</u> <u>real</u> <u>array</u> WP[0:X, 1:M];
         <u>for</u> I ≔ MAX(2,-ENTIER(X/2-M)) <u>step</u> 1
           <u>until</u> M <u>do</u>
            <u>begin</u> UP ≔ X-(M-I)×2; UP1 ≔ MIN(UP,I);
               H1 ≔ 1/(I+1);
               <u>for</u> W ≔ 0 <u>step</u> 1 <u>until</u> UP1 <u>do</u>
                    WP[W,I] ≔ H1;
            <u>end</u>;
         <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> UP ≔ MIN(X-(M-1)×J , J); H2 ≔ 1/(J+1);
               <u>for</u> W ≔ 0 <u>step</u> 1 <u>until</u> UP <u>do</u>
                    WP[W,1] ≔ H2;
               <u>for</u> I ≔ MAX(2,-ENTIER(X/J-M)) <u>step</u> 1
                 <u>until</u> M <u>do</u>
                  <u>begin</u> UP ≔ X - (M-I)×J;
                     H1 ≔ J/(I+J); H2 ≔ I/(I+J);
                     UP1 ≔ MIN(UP,J-1);
                     <u>for</u> W ≔ 0 <u>step</u> 1 <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,I]×H1;
                     UP1 ≔ MIN(UP,I×J-I);
                     <u>for</u> W ≔ J <u>step</u> 1 <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,I]×H1 + WP[W-J,I-1]×H2;
                     UP1 ≔ MIN(UP,I×J);
                     <u>for</u>  W ≔ I×J-I+1 <u>step</u> 1 <u>until</u> UP1
                       <u>do</u>  WP[W,I] ≔ WP[W-J,I-1]×H2;
                  <u>end</u>
            <u>end</u>;
         WCMN[-1] ≔ 0;
         WCMN[0] ≔ WP[0,M];
         <u>for</u> W ≔ 1 <u>step</u> 1 <u>until</u> X <u>do</u>
              WCMN[W] ≔ WCMN[W-1] + WP[W,M];
         <u>if</u> MN EVEN <u>then</u>
         <u>begin</u> WCMN[X+1] ≔ 1 - WCMN[X];
            WCMN[X+2] ≔ 1 - WCMN[X-1];
         <u>end</u>
         <u>else</u>
         <u>begin</u> WCMN[X+1] ≔ ·5;
            WCMN[X+2] ≔ 1 - WCMN[X];
         <u>end</u>;
      <u>end</u>;
      WI ≔ PHINV(PROB) × SQRT(MN×(M+N+1)/3) + MN;
      W ≔ ENTIER(WI/2);
      <u>if</u> W &lt; 0 <u>then</u> WI ≔ W ≔ 0 <u>else</u> WI ≔ W;
      <u>if</u> WCMN[W] &LessSlantEqual; PROB <u>then</u>
      <u>begin</u> <u>for</u> W ≔ W + 1
           <u>while</u> WCMN[W] &LessSlantEqual; PROB <u>do</u> WI ≔ W
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> W ≔ W - 1
           <u>while</u> WCMN[W] &gt; PROB <u>do</u> WI ≔ W;
         WI ≔ WI - 1;
      <u>end</u>;
      EQUAL ≔ WCMN[WI] = PROB;
      <u>if</u> RIGHT <u>then</u>
      <u>begin</u> <u>if</u> EQUAL <u>then</u> WI ≔ 2 × (MN - WI - 1)
         <u>else</u> WI ≔ 2 × (MN - WI - 2)
      <u>end</u>
      <u>else</u> WI ≔ 2 × WI;
   <u>end</u>;
   WILCOXINV ≔ <u>if</u> LEFT <u>then</u> WI <u>else</u> 2×MN - WI;
<u>end</u> WILCOXINV;
<u>eop</u>
<u>code</u> 41022;
<u>real</u> <u>procedure</u> WILCOXPROB(X,M,N);
   <u>value</u> X,M,N; <u>real</u> X,M,N;
<u>begin</u>
   <u>integer</u> <u>procedure</u> MIN(A,B);
      <u>value</u> A,B; <u>integer</u> A,B;
      MIN ≔ <u>if</u> A&gt; B <u>then</u> B <u>else</u> A;
   <u>integer</u> <u>procedure</u> MAX(A,B);
      <u>value</u> A,B; <u>integer</u> A,B;
      MAX ≔ <u>if</u> A&gt; B <u>then</u> A <u>else</u> B;
   <u>real</u> WP1;
   <u>integer</u> MN;
   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“WILCOXPROB”, 2, M);
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“WILCOXPROB”, 3, N);
   MN ≔ M × N;
   X ≔ MIN(X/2, MN - X/2);
   M ≔ MIN(M,N); N ≔ MN/M;
   <u>if</u> ENTIER(X) &lt; X <u>then</u> WP1 ≔ 0 <u>else</u>
   <u>if</u> X &lt; 0 <u>then</u> WP1 ≔ 0 <u>else</u>
   <u>if</u> MN = 0 <u>then</u> WP1 ≔ 1 <u>else</u>
   <u>if</u> M = 1 <u>then</u> WP1 ≔ 1/(N+1) <u>else</u>
   <u>if</u> M = 2 <u>then</u>
     WP1 ≔ ENTIER(X/2+1) / ((N+1)×(N+2)/2) <u>else</u>
   <u>if</u> MN &gt; 400 <u>then</u>
     WP1 ≔ WILCOX(2×X,M,N) - WILCOX(2×X-2,M,N) <u>else</u>
   <u>begin</u> <u>integer</u> I,J,W,UP,UP1,UP2; <u>real</u> H1,H2;
      <u>if</u> N × (X+1) &LessSlantEqual; 12000 <u>then</u>
      <u>begin</u> M ≔ N; N ≔ MN/M <u>end</u>;
      <u>begin</u> <u>real</u> <u>array</u> WP[0:X, 1:M];
         UP2 ≔ MIN(M, ENTIER((MN-X)/(N-1)));
         <u>for</u> I ≔ MAX(2,-ENTIER(X/2-M)) <u>step</u> 1
           <u>until</u> UP2 <u>do</u>
            <u>begin</u> UP ≔ X-(M-I)×2; UP1 ≔ MIN(UP,I);
               H1 ≔ 1/(I+1);
               <u>for</u> W ≔ MAX(0, X-(M-I)×N) <u>step</u> 1
                 <u>until</u> UP1 <u>do</u>
                    WP[W,I] ≔ H1;
            <u>end</u>;
         <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> UP ≔ MIN(X-(M-1)×J , J); H2 ≔ 1/(J+1);
               <u>for</u> W ≔ MAX(0, X-(M-2)×N-J) <u>step</u> 1
                 <u>until</u> UP <u>do</u>
                    WP[W,1] ≔ H2;
               UP2 ≔ <u>if</u> J×M&lt;X+1 <u>then</u>
                 ENTIER((MN-X)/(N-J)) <u>else</u> M;
               <u>for</u> I ≔ MAX(2,-ENTIER(X/2-M)) <u>step</u> 1
                 <u>until</u> UP2 <u>do</u>
                  <u>begin</u> UP ≔ X - (M-I)×J;
                     H1 ≔ J/(I+J); H2 ≔ I/(I+J);
                     UP1 ≔ MIN(UP,J-1);
                     <u>for</u> W ≔ MAX(0, X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,1]×H1;
                     UP1 ≔ MIN(UP,I×J-I);
                     <u>for</u> W ≔ MAX(J, X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W,I]×H1 + WP[W-J,I-1]×H2;
                     UP1 ≔ MIN(UP,I×J);
                     <u>for</u> W ≔ AX(I×J-I+1,X-(M-I)×N) <u>step</u> 1
                       <u>until</u> UP1 <u>do</u>
                          WP[W,I] ≔ WP[W-J,I-1]×H2;
                  <u>end</u>
            <u>end</u>;
         WP1   ≔ WP[X,M];
      <u>end</u>;
   <u>end</u>;
   WILCOXPROB ≔ WP1
<u>end</u> WILCOXPROB;
<u>eop</u>
<u>code</u> 41023;
<u>real</u> <u>procedure</u> RUN(X, M, N);
   <u>value</u> X, M, N; <u>real</u> X, M, N;
<u>begin</u>
   <u>real</u> P, PCUM; <u>integer</u> IX, I, K, UP;
   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“RUN”, 2, M) <u>else</u>
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“RUN”, 3, N) <u>else</u>
   <u>if</u> M &gt; N <u>then</u> <u>begin</u> K ≔ M; M ≔ N; N ≔ K <u>end</u>;
   <u>if</u> M = 0 <u>then</u> RUN ≔ (<u>if</u> X &lt; 1 <u>then</u> 0 <u>else</u> 1)
     <u>else</u> <u>if</u> X &lt; 2 <u>then</u> RUN ≔ 0 <u>else</u>
   <u>if</u> M = N ∧ X &GreaterSlantEqual; M × 2 <u>then</u> RUN ≔ 1 <u>else</u>
   <u>if</u> X &gt; M × 2 <u>then</u> RUN ≔ 1 <u>else</u>
   <u>begin</u> IX ≔ ENTIER(X); <u>if</u> IX ÷ 2 × 2 &lt; IX <u>then</u>
      <u>begin</u> PCUM ≔ P ≔ RUNPROB(IX, M, N);
         K ≔ (IX - 1) / 2;
         P ≔ P×K×2 / (M + N - K × 2); PCUM ≔ PCUM + P
      <u>end</u> <u>else</u>
      <u>begin</u> K ≔ IX / 2;
         P ≔ PCUM ≔ RUNPROB(IX, M, N)
      <u>end</u>;
      <u>for</u> I ≔ K - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
         <u>begin</u> P ≔ P × (M + N - I × 2) × I / (N - I) /
              (M - I) / 2; PCUM ≔ PCUM + P;
            P ≔ P×2×I / (M + N - 2 × I); PCUM ≔ PCUM + P
         <u>end</u>;
      RUN ≔ PCUM
   <u>end</u>
<u>end</u> RUN;
<u>eop</u>
<u>code</u> 41024;
<u>real</u> <u>procedure</u> RUNINV(PROB, M, N, LEFT);
   <u>value</u> PROB, M, N, LEFT; <u>real</u> PROB, M, N; <u>Boolean</u> LEFT;
<u>begin</u>
   <u>integer</u> H, R, MN; <u>real</u> P, PCUM;
   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“RUNINV”, 1, PROB) <u>else</u>
   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“RUNINV”, 2, M) <u>else</u>
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“RUNINV”, 3, N);
   MN ≔ M + N;
   <u>if</u> M &gt; N <u>then</u> <u>begin</u> H ≔ M; M ≔ N; N ≔ H <u>end</u>;
   <u>if</u> M = 0 <u>then</u>
     RUNINV ≔ (<u>if</u> LEFT <u>then</u> 0 <u>else</u> 2) <u>else</u>
   <u>if</u> LEFT <u>then</u>
   <u>begin</u> R ≔ PHINV(PROB) ×
        SQRT((MN ⭡ 3 - MN) / (2 × M × N ×
        (2 × M × N - MN))) + ·5 + 2 × M × N / MN;
      <u>if</u> R &lt; 2 <u>then</u> R ≔ 2 <u>else</u>
      <u>if</u> R &gt; M × 2 <u>then</u> R ≔ M × 2;
      <u>if</u> PROB &lt; RUNPROB(2, M, N)
        <u>then</u> RUNINV ≔ +1 <u>else</u>
      <u>begin</u> PCUM ≔ RUN(R, M, N);
         <u>if</u> PCUM &LessSlantEqual; PROB <u>then</u>
         <u>begin</u> <u>for</u> P ≔ RUNPROB(R + 1, M, N)
              <u>while</u> PCUM + P &LessSlantEqual; PROB <u>do</u>
               <u>begin</u> R ≔ R + 1; PCUM ≔ PCUM + P <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> P ≔ RUNPROB(R, M, N)
              <u>while</u> PCUM - P &gt; PROB <u>do</u>
               <u>begin</u> R ≔ R - 1; PCUM ≔ PCUM - P <u>end</u>;
            R ≔ R - 1
         <u>end</u>; RUNINV ≔ R
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> R ≔ PHINV(1 - PROB) ×
        SQRT((MN ⭡ 3 - MN) / (2 × M × N ×
        (2 × M × N - MN))) + 1·5 + 2 × M × N / MN;
      <u>if</u> R &lt; 2 <u>then</u> R ≔ 2 <u>else</u>
      <u>if</u> R &gt; M × 2 <u>then</u> R ≔ M × 2;
      MN ≔ <u>if</u> M = N <u>then</u> 2 × M <u>else</u> 2 × M + 1;
      <u>if</u> PROB &lt; RUNPROB(MN, M, N)
        <u>then</u> RUNINV ≔ MN + 1 <u>else</u>
      <u>begin</u> PCUM ≔ 1 - RUN(R - 1, M, N);
         <u>if</u> PCUM &LessSlantEqual; PROB <u>then</u>
         <u>begin</u> <u>for</u> P ≔ RUNPROB(R - 1, M, N)
              <u>while</u> PCUM + P &LessSlantEqual; PROB <u>do</u>
               <u>begin</u> R ≔ R - 1; PCUM ≔ PCUM + P <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> P ≔ RUNPROB(R, M, N)
              <u>while</u> PCUM - P &gt; PROB <u>do</u>
               <u>begin</u> R ≔ R + 1; PCUM ≔ PCUM - P <u>end</u>;
            R ≔ R + 1
         <u>end</u>;
         RUNINV ≔ R
      <u>end</u>
   <u>end</u>
<u>end</u> RUNINV;
<u>eop</u>
<u>code</u> 41025;
<u>real</u> <u>procedure</u> RUNPROB(X, M, N); <u>value</u> X, M, N;
   <u>real</u> X, M, N;
<u>begin</u> <u>integer</u> K; <u>real</u> P; <u>Boolean</u> EVEN;

   <u>if</u> M &lt; 0 ∨ ENTIER(M) &lt; M <u>then</u>
     STATAL3 ERROR(“RUNPROB”, 2, M) <u>else</u>
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“RUNPROB”, 3, N);
   <u>if</u> M &gt; N <u>then</u> <u>begin</u> K ≔ N; N ≔ M; M ≔ K <u>end</u>;
   EVEN ≔ ENTIER(X / 2) × 2 = X;
   K ≔ <u>if</u> EVEN <u>then</u> X / 2 <u>else</u> (X + 1) / 2;
   RUNPROB ≔      <u>if</u> N = 0 <u>then</u> 0 <u>else</u>
     <u>if</u> M = 0 <u>then</u> (<u>if</u> X = 1 <u>then</u> 1 <u>else</u> 0) <u>else</u>
     <u>if</u> X &lt; 2 ∨ X &gt; 2 × M + 1 ∨ ENTIER(X) &lt; X
     <u>then</u> 0 <u>else</u>
     <u>if</u> EVEN <u>then</u>
     2 × M × N × EXP(2 × (LOGGAMMA(M) + LOGGAMMA(N) -
     LOGGAMMA(K)) - LOGGAMMA(M - K + 1) - LOGGAMMA(N - K + 1)
     - LOGGAMMA(M + N + 1)) <u>else</u>
     (M + N - X + 1) × M × N / (K - 1) × EXP(2 × (LOGGAMMA(M)
     + LOGGAMMA(N) - LOGGAMMA(K - 1)) - LOGGAMMA(M + N + 1)
     - LOGGAMMA(M - K + 2) - LOGGAMMA(N - K + 2))
<u>end</u> RUNPROB;
<u>eop</u>
<u>code</u> 41026;
<u>real</u> <u>procedure</u> KENDALL(X, N); <u>value</u> X, N; <u>real</u> X, N;
<u>begin</u>
   <u>integer</u> I, G, IX; <u>real</u> P;
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“KENDALL”, 2, N);
   G ≔ N × (N - 1) / 2; IX ≔ G + ENTIER(-(G - X) / 2) × 2;
   <u>if</u> IX &GreaterSlantEqual; G <u>then</u> KENDALL ≔ 1 <u>else</u>
   <u>if</u> IX &lt; -G <u>then</u> KENDALL ≔ 0 <u>else</u>
   <u>if</u> N &gt; 9 <u>then</u>
     KENDALL ≔ PHI(IX + 1 / SQRT(N × (N - 1) × (N+N+5) / 18))
     <u>else</u> <u>if</u> IX &gt; 0 <u>then</u>
   <u>begin</u> P ≔ 0; <u>for</u> I ≔ G <u>step</u> -2 <u>until</u> IX + 2 <u>do</u>
           P ≔ P + KENDALLPROB(I, N); KENDALL ≔ 1 - P
   <u>end</u> <u>else</u>
   <u>begin</u> P ≔ 0; <u>for</u> I ≔ -G <u>step</u> 2 <u>until</u> IX <u>do</u>
           P ≔ P + KENDALLPROB(I, N); KENDALL ≔ P
   <u>end</u>
<u>end</u> KENDALL;
<u>eop</u>
<u>code</u> 41027;
<u>real</u> <u>procedure</u> KENDALLINV(PROB, N, LEFT);
   <u>value</u> PROB, N, LEFT; <u>real</u> PROB, N; <u>Boolean</u> LEFT;
<u>begin</u> <u>integer</u> S, G; <u>real</u> P, PCUM;

   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“KENDALLINV”, 1, PROB) <u>else</u>
   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“KENDALLINV”, 2, N);
   G ≔ N × (N - 1) / 2;
   <u>if</u> N = 0 <u>then</u>
     KENDALLINV ≔ (<u>if</u> LEFT <u>then</u> -1 <u>else</u> +1)
     <u>else</u> <u>if</u> LEFT <u>then</u>
   <u>begin</u> S ≔ PHINV(PROB) × SQRT(G × (N × 2 + 5) / 9);
      S ≔ <u>if</u> ABS(S) &gt; G <u>then</u> G × SIGN(S) <u>else</u>
        G + ENTIER(-(G - S) / 2) × 2;
      <u>if</u> PROB &lt; KENDALLPROB(-G, N) <u>then</u>
        KENDALLINV ≔ -G - 2
      <u>else</u>
      <u>begin</u> PCUM ≔ KENDALL(S, N);
         <u>if</u> PCUM &LessSlantEqual; PROB <u>then</u>
         <u>begin</u> <u>for</u> P ≔ KENDALLPROB(S + 2, N)
              <u>while</u> PCUM + P &LessSlantEqual; PROB <u>do</u>
               <u>begin</u> S ≔ S + 2; PCUM ≔ PCUM + P <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> P ≔ KENDALLPROB(S, N)
              <u>while</u> PCUM - P &gt; PROB <u>do</u>
               <u>begin</u> S ≔ S - 2; PCUM ≔ PCUM - P <u>end</u>;
            S ≔ -2
         <u>end</u>; KENDALLINV ≔ S
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> S ≔ PHINV(1 - PROB) × SQRT(G × (N × 2 + 5) / 9);
      S ≔ <u>if</u> ABS(S) &gt; G <u>then</u> G × SIGN(S) <u>else</u>
        G - ENTIER((G - S) / 2) × 2;
      <u>if</u> PROB &lt; KENDALLPROB(G, N) <u>then</u>
        KENDALLINV ≔ G + 2 <u>else</u>
      <u>begin</u> PCUM ≔ 1 - KENDALL(S - 2, N);
         <u>if</u> PCUM &LessSlantEqual; PROB <u>then</u>
         <u>begin</u> <u>for</u> P ≔ KENDALLPROB(S - 2, N)
              <u>while</u> PCUM + P &LessSlantEqual; PROB <u>do</u>
               <u>begin</u> S ≔ S - 2; PCUM ≔ PCUM + P <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>for</u> P ≔ KENDALLPROB(S, ND)
              <u>while</u> PCUM - P &gt; PROB <u>do</u>
               <u>begin</u> S ≔ S + 2; PCUM ≔ PCUM - P <u>end</u>;
            S ≔ S +2
         <u>end</u>;
         KENDALLINV ≔ S
      <u>end</u>
   <u>end</u>
<u>end</u> KENDALLINV;
<u>eop</u>
<u>code</u> 41028;
<u>real</u> <u>procedure</u> KENDALLPROB(X, N);
   <u>value</u> X, N; <u>real</u> X, N;
<u>begin</u> <u>integer</u> G, IX;

   <u>real</u> <u>procedure</u> PROB(S, N);
      <u>value</u> S, N; <u>integer</u> S, N;
   <u>begin</u> <u>integer</u> I; <u>real</u> P;
      <u>if</u> N = 2 <u>then</u> PROB ≔ (<u>if</u> ABS(S) = 1 <u>then</u> ·5
      <u>else</u> 0) <u>else</u>
      <u>begin</u> P ≔ 0;
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
              P ≔ P + PROB(S - N + 1 + I × 2, N - 1);
         PROB ≔ P / N
      <u>end</u>
   <u>end</u>;

   <u>if</u> N &lt; 0 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL3 ERROR(“KENDALLPROB”, 2, N);
   G ≔  × (N - 1) / 2; IX ≔ ENTIER(X);
   <u>if</u> N &gt; 9 <u>then</u>
   <u>begin</u> <u>real</u> S; S ≔ SQRT(N × (N-1) × (N+N+5) / 18);
      KENDALLPROB ≔ PHI(IX + 1/S) - PHI(IX - 1/S)
   <u>end</u> <u>else</u>
     KENDALLPROB ≔ <u>if</u> IX &lt; X ∨ ABS(IX) &gt; G ∨
     (G - IX) ÷ 2 × 2 &lt; G - IX <u>then</u> 0 <u>else</u> PROB(IX, N)
<u>end</u> KENDALLPROB;
<u>eop</u>
<u>code</u> 41251;
<u>real</u> <u>procedure</u> BINPROB(X, N, P);
   <u>value</u> X, N, P; <u>real</u> X, N, P;
   BINPROB ≔ <u>if</u> N &lt; 0 ∨ N &gt; ENTIER(N)
     <u>then</u> STATAL3 ERROR(“BINPROB”, 2, N)
   <u>else</u> <u>if</u> P &lt; 0 ∨ P &gt; 1
     <u>then</u> STATAL3 ERROR(“BINPROB”, 3, P)
   <u>else</u> <u>if</u> X &lt; 0 ∨ X &gt; N ∨ X &gt; ENTIER(X)
     <u>then</u> 0 <u>else</u> <u>if</u> P = 0 ∨ N = 0
     <u>then</u> (<u>if</u> X = 0 <u>then</u> 1 <u>else</u> 0)
   <u>else</u> <u>if</u> P = 1
     <u>then</u> (<u>if</u> X = N <u>then</u> 1 <u>else</u> 0)
   <u>else</u> EXP(LOGGAMMA(N+1) - LOGGAMMA(X+1)
     - LOGGAMMA(N-X+1) + X × LN(P) + (N-X) × LN(1-P));
<u>eop</u>
<u>code</u> 41252;
<u>real</u> <u>procedure</u> POISSONPROB(X, MU);
   <u>value</u> X, MU; <u>real</u> X, MU;
   POISSONPROB ≔ <u>if</u> MU &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“POISSONPROB”, 2, MU)
   <u>else</u> <u>if</u> X &lt; 0 ∨ X &gt; ENTIER(X) <u>then</u> 0
   <u>else</u> EXP(-MU + X × LN(MU) - LOGGAMMA(X+1));
<u>eop</u>
<u>code</u> 41253;
<u>real</u> <u>procedure</u> HYPERGPROB(X, N, R, M);
   <u>value</u> X, N, R, M; <u>real</u> X, N, R, M;
<u>begin</u>
   <u>integer</u> <u>procedure</u> BINCOEF(N, K); <u>value</u> N, K;
      <u>integer</u> N, K;
   <u>begin</u> <u>integer</u> B, L, B1;
      B1 ≔ <u>if</u> K &gt; N - K <u>then</u> N - K <u>else</u> K; B ≔ 1;
      <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> B1 <u>do</u>
           B ≔ B × (N + 1 - L) ÷ L;
      BINCOEF ≔ B
   <u>end</u>;
   <u>if</u> N &lt; 0 ∨ N &gt; M ∨ N &gt; ENTIER(N)
     <u>then</u> STATAL3 ERROR(“HYPERGPROB”, 2, N)
     <u>else</u> <u>if</u> R &lt; 0 ∨ R &gt; M ∨ R &gt; ENTIER(R)
     <u>then</u> STATAL3 ERROR(“HYPERGPROB”, 3, R)
     <u>else</u> <u>if</u> M &gt; ENTIER(M)
     <u>then</u> STATAL3 ERROR(“HYPERGPROB”, 4, M);
   <u>if</u> X &lt; 0 ∨ X &lt; N + R - M ∨ X &gt; N ∨ X &gt; R∨ X &gt; ENTIER(X)
     <u>then</u> HYPERGPROB ≔ 0 <u>else</u>
   <u>if</u> N = 0 ∨ M = 0 <u>then</u> HYPERGPROB ≔      (<u>if</u> X = 0 <u>then</u> 1 <u>else</u> 0) <u>else</u>
   <u>if</u> N = M ∨ R = M <u>then</u> HYPERGPROB ≔      (<u>if</u> X = M <u>then</u> 1 <u>else</u> 0) <u>else</u>
   <u>if</u> M &LessSlantEqual; 51 <u>then</u>
     HYPERGPROB ≔ (BINCOEF(N, X) × BINCOEF(M - N, R - X))
     / BINCOEF(M, R)
   <u>else</u>
   <u>begin</u> <u>integer</u> I; <u>real</u> PROB; PROB ≔ 0;
      <u>for</u> I ≔ N, M-N, R, M-R <u>do</u>
           PROB ≔ PROB + LOGGAMMA(I + 1);
      <u>for</u> I ≔ N - X, X, M - N - R + X, R - X, M <u>do</u>
           PROB ≔ PROB - LOGGAMMA(I + 1);
      HYPERGPROB ≔ EXP(PROB)
   <u>end</u>
<u>end</u> HYPERGPROB;
<u>eop</u>
<u>code</u> 41254;
<u>real</u> <u>procedure</u> NEGBINPROB(X, K, P);
   <u>value</u> X, K, P; <u>real</u> X, K, P;
   NEGBINPROB ≔ <u>if</u> K &lt; 0 ∨ K &gt; ENTIER(K)
     <u>then</u> STATAL3 ERROR(“NEGBINPROB”, 2, K)
   <u>else</u> <u>if</u> P &LessSlantEqual; 0 ∨ P &gt; 1
     <u>then</u> STATAL3 ERROR(“NEGBINPROB”, 3, P)
   <u>else</u> <u>if</u> X &lt; K ∨ X &gt; ENTIER(X) <u>then</u> 0
   <u>else</u> <u>if</u> P = 0 <u>then</u> 0
   <u>else</u> <u>if</u> P = 1 ∨ K = 0
     <u>then</u> (<u>if</u> X = K <u>then</u> 1 <u>else</u> 0)
   <u>else</u> P × BINPROB(K - 1, X - 1, P);
<u>eop</u>
<u>code</u> 41255;
<u>real</u> <u>procedure</u> MULNOMPROB(XVEC, N, K, PVEC);
   <u>value</u> N,K; <u>real</u> N,K; <u>array</u> XVEC, PVEC;
<u>begin</u> <u>real</u> XL, PL, LNPR, EPS, PSUM;
   <u>integer</u> J, XSUM;

   <u>if</u> N &gt; ENTIER(N) ∨ N &lt; 1 <u>then</u>
     STATAL3 ERROR(“MULNOMPROB”,2,N) <u>else</u>
   <u>if</u> K &gt; ENTIER(K) ∨ K &lt; 2 <u>then</u>
     STATAL3 ERROR(“MULNOMPROB”,3,K) <u>else</u>
   <u>begin</u> PSUM ≔ 0; XSUM ≔ 0; EPS ≔ &#9192;-14;
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
         <u>begin</u> PL ≔ PVEC[J];
            <u>if</u> PL &lt; 0 <u>then</u>
              STATAL3 ERROR(“MULNOMPROB”,4,PL) <u>else</u>
              PSUM ≔ PSUM + PL
         <u>end</u>;
      <u>if</u> ABS(PSUM-1) &gt; EPS <u>then</u>
        STATAL3 ERROR(“MULNOMPROB”,4,PSUM) <u>else</u>
      <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
            <u>begin</u> XL ≔ XVEC[J];
               <u>if</u> XL &gt; ENTIER(XL) ∨ XL &lt; 0 <u>then</u>
               <u>begin</u> MULNOMPROB ≔ 0; <u>goto</u> OUT <u>end</u>;
               XSUM ≔ XSUM + XL;
            <u>end</u>;
         <u>if</u> XSUM ≠ N <u>then</u>
         <u>begin</u> MULNOMPROB ≔ 0; <u>goto</u> OUT <u>end</u> <u>else</u>
         <u>begin</u> LNPR ≔ LOGGAMMA(N+1);
            <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
                 <u>if</u> PVEC[J] = 0 <u>then</u>
               <u>begin</u> <u>if</u> XVEC[J] ≠ 0 <u>then</u>
                  <u>begin</u> MULNOMPROB ≔ 0;
                     <u>goto</u> OUT
                  <u>end</u>
               <u>end</u> <u>else</u>
                 LNPR ≔ LNPR - LOGGAMMA(XVEC[J]+1) +
                 XVEC[J] × LN(PVEC[J]);
            MULNOMPROB ≔ EXP(LNPR);
         <u>end</u>;
      <u>end</u>;
   <u>end</u>; OUT:
<u>end</u> MULNOMPROB;
<u>eop</u>
<u>code</u> 41256;
<u>real</u> <u>procedure</u> MULHYPERGPROB(X,N,K,R);
   <u>value</u> N,K; <u>real</u> N,K; <u>array</u> X,R;
<u>begin</u> <u>integer</u> I,J,L,SR,SX; <u>real</u> MHP,XJ,RJ;
   <u>if</u> N &lt; 1 ∨ N &gt; ENTIER(N) <u>then</u>
     STATAL3 ERROR(“MULHYPERGPROB”,2,N);
   <u>if</u> K &lt; 1 ∨ K &gt; ENTIER(K) <u>then</u>
     STATAL3 ERROR(“MULHYPERGPROB”,3,K);
   SX ≔ SR ≔ 0;
   MHP ≔ 0;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
      <u>begin</u> RJ ≔ R[J]; XJ ≔ X[J];
         <u>if</u> RJ &lt; 0 ∨ RJ &gt; ENTIER(RJ) <u>then</u>
           STATAL3 ERROR(“MULHYPERGPROB”,4,RJ);
         SR ≔ SR + RJ; SX ≔ SX + XJ;
         <u>if</u> XJ &gt; RJ ∨ XJ &lt; 0 ∨ XJ &gt; ENTIER(XJ) <u>then</u>
         <u>begin</u> MULHYPERGPROB ≔ 0; <u>goto</u> OUT <u>end</u>;
         MHP ≔ MHP + LOGGAMMA(RJ+1) - LOGGAMMA(XJ+1)
           - LOGGAMMA(RJ-XJ+1);
      <u>end</u> J ;
   <u>if</u> SX ≠ N <u>then</u>
   <u>begin</u> MULHYPERGPROB ≔ 0; <u>goto</u> OUT <u>end</u>;
   MHP ≔ MHP + LOGGAMMA(N+1) + LOGGAMMA(SR-N+1)
     - LOGGAMMA(SR+1);
   MULHYPERGPROB ≔ EXP(MHP);
   OUT:
<u>end</u> MULHYPERGPROB;
<u>eop</u>
<u>code</u> 41500;
<u>real</u> <u>procedure</u> PHI(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> ABSX, ERF, ERFC, C, P, Q;
   X ≔ X × ·70710 67811 8655; ABSX ≔ ABS(X);
   <u>if</u> X &gt; 5·5 <u>then</u> PHI ≔ 1 <u>else</u> <u>if</u> X &lt; -5·5
     <u>then</u> PHI ≔ 0 <u>else</u> <u>if</u> ABSX &LessSlantEqual; 0·5 <u>then</u>
   <u>begin</u> C ≔ X × X;
      P ≔ ((-0·35609 84370 1815&#9192;-1 × C +
        0·69963 83488 6191&#9192;+1) × C + 0·21979 26161 8294&#9192;+2)× C + 0·24266 79552 3053&#9192;+3;
      Q ≔ ((C +
        0·15082 79763 0408&#9192;+2) × C +
        0·91164 90540 4515&#9192;+2) × C +
        0·21505 88758 6986&#9192;+3;
      PHI ≔ ·5 × X × P / Q + ·5
   <u>end</u> <u>else</u>
   <u>begin</u> <u>if</u> ABSX &lt; 4 <u>then</u>
      <u>begin</u> C ≔ ABSX;
         P ≔ ((((((-0·13686 48573 8272&#9192;-6 × C +
           0·56419 55174 7897&#9192;+0) × C +
           0·72117 58250 8831&#9192;+1) × C +
           0·43162 22722 2057&#9192;+2) × C +
           0·15298 92850 4694&#9192;+3) × C +
           0·33932 08167 3434&#9192;+3) × C +
           0·45191 89537 1187&#9192;+3) × C +
           0·30045 92610 2016&#9192;+3;
         Q ≔ ((((((C +
           0·12782 72731 9629&#9192;+2) × C +
           0·77000 15293 5230&#9192;+2) × C +
           0·27758 54447 4399&#9192;+3) × C +
           0·63898 02644 6563&#9192;+3) × C +
           0·93135 40948 3061&#9192;+3) × C +
           0·79095 09253 2790&#9192;+3) × C +
           0·30045 92609 3698&#9192;+3;
         C ≔ P/Q
      <u>end</u> <u>else</u>
      <u>begin</u> C ≔ 1 / X / X;
         P ≔ (((0·22319 24597 3419&#9192;-1 × C +
           0·27866 13086 0965&#9192;-0) × C +
           0·22695 65935 3969&#9192;-0) × C +
           0·49473 09106 2325&#9192;-1) × C +
           0·29961 07077 0354&#9192;-2;
         Q ≔ (((C +
           0·19873 32018 1714&#9192;+1) × C +
           0·10516 75107 0679&#9192;+1) × C +
           0·19130 89261 0783&#9192;+0) × C +
           0·10620 92305 2847&#9192;-1;
         C ≔ (C × (-P) / Q + 0·56418 95835 4776) / ABSX
      <u>end</u>;
      PHI ≔ ·5 + ·5 × SIGN(X) × (1 - C × EXP(-X × X))
   <u>end</u>
<u>end</u> PHI;
<u>eop</u>
<u>code</u> 41501;
<u>real</u> <u>procedure</u> PHINV(PROB); <u>value</u> PROB; <u>real</u> PROB;
<u>begin</u> <u>real</u> EPS;
   <u>real</u> <u>procedure</u> INVERF(X); <u>value</u> X; <u>real</u> X;
   <u>begin</u> <u>real</u> ABSX, P, BETAX;
      <u>real</u> <u>array</u> A[0 : 23];
      <u>real</u> <u>procedure</u> CHEPOLSER(N, X, A);
         <u>value</u> N, X; <u>integer</u> N; <u>real</u> X; <u>array</u> A;
      <u>begin</u> <u>integer</u> K; <u>real</u> H, R, S, TX;
         TX ≔ X + X; R ≔ A[N];
         H ≔ A[N - 1] + R × TX;
         <u>for</u> K ≔ N - 2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> S ≔ R; R ≔ H;
               H ≔ A[K] + R × TX - S
            <u>end</u>;
         CHEPOLSER ≔ A[0]- R + H × X
      <u>end</u> CHEPOLSER;

      ABSX ≔ ABS(X);
      <u>if</u> ABSX &LessSlantEqual; 0·8 <u>then</u>
      <u>begin</u>
         A[ 0] ≔                 0·99288   53766   1894;
         A[ 1] ≔                 0·12046   75161   4310;
         A[ 2] ≔                 0·01607   81993   4210;
         A[ 3] ≔                 0·00268   67044   3716;
         A[ 4] ≔                 0·00049   96347   3024;
         A[ 5] ≔                 0·00009   88982   1860;
         A[ 6] ≔                 0·00002   03918   1276;
         A[ 7] ≔                 0·00000   43272   7162;
         A[ 8] ≔                 0·00000   09380   8141;
         A[ 9] ≔                 0·00000   02067   3472;
         A[10] ≔                 0·00000   00461   5970;
         A[11] ≔                 0·00000   00104   1668;
         A[12] ≔                 0·00000   00023   7150;
         A[13] ≔                 0·00000   00005   4393;
         A[14] ≔                 0·00000   00001   2555;
         A[15] ≔                 0·00000   00000   2914;
         A[16] ≔                 0·00000   00000   0680;
         A[17] ≔                 0·00000   00000   0159;
         A[18] ≔                 0·00000   00000   0037;
         A[19] ≔                 0·00000   00000   0009;
         A[20] ≔                 0·00000   00000   0002;
         A[21] ≔                 0·00000   00000   0001;
         INVERF ≔ CHEPOLSER(21, X × X / 0·32 - 1, A) × X
      <u>end</u> <u>else</u>
      <u>if</u> 1 - ABSX &GreaterSlantEqual; 25&#9192;-4 <u>then</u>
      <u>begin</u>
         A[ 0] ≔                      0·91215   88034   1755;
         A[ 1] ≔                     -0·01626   62818   6766;
         A[ 2] ≔                      0·00043   35564   7295;
         A[ 3] ≔                      0·00021   44385   7007;
         A[ 4] ≔                      0·00000   26257   5108;
         A[ 5] ≔                     -0·00000   30210   9105;
         A[ 6] ≔                     -0·00000   00124   0606;
         A[ 7] ≔                      0·00000   00624   0661;
         A[ 8] ≔                     -0·00000   00005   4015;
         A[ 9] ≔                     -0·00000   00014   2321;
         A[10] ≔                      0·00000   00000   3438;
         A[11] ≔                      0·00000   00000   3358;
         A[12] ≔                     -0·00000   00000   0146;
         A[13] ≔                     -0·00000   00000   0081;
         A[14] ≔                      0·00000   00000   0005;
         A[15] ≔                      0·00000   00000   0002;
         BETAX ≔ SQRT(- LN((1 + ABSX) × (1 - ABSX)));
         P ≔ -1·54881 30423 7326 × BETAX +
           2·56549 01231 4782;
         P ≔ CHEPOLSER(15, P, A);
         INVERF ≔ <u>if</u> X &lt; 0 <u>then</u> - BETAX × P
         <u>else</u> BETAX × P
      <u>end</u> <u>else</u>
      <u>begin</u>
         A[ 0] ≔    0·95667 97090   2049;
         A[ 1] ≔   -0·02310 70043   0907;
         A[ 2] ≔   -0·00437 42360   9751;
         A[ 3] ≔   -0·00057 65034   2265;
         A[ 4] ≔   -0·00001 09610   2231;
         A[ 5] ≔    0·00002 51085   4703;
         A[ 6] ≔    0·00001 05623   3607;
         A[ 7] ≔    0·00000 27544   1233;
         A[ 8] ≔    0·00000 04324   8450;
         A[ 9] ≔   -0·00000 00205   3034;
         A[10] ≔   -0·00000 00438   9154;
         A[11] ≔   -0·00000 00176   8401;
         A[12] ≔   -0·00000 00039   9129;
         A[13] ≔   -0·00000 00001   8693;
         A[14] ≔    0·00000 00002   7292;
         A[15] ≔    0·00000 00001   3282;
         A[16] ≔    0·00000 00000   3183;
         A[17] ≔    0·00000 00000   0167;
         A[18] ≔   -0·00000 00000   0204;
         A[19] ≔   -0·00000 00000   0097;
         A[20] ≔   -0·00000 00000   0022;
         A[21] ≔   -0·00000 00000   0001;
         A[22] ≔    0·00000 00000   0001;
         A[23] ≔    0·00000 00000   0001;
         BETAX ≔   SQRT(- LN((1 +   ABSX) × (1 - ABSX)));
         P ≔ -0·55945 76313 29832 × BETAX +
           2·28791 57162 6336;
         P ≔ CHEPOLSER(23, P, A);
         INVERF ≔ <u>if</u> X &lt; 0 <u>then</u> - BETAX × P
         <u>else</u> BETAX × P
      <u>end</u>
   <u>end</u> INVERSE ERROR FUNCTION;
   EPS ≔ &#9192;-14;
   <u>if</u> PROB &lt; EPS ∨ 1 - PROB &lt; EPS <u>then</u>
     STATAL3 ERROR(“PHINV”, 1, PROB);
   PHINV ≔ INVERF(2 × PROB - 1) × 1·41421356237310
<u>end</u> PHINV;
<u>eop</u>
<u>code</u> 41502;
<u>real</u> <u>procedure</u> NORMAL(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
   NORMAL ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“NORMAL”, 3, SIGMA)
   <u>else</u> PHI((X - MU) / SIGMA);
<u>eop</u>
<u>code</u> 41503;
<u>real</u> <u>procedure</u> NORMALINV(PROB, MU, SIGMA);
   <u>value</u> PROB, MU, SIGMA; <u>real</u> PROB, MU, SIGMA;
   NORMALINV ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“NORMALINV”, 3, SIGMA)
   <u>else</u> <u>if</u> PROB &lt; &#9192;-14 ∨ PROB &gt; 1 - &#9192;-14
     <u>then</u> STATAL3 ERROR(“NORMALINV”, 1, PROB)
   <u>else</u> MU + PHINV(PROB) × SIGMA;
<u>eop</u>
<u>code</u> 41506;
<u>real</u> <u>procedure</u> CHISQ(X, DF);
   <u>value</u> X, DF; <u>real</u> X, DF;
   CHISQ ≔ <u>if</u> DF &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“CHISQ”, 2, DF)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0 <u>else</u>
     GAMMA(X, DF / 2, 2);
<u>eop</u>
<u>code</u> 41507;
<u>real</u> <u>procedure</u> CHISQINV(PROB, DF);
   <u>value</u> PROB, DF; <u>real</u> PROB, DF;
   <u>if</u> PROB &lt; &#9192;-10 ∨ PROB &gt; 1 - &#9192;-10
     <u>then</u> STATAL3 ERROR(“CHISQINV”, 1, PROB)
     <u>else</u> <u>if</u> DF &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“CHISQINV”, 2, DF)
   <u>else</u>
   <u>begin</u> <u>real</u> X;
      X ≔ PHINV(PROB) × SQRT(2 × DF) + DF;
      CHISQINV ≔ INVERSE(X, CHISQ(X, DF), PROB, &#9192;-10)
   <u>end</u> CHISQINV;
<u>eop</u>
<u>code</u> 41509;
<u>real</u> <u>procedure</u> NCCHISQ(X, DF, DELTA);
   <u>value</u> X, DF, DELTA; <u>real</u> X, DF, DELTA;
<u>begin</u> <u>real</u> FACTOR1, FACTOR2, PROB, SUM, TERM;
   <u>integer</u> M;
   <u>if</u> DF &lt; 1 ∨ DF &gt; ENTIER(DF) <u>then</u>
     STATAL3ERROR(“NCCHISQ”, 2, DF);
   <u>if</u> DELTA &lt; 0 <u>then</u>
     STATAL3ERROR(“NCCHISQ”, 3, DELTA);
   <u>if</u> X &LessSlantEqual; 0 <u>then</u> NCCHISQ ≔ 0 <u>else</u>
   <u>if</u> DELTA = 0 <u>then</u> NCCHISQ ≔ CHISQ(X, DF) <u>else</u>
   <u>begin</u> PROB ≔ CHISQ(X, DF); X ≔ X / 2; DF ≔ DF / 2;
      DELTA ≔ DELTA / 2; FACTOR1 ≔ EXP(-DELTA);
      FACTOR2 ≔ EXP(DF × LN(X) - X - LOGGAMMA(DF + 1));
      TERM ≔ SUM ≔ PROB × FACTOR1; M ≔ 0;
      <u>for</u> M ≔ M + 1
        <u>while</u> ¬( TERM &lt; &#9192;-9 ∧ M &gt; DELTA ) <u>do</u>
         <u>begin</u> FACTOR1 ≔ FACTOR1 × DELTA / M;
            PROB ≔ PROB - FACTOR2;
            FACTOR2 ≔ FACTOR2 × X / (DF + M);
            TERM ≔ PROB × FACTOR1; SUM ≔ SUM + TERM
         <u>end</u>;
      NCCHISQ ≔ SUM
   <u>end</u>;
<u>end</u> NCCHISQ;
<u>eop</u>
<u>code</u> 41513;
<u>real</u> <u>procedure</u> GAMMA(X, ALPHA, SCALE);
   <u>value</u> X, ALPHA, SCALE; <u>real</u> X, ALPHA, SCALE;
<u>begin</u> <u>integer</u> DELTA, UPP;
   <u>real</u> BETA, START, SUM, TERM;

   <u>real</u> <u>procedure</u> INCGAM(X, A, EPS);
      <u>value</u> X, A, EPS; <u>real</u> X, A, EPS;
   <u>begin</u> <u>real</u> C0, C1, C2, D0, D1, D2, X2, AX, P,
        Q, R, S, R1, R2, SCF; <u>integer</u> N;
      S ≔ EXP(-X + A × LN(X)); SCF ≔ &#9192;+300;
      <u>if</u> X &LessSlantEqual; 1 <u>then</u>
      <u>begin</u> X2 ≔ X × X; AX ≔ A × X;
         D0 ≔ 1; P ≔ A; C0 ≔ S;
         D1 ≔ (A + 1) × (A + 2 - X);
         C1 ≔ (D1 + AX + 2 × X) × S;
         R2 ≔ C1 / D1;
         <u>for</u> N ≔ 1, N + 1
           <u>while</u> ABS((R2 - R1) / R2) &gt; EPS <u>do</u>
            <u>begin</u> P ≔ P + 2;
               Q ≔ (P + 1) × (P × (P + 2) - AX);
               R ≔ N × (N + A) × (P + 2) × X2;
               C2 ≔ (Q × C1 + R × C0) / P;
               D2 ≔ (Q × D1 + R × D0) / P;
               R1 ≔ R2; R2 ≔ C2 / D2;
               C0 ≔ C1; C1 ≔ C2; D0 ≔ D1; D1 ≔ D2;
               <u>if</u> ABS(C1) &gt; SCF ∨ ABS(D1) &gt; SCF <u>then</u>
               <u>begin</u> C0 ≔ C0 / SCF; C1 ≔ C1 / SCF;
                  D0 ≔ D0 / SCF; D1 ≔ D1 / SCF
               <u>end</u>
            <u>end</u>; INCGAM ≔ R2 / A / EXP(LOGGAMMA(A))
      <u>end</u> <u>else</u>
      <u>begin</u> C0 ≔ A × S; C1 ≔ (1 + X) × C0;
         Q ≔ X + 2 - A;
         D0 ≔ X; D1 ≔ X × Q; R2 ≔ C1 / D1;
         <u>for</u> N ≔ 1, N + 1
           <u>while</u> ABS((R2 - R1) / R2) &gt; EPS <u>do</u>
            <u>begin</u> Q ≔ Q + 2; R ≔  × (N + 1 - A);
               C2 ≔ Q × C1 - R × C0; D2 ≔ Q × D1 - R × D0;
               R1 ≔ R2; R2 ≔ C2 / D2;
               C0 ≔ C1; C1 ≔ C2; D0 ≔ D1; D1 ≔ D2;
               <u>if</u> ABS(C1) &gt; SCF ∨ ABS(D1) &gt; SCF <u>then</u>
               <u>begin</u> C0 ≔ C0 / SCF; C1 ≔ C1 / SCF;
                  D0 ≔ D0 / SCF; D1 ≔ D1 / SCF
               <u>end</u>
            <u>end</u>; INCGAM ≔ 1 - R2 / A / EXP(LOGGAMMA(A))
      <u>end</u>
   <u>end</u> INCGAM;

   <u>if</u> ALPHA &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“GAMMA”, 2, ALPHA)
     <u>else</u> <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“GAMMA”, 3, SCALE)
     <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> GAMMA ≔ 0 <u>else</u>
   <u>if</u> ALPHA &GreaterSlantEqual; 500 <u>then</u>
   <u>begin</u>
      GAMMA ≔ PHI(((X / SCALE / ALPHA) ⭡ ·33333333353333
        - 1 + 1 / (9 × ALPHA)) × 3 × SQRT(ALPHA))
   <u>end</u> <u>else</u>
   <u>begin</u> X ≔ X / SCALE; BETA ≔ ALPHA - ENTIER(ALPHA) + 1;
      START ≔ <u>if</u> X &GreaterSlantEqual; 40 <u>then</u> 1 <u>else</u>
        INCGAM(X, BETA, &#9192;-12);
      <u>if</u> ALPHA &lt; 1 <u>then</u>
        GAMMA ≔ START + EXP(-X + ALPHA × LN(X)
        - LOGGAMMA(ALPHA + 1))
        <u>else</u> <u>if</u> ALPHA &lt; 2 <u>then</u> GAMMA ≔ START
        <u>else</u> <u>if</u> X &gt; 700 <u>then</u> GAMMA ≔ 1
      <u>else</u>
      <u>begin</u> UPP ≔ ENTIER(ALPHA) - 2; SUM ≔ TERM ≔            EXP(-X + (ALPHA - 1) × LN(X) - LOGGAMMA(ALPHA));
         <u>for</u> DELTA ≔ 1 <u>step</u> 1 <u>until</u> UPP <u>do</u>
            <u>begin</u> TERM ≔ TERM × (ALPHA - DELTA) / X;
               SUM ≔ SUM + TERM
            <u>end</u>;
         GAMMA ≔ START - SUM
      <u>end</u>
   <u>end</u>
<u>end</u> GAMMA;
<u>eop</u>
<u>code</u> 41514;
<u>real</u> <u>procedure</u> GAMMAINV(PROB,ALPHA,SCALE);
   <u>value</u> PROB,ALPHA,SCALE; <u>real</u> PROB,ALPHA,SCALE;
<u>begin</u> <u>real</u> X,TOL;

   TOL ≔ &#9192;-10;
   <u>if</u> ALPHA &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“GAMMAINV”,2,ALPHA) <u>else</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“GAMMAINV”,3,SCALE) <u>else</u>
   <u>if</u> PROB &LessSlantEqual; TOL ∨ PROB &GreaterSlantEqual; 1 - TOL <u>then</u>
     STATAL3 ERROR(“GAMMAINV”,1,PROB);
   X ≔ ALPHA × SCALE;
   GAMMAINV ≔ INVERSE(X,GAMMA(X,ALPHA,SCALE),PROB, TOL)
<u>end</u> GAMMAINV;
<u>eop</u>
<u>code</u> 41517;
<u>real</u> <u>procedure</u> BETA(X, ALPHA1, ALPHA2);
   <u>value</u> X, ALPHA1, ALPHA2; <u>real</u> X, ALPHA1, ALPHA2;
   BETA ≔ <u>if</u> ALPHA1 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“BETA”, 2, ALPHA1)
   <u>else</u> <u>if</u> ALPHA2 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“BETA”, 3, ALPHA2)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0
   <u>else</u> <u>if</u> X &GreaterSlantEqual; 1 <u>then</u> 1
   <u>else</u> INCOMPLETE BETA(X, ALPHA1, ALPHA2, &#9192;-12);
<u>eop</u>
<u>code</u> 41518;
<u>real</u> <u>procedure</u> BETAINV(PROB,ALPHA1,ALPHAZ2);
   <u>value</u> PROB,ALPHA1,ALPHA2; <u>real</u> PROB,ALPHA1,ALPHA2;
<u>begin</u> <u>real</u> X,Y,TOL;

   <u>comment</u> DEFINE ACCURACY;
   TOL ≔ &#9192;-10;

   <u>comment</u> TEST FOR ADMISSIBILITY OF PARAMETERS;
   <u>if</u> ALPHA1 &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“BETAINV”,2,ALPHA1)
     <u>else</u>
   <u>if</u> ALPHA2 &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“BETAINV”,3,ALPHA2)
     <u>else</u>
   <u>if</u> PROB &LessSlantEqual; TOL ∨ PROB &GreaterSlantEqual; 1 - TOL <u>then</u>
     STATAL3 ERROR(“BETAINV”,1,PROB);

   X ≔ 0;
   BETAINV ≔ INVERSE(X,BETA(X,ALPHA1,ALPHA2),PROB,TOL)
<u>end</u> BETAINV;
<u>eop</u>
<u>code</u> 41521;
<u>real</u> <u>procedure</u> FISHER(X, DF1, DF2); <u>value</u> X, DF1, DF2;
   <u>real</u> X, DF1, DF2;
<u>begin</u> <u>real</u> IB;

   <u>if</u> DF1 &LessSlantEqual; 0 <u>then</u>
     FISHER ≔ STATAL3 ERROR(“FISHER”,2,DF1)
     <u>else</u>
   <u>if</u> DF2 &LessSlantEqual; 0 <u>then</u>
     FISHER ≔ STATAL3 ERROR(“FISHER”,3,DF2)
     <u>else</u>
   <u>if</u> X &LessSlantEqual; 0 <u>then</u> FISHER ≔ 0
   <u>else</u>
   <u>begin</u> IB ≔ INCOMPLETE BETA(DF2/(DF2 + DF1 × X)
        , DF2/2,DF1/2,&#9192;-12);
      <u>if</u> IB &lt; 0 <u>then</u> IB ≔ 0
        <u>else</u> <u>if</u> IB &gt; 1 <u>then</u> IB ≔ 1;
      FISHER ≔ 1 - IB
   <u>end</u>
<u>end</u> FISHER;
<u>eop</u>
<u>code</u> 41522;
<u>real</u> <u>procedure</u> FISHERINV(PROB, DF1, DF2);
   <u>value</u> PROB, DF1, DF2; <u>real</u> PROB, DF1, DF2;
<u>begin</u>
   <u>if</u> PROB &lt; &#9192;-10 ∨ PROB &gt; 1 - &#9192;-10
     <u>then</u> STATAL3 ERROR(“FISHERINV”, 1, PROB)
     <u>else</u> <u>if</u> DF1 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“FISHERINV”, 2, DF1)
     <u>else</u> <u>if</u> DF2 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“FISHERINV”, 3, DF2)
   <u>else</u>
   <u>begin</u> <u>real</u> X;
      X ≔ <u>if</u> PROB &LessSlantEqual; ·5 <u>then</u> ·5 <u>else</u>
        <u>if</u> DF2 &LessSlantEqual; 4 <u>then</u> 1 <u>else</u>
        DF2 / (DF2 - 2) + PHINV(PROB) ×
        SQRT(2 × DF2 × DF2 × (DF1 + DF2 - 2) /
        (DF1 × (DF2 - 4) × (DF2- 2) × (DF2 - 2)));
      FISHERINV ≔         INVERSE(X, FISHER(X, DF1, DF2), PROB, &#9192;-10)
   <u>end</u>
<u>end</u> FISHERINV;
<u>eop</u>
<u>code</u> 41525;
<u>real</u> <u>procedure</u> NCFISHER(X,DF1,DF2,DELTA);
   <u>value</u> X,DF1,DF2,DELTA; <u>real</u> X,DF1,DF2,DELTA;
<u>begin</u> <u>integer</u> J; <u>real</u> XX,FAKTOR1,FAKTOR2,EPS,SUM;

   <u>if</u> DF1 &LessSlantEqual; 0 <u>then</u> STATAL3 ERROR(“NCFISHER”,2,DF1)
     <u>else</u>
   <u>if</u> DF2 &LessSlantEqual; 0 <u>then</u> STATAL3 ERROR(“NCFISHER”,3,DF2)
     <u>else</u>
   <u>if</u> DELTA &lt; 0 <u>then</u>
     STATAL3 ERROR(“NCFISHER”,4,DELTA)
     <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> NCFISHER ≔ 0 <u>else</u>
   <u>begin</u> XX ≔ (DF1 × X) / (DF1 × X + DF2); EPS ≔ &#9192;-12;
      DF1 ≔ DF1 / 2; DF2 ≔ DF2 / 2; DELTA ≔ DELTA / 2;
      FAKTOR1 ≔ 1;
      FAKTOR2 ≔ SUM ≔ INCOMPLETE BETA(XX,DF1,DF2,EPS);
      <u>if</u> DELTA = 0 <u>then</u> <u>goto</u> UIT;
      J ≔ 0; <u>for</u> J ≔ J + 1 <u>while</u> FAKTOR2 &gt; EPS <u>do</u>
         <u>begin</u> FAKTOR1 ≔ FAKTOR1 × DELTA / J;
            FAKTOR2 ≔ FAKTOR1 ×
              INCOMPLETE BETA(XX,DF1 + J,DF2,EPS);
            SUM ≔ SUM + FAKTOR2
         <u>end</u>;
      UIT: NCFISHER ≔ EXP(-DELTA) × SUM
   <u>end</u>
<u>end</u> NCFISHER;
<u>eop</u>
<u>code</u> 41530;
<u>real</u> <u>procedure</u> STUDENT(X, DF); <u>value</u> X, DF;
   <u>real</u> X, DF;
<u>begin</u> <u>real</u>IB;

   <u>if</u> DF &LessSlantEqual; 0 <u>then</u>
     STUDENT ≔ STATAL3 ERROR(“STUDENT”,2,DF)
   <u>else</u>
   <u>begin</u> IB ≔         INCOMPLETE BETA(DF/(DF + X × X),DF/2,0·5,&#9192;-12);
      <u>if</u> IB &lt; 0 <u>then</u> IB ≔ 0
        <u>else</u> <u>if</u> IB &gt; 2 <u>then</u> IB ≔ 2;
      STUDENT ≔ <u>if</u> X &lt; 0 <u>then</u> IB / 2 <u>else</u> 1 - IB / 2
   <u>end</u>
<u>end</u> STUDENT;
<u>eop</u>
<u>code</u> 41531;
<u>real</u> <u>procedure</u> STUDENTINV(PROB, DF);
   <u>value</u> PROB, DF; <u>real</u> PROB, DF;
<u>begin</u>
   <u>if</u> PROB &lt; &#9192;-10 ∨ PROB &gt; 1 - &#9192;-10
     <u>then</u> STATAL3 ERROR(“STUDENTINV”, 1, PROB)
     <u>else</u> <u>if</u> DF &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“STUDENTINV”, 2, DF)
   <u>else</u>
   <u>begin</u> <u>real</u> X, U, U2;
      U ≔ PHINV(PROB); U2 ≔ U × U;
      X ≔ U × (1 + (U2 + 1) / 4 / DF +
        (3 + U2 × (U2 × 5 + 16)) / 96 / DF / DF);
      STUDENTINV ≔ INVERSE(X, STUDENT(X, DF), PROB, &#9192;-10)
   <u>end</u>
<u>end</u> STUDENTINV;
<u>eop</u>
<u>code</u> 41533;
<u>real</u> <u>procedure</u> NCSTUDENT(X, DF, DELTA);
   <u>value</u> X, DF, DELTA; <u>real</u> X, DF, DELTA;
<u>begin</u> <u>real</u> A, B, A2, WB, D2, TOL, TOLI, H, HELP, RESULT;
   <u>Boolean</u> DFEVEN;

   <u>real</u> <u>procedure</u> INTEGRATE(Y0, Y4, F0, F2, F4);
      <u>value</u> Y0, Y4, F0, F2, F4; <u>real</u> Y0, Y4, F0, F2, F4;
   <u>begin</u> <u>real</u> F1, F3, Y2, TEE, Y;
      Y2 ≔ Y0 + Y4)/2;
      Y ≔ Y0 + Y2)/2; F1 ≔ EXP(H×(1 + Y×Y))/(1 + Y×Y);
      Y ≔ Y2 + Y4)/2; F3 ≔ EXP(H×(1 + Y×Y))/(1 + Y×Y);
      TEE ≔ ×F2 - 4×(F1 + F3) + F0 + F4;
      INTEGRATE ≔ ̲<u>f</u> ABS(TEE) &lt; TOLI
        <u>then</u> (Y4 - Y0)×(4×(F1 + F3) + 2×F2 +
        F0 + F4 - TEE/15)
      <u>else</u> INTEGRATE(Y0, Y2, F0, F1, F2) +
        INTEGRATE(Y2, Y4, F2, F3, F4);
   <u>end</u> INTEGRATE;

   <u>real</u> <u>procedure</u> SUMMATION OF FACTORS M;
   <u>begin</u> <u>integer</u> I;
      <u>real</u> MSUM, COEF, MIMIN2, MIMIN1, MI;
      <u>Boolean</u> ADD;
      MSUM ≔ 0;
      <u>if</u> DF &gt; 1 <u>then</u>
      <u>begin</u>
         MIMIN2 ≔ A×WB × EXP(H) × PHI(HELP×WB) ×·3989422804;
         <u>if</u> DFEVEN <u>then</u> MSUM ≔ MSUM + MIMIN2;
         <u>if</u> DF &gt; 2 <u>then</u>
         <u>begin</u> COEF ≔ 1;
            MIMIN1 ≔ B×(HELP×MIMIN2 +
              A×·1591549431×EXP(-·5×D2));
            <u>if</u> ¬ DFEVEN <u>then</u> MSUM ≔ MSUM + MIMIN1;
            ADD ≔ DFEVEN;
            <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> DF - 2 <u>do</u>
               <u>begin</u> MI ≔ (I - 1)/I×B×
                    (COEF×HELP×MIMIN1 + MIMIN2);
                  <u>if</u> ADD <u>then</u> MSUM ≔ MSUM + MI;
                  ADD ≔  ADD; COEF ≔ 1/(I - 1)/COEF;
                  MIMIN2 ≔ MIMIN1; MIMIN1 ≔ MI;
               <u>end</u> I;
         <u>end</u> DF&gt;2;
      <u>end</u> DF&gt;1;
      SUMMATION OF FACTORS M ≔ MSUM;
   <u>end</u> SUMMATION OF FACTORS M;

   <u>procedure</u> INITIALISATION;
   <u>begin</u> TOL ≔ &#9192;-8;
      <u>if</u> DF &lt; 1 ∨ ENTIER(DF) ≠ DF <u>then</u>
        STATAL3 ERROR(“NCSTUDENT”, 2, DF);
      DFEVEN ≔ ENTIER(DF/2) = DF/2;
      A ≔ X/SQRT(DF); A2 ≔ A×A; D2 ≔ DELTA×DELTA;
      HELP ≔ DELTA×A;
      B ≔ F/(DF + X×X); WB ≔ SQRT(B); H ≔ D2×B×·5;
      <u>if</u> ABS(A) &gt; TOL <u>then</u> TOLI ≔ 180 × TOL / ABS(A);
   <u>end</u> INITIALISATION;

   INITIALISATION;

   RESULT ≔      <u>if</u> DFEVEN <u>then</u>
     PHI(-DELTA) + SUMMATION OF FACTORS M × 2·5066282746
   <u>else</u>
     PHI(-DELTA×WB) + SUMMATION OF FACTORS M × 2 +
     (<u>if</u> ABS(A) &LessSlantEqual; TOL <u>then</u> 0 <u>else</u>·31830 98862 × INTEGRATE(0, A, EXP(H),
     EXP(H×(1 + A2/4))/(1 + A2/4),
     EXP(H×(1 + A2))/(1 + A2)) / 12);

   NCSTUDENT ≔      <u>if</u> TOL &LessSlantEqual; RESULT ∧ RESULT &LessSlantEqual; 1 - TOL <u>then</u> RESULT
   <u>else</u>
     <u>if</u> ABS(RESULT) &lt; TOL <u>then</u> 0 <u>else</u>
     <u>if</u> ABS(RESULT - 1) &lt; TOL <u>then</u> 1 <u>else</u>
     STATAL3 ERROR(“NCSTUDENT”, 0, RESULT);
<u>end</u> NCSTUDENT;
<u>eop</u>
<u>code</u> 41534;
<u>real</u> <u>procedure</u> NCSTUDENTINVC(PROB, DF, DELTA);
   <u>value</u> PROB, DF, DELTA; <u>real</u> PROB, DF, DELTA;
<u>begin</u> <u>real</u> X, Y, TOL;

   <u>procedure</u> CORNISH FISHER EXPANSION;
   <u>begin</u> <u>real</u> UA, UA2, UA3, UA4, UA5;
      <u>integer</u> DF4, DFDF;
      UA ≔ HINV(PROB);
      UA2 ≔ A×UA; UA3 ≔ A2×UA; UA4 ≔ A2×UA2;
      UA5 ≔ A4×UA; DF4 ≔ F×4; DFDF ≔ F×DF;
      X ≔ UA/DFDF/32;
      X ≔ ×DELTA - (UA2 - 1)/DFDF/24;
      X ≔ ×DELTA + UA/DF4 + (UA3 + UA×4)/DFDF/16;
      X ≔ ×DELTA + 1 + (UA2×2 + 1)/DF4 +
        (UA4×4 + UA2×12 + 1)/DFDF/32;
      X ≔ ×DELTA + UA + (UA3 + UA)/DF4 + (UA5×5 + UA3×16
        + UA×3)/DFDF/96;
   <u>end</u> INITIAL APPROXIMATION BY CORNISH-FISHER METHOD;

   TOL ≔ &#9192;-7;
   <u>if</u> PROB &lt; TOL ∨ PROB &gt; 1 - TOL <u>then</u>
     STATAL3 ERROR(“NCSTUDENTINV”, 1, PROB);
   <u>if</u> DF &lt; 1 ∨ ENTIER(DF) ≠ DF <u>then</u>
     STATAL3 ERROR(“NCSTUDENTINV”, 2, DF);

   CORNISH FISHER EXPANSION;

   NCSTUDENTINV ≔      INVERSE(X, NCSTUDENT(X, DF, DELTA), PROB, TOL)
<u>end</u> NCSTUDENTINV;
<u>eop</u>
<u>code</u> 41539;
<u>real</u> <u>procedure</u> LOGNORMAL(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
   LOGNORMAL ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“LOGNORMAL”, 3, SIGMA)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0
   <u>else</u> PHI((LN(X) - MU) / SIGMA);
<u>eop</u>
<u>code</u> 41540;
<u>real</u> <u>procedure</u> LOGNORMALINV(PROB, MU, SIGMA);
   <u>value</u> PROB, MU, SIGMA; <u>real</u> PROB, MU, SIGMA;
   LOGNORMALINV ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“LOGNORMALINV”, 3, SIGMA)
   <u>else</u> <u>if</u> PROB &lt; &#9192;-14 ∨ PROB &gt; 1 - &#9192;-14
     <u>then</u> STATAL3 ERROR(“LOGNORMALINV”, 1, PROB)
   <u>else</u> EXP(PHINV(PROB) × SIGMA + MU);
<u>eop</u>
<u>code</u> 41541;
<u>real</u> <u>procedure</u> CAUCHY(X, LOC, SCALE);
   <u>value</u> X, LOC, SCALE; <u>real</u> X, LOC, SCALE;
   CAUCHY ≔ <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“CAUCHY”, 3, SCALE)
   <u>else</u> ARCTAN((X - LOC) / SCALE) × ·31830988618379 + ·5;
<u>eop</u>
<u>code</u> 41542;
<u>real</u> <u>procedure</u> CAUCHYINV (PROB, LOC, SCALE);
   <u>value</u> PROB, LOC, SCALE; <u>real</u> PROB, LOC, SCALE;
<u>begin</u> <u>real</u> ARG;
   ARG ≔ 3·1415 92653 5898 × PROB;
   CAUCHYINV ≔ <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR (“CAUCHYINV”, 1, PROB)
   <u>else</u> <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR (“CAUCHYINV”, 3, SCALE)
   <u>else</u>
     -SCALE × COS (ARG) / SIN (ARG) + LOC
<u>end</u> CAUCHYINV;
<u>eop</u>
<u>code</u> 41545;
<u>real</u> <u>procedure</u> WEIBULL(X, LOC, SCALE, ALPHA);
   <u>value</u> X, LOC, SCALE, ALPHA; <u>real</u> X, LOC, SCALE, ALPHA;
   WEIBULL ≔ <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“WEIBULL”, 3, SCALE)
   <u>else</u> <u>if</u> ALPHA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“WEIBULL”, 4, ALPHA)
   <u>else</u> <u>if</u> X &LessSlantEqual; LOC <u>then</u> 0
   <u>else</u> 1 - EXP(-((X - LOC) / SCALE) ⭡ ALPHA);
<u>eop</u>
<u>code</u> 41546;
<u>real</u> <u>procedure</u> WEIBULLINV(PROB,LOC,SCALE,ALPHA);
   <u>value</u> PROB,LOC,SCALE,ALPHA; <u>real</u> PROB,LOC,SCALE,ALPHA;
<u>begin</u>
   <u>if</u> PROB &LessSlantEqual; &#9192;-10 ∨ PROB &GreaterSlantEqual; 1 - &#9192;-10 <u>then</u>
     STATAL3 ERROR(“WEIBULLINV”,1,PROB) <u>else</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“WEIBULLINV”,3,SCALE)
     <u>else</u>
   <u>if</u> ALPHA &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“WEIBULLINV”,4,ALPHA);

   WEIBULLINV ≔ LOC + SCALE × (-LN(1 - PROB)) ⭡ (1 / ALPHA)
<u>end</u> WEIBULLINV;
<u>eop</u>
<u>code</u> 41550;
<u>real</u> <u>procedure</u> LOGISTIC(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
   LOGISTIC ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“LOGISTIC”, 3, SIGMA)
   <u>else</u> 1 / (1 + EXP(-(X - MU) / SIGMA));
<u>eop</u>
<u>code</u> 41551;
<u>real</u> <u>procedure</u> LOGISTICINV (PROB, MU, SIGMA);
   <u>value</u> PROB, MU, SIGMA; <u>real</u> PROB, MU, SIGMA;
   LOGISTICINV ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u>   STATAL3 ERROR(“LOGISTICINV”, 3, SIGMA)
   <u>else</u>   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1
     <u>then</u>   STATAL3 ERROR(“LOGISTICINV”, 1, PROB)
   <u>else</u>   - SIGMA × LN((1 - PROB) / PROB) + MU;
<u>eop</u>
<u>code</u> 41556;
<u>real</u> <u>procedure</u> KOLSMIR(D, XSIZE, YSIZE, EPS);
   <u>value</u> D, XSIZE, YSIZE, EPS; <u>real</u> D, XSIZE, YSIZE, EPS;
<u>begin</u> <u>integer</u> I, KGV, M, N;
   <u>integer</u> <u>procedure</u> GGD(M, N);
      <u>value</u> M, N; <u>integer</u> M, N;
      GGD ≔ <u>if</u> N = 0 <u>then</u> M <u>else</u> GGD(N, M - M ÷ N × N);

   <u>procedure</u> APPROX;
   <u>begin</u> <u>integer</u> K; <u>real</u> SUM, X, TERM, THETA;
      SUM ≔ ·5; THETA ≔ (1 + (M / KGV) ⭡ 1·2) / (M + N);
      X ≔ (I / KGV + THETA) ⭡ 2 × 2 / (1 / M + 1 / N);
      <u>for</u> K ≔ 1, K + 2 <u>while</u> TERM &gt; EPS <u>do</u>
         <u>begin</u> TERM ≔ EXP(-X × K × K);
            SUM ≔ SUM - TERM × (1 - EXP(-X × (2 × K + 1)))
         <u>end</u>;
      KOLSMIR ≔ 2 × SUM
   <u>end</u>;

   <u>procedure</u> EXACT;
   <u>begin</u> <u>integer</u> <u>array</u> LOW[0:N]; <u>array</u> H[0:M];
      <u>integer</u> DMN, MN1, X, Y, UPP; <u>real</u> SUM, BINCOEF;
      BINCOEF ≔ 1; LOW[0] ≔ 0; MN1 ≔ M + N + 1;
      DMN ≔ I × M × N / KGV;
      <u>for</u> X ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>integer</u> T, TN;
            T ≔ M × X - DMN; TN ≔ T ÷ N;
            LOW[X] ≔ <u>if</u> T &LessSlantEqual; 0 <u>then</u> 0 <u>else</u>
              <u>if</u> TN = T / N <u>then</u> TN <u>else</u> TN + 1;
            BINCOEF ≔ BINCOEF × (MN1 - X) / X;
            <u>if</u> BINCOEF &gt; &#9192;318 <u>then</u>
            <u>begin</u> EPS ≔ &#9192;-4;<u>goto</u> L <u>end</u>
         <u>end</u>;
      H[0] ≔ 1;
      <u>for</u> Y ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> H[Y] ≔ 0;
      <u>for</u> X ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> Y ≔ LOW[X]; SUM ≔ H[Y];
            UPP ≔ M - LOW[N - X];
            <u>for</u>  Y ≔ Y + 1 <u>step</u> 1 <u>until</u> UPP <u>do</u>
                 H[Y] ≔ SUM ≔ SUM + H[Y]
         <u>end</u>;
      KOLSMIR ≔ SUM / BINCOEF
   <u>end</u>;
   <u>if</u> XSIZE &LessSlantEqual; 0 ∨ XSIZE &gt; ENTIER(XSIZE) <u>then</u>
     STATAL3 ERROR(“KOLSMIR”, 2, XSIZE);
   <u>if</u> YSIZE &LessSlantEqual; 0 ∨ YSIZE &gt; ENTIER(YSIZE) <u>then</u>
     STATAL3 ERROR(“KOLSMIR”, 3, YSIZE);
   <u>if</u> XSIZE &lt; YSIZE <u>then</u>
   <u>begin</u> N ≔ XSIZE; M ≔ YSIZE <u>end</u>
   <u>else</u> <u>begin</u> M ≔ XSIZE; N ≔ YSIZE <u>end</u>;
   <u>if</u> EPS &lt; 0 ∨ EPS &gt; &#9192;-2 <u>then</u> EPS ≔ &#9192;-3;
   <u>if</u> XSIZE &lt; YSIZE <u>then</u>
   <u>begin</u> N ≔ XSIZE; M ≔ YSIZE <u>end</u>
   <u>else</u> <u>begin</u> M ≔ XSIZE; N ≔ YSIZE <u>end</u>;
   KGV ≔ M × N / GGD(M, N);
   I ≔ ENTIER((1 + &#9192;-14) × D × KGV);
   <u>if</u> EPS &GreaterSlantEqual; &#9192;-3 <u>then</u> L: APPROX <u>else</u> EXACT;
<u>end</u> KOLSMIR;
<u>eop</u>
<u>code</u> 41558;
<u>real</u> <u>procedure</u> BIVANORM(H, K, RHO); <u>value</u> H, K, RHO;
   <u>real</u> H, K, RHO;
<u>begin</u> <u>real</u> B;

   <u>real</u> <u>procedure</u> V(H, K, EPS); <u>value</u> H, K, EPS;
      <u>real</u> H, K, EPS;
      <u>if</u> H = 0 ∨ K = 0 <u>then</u> V ≔ 0 <u>else</u>
      <u>if</u> ABS(H) &lt; ABS(K) <u>then</u>
        V ≔ (PHI(H) - ·5) × (PHI(K) - ·5) - V(K, H, EPS)
        <u>else</u>
      <u>if</u> ABS(K)&gt; 8 <u>then</u>
        V ≔ 15915 49430 9189 × ARCTAN (K/H)
      <u>else</u>
      <u>begin</u> <u>real</u> M, L, L2, S, R, T, SS, TSN; <u>integer</u> N;
         L ≔ K / H; M ≔ H × H / 2; L2 ≔ L × L; R ≔ EXP(-M);
         S ≔ 1 - R; T ≔ L; SS ≔ T × S;
         <u>for</u> N ≔ 1, N + 1 <u>while</u> ABS(TSN) &GreaterSlantEqual; EPS <u>do</u>
            <u>begin</u> R ≔ R × M / N; S ≔ S - R; T ≔ -T × L2;
               TSN ≔  × T / (2 × N + 1);
               SS ≔ SS + TSN
            <u>end</u>;
         V ≔ SS × ·15915 49430 9189
      <u>end</u> V;

   <u>if</u> H &lt; -8 ∨ K &lt; -8 <u>then</u> B ≔  <u>else</u>
   <u>if</u> H &gt; 8 ∧ K &gt; 8 <u>then</u> B ≔  <u>else</u>
     B ≔ <u>if</u> ABS(RHO) &gt; 1 <u>then</u>
     STATAL3 ERROR(“BIVANORM”, 3, RHO)
   <u>else</u> <u>if</u> ABS(RHO) = 1 <u>then</u>
     (<u>if</u> RHO = 1 <u>then</u> (<u>if</u> K &LessSlantEqual; H <u>then</u> PHI(K)
   <u>else</u> PHI(H))
   <u>else</u> (<u>if</u> H &LessSlantEqual; -K <u>then</u> 0
   <u>else</u> PHI(K) - PHI(H)))
   <u>else</u> V(H,(K - RHO × H)/ SQRT(1 - RHO ⭡ 2), &#9192;-14)
     + V(K,(H - RHO × K)/ SQRT(1 - RHO ⭡ 2), &#9192;-14)
     + ·5 × (PHI(H) + PHI(K))
     - ·15915 49430 9189 × ARCCOS(RHO);
   <u>if</u> B &lt; 0 <u>then</u> BIVANORM ≔  <u>else</u> BIVANORM ≔ ;
<u>end</u> BIVANORM;
<u>eop</u>
<u>code</u> 41560;
<u>real</u> <u>procedure</u> STUDRANGE(Q,N,NU);
   <u>value</u> Q,N,NU; <u>real</u> Q,N,NU;
<u>begin</u> <u>real</u> X, PI, LN4, LNSQRT2PI, LNSQRTPI4;
   <u>array</u> E[1 : 3];

   <u>real</u> <u>procedure</u> POWER(X)TO:(N); <u>value</u> X, N;
      <u>real</u> X; <u>integer</u> N;
   <u>begin</u> <u>integer</u> N2; <u>real</u> Y;
      Y ≔ 1;
      WHILE POS N:
      <u>if</u> N &LessSlantEqual; 0 <u>then</u> <u>goto</u> END WHILE POS N;
      N2 ≔ N ÷ 2;
      WHILE EVEN N:
      <u>if</u> N2 × 2 ≠ N <u>then</u> <u>goto</u> END WHILE EVEN N;
      N ≔ N2; X ≔ X × X; N2 ≔ N ÷ 2;
      <u>goto</u> WHILE EVEN N;
      END WHILE EVEN N:
      N ≔ N - 1; Y ≔ Y × X;
      <u>goto</u> WHILE POS N;
      END WHILE POS N:
      POWER ≔ Y
   <u>end</u> POWER;

   <u>real</u> <u>procedure</u> RANGE(T,N); <u>value</u> T,N; <u>real</u> T,N;
   <u>begin</u> <u>real</u> U; <u>real</u> <u>array</u> E[1:3];
      E[1] ≔ E[2] ≔ &#9192;-7;
      RANGE ≔ N × QADRAT(U, -5, +5,
        PHIDENS(U) × POWER(PHI(U + T) - PHI(U), N - 1), E);
   <u>end</u> RANGE;

   <u>real</u> <u>procedure</u> INTEGRAND(X); <u>value</u> X; <u>real</u> X;
   <u>begin</u> <u>real</u> XQ;
      XQ ≔ X / Q;
      INTEGRAND ≔ EXP(NU × (LN4 + LN(XQ) - LNSQRT2PI
        - XQ × XQ / 2)) × (1 - RANGE(X, N)) / X;
   <u>end</u> INTEGRAND;

   <u>if</u> N &lt; 2 ∨ ENTIER(N) &lt; N <u>then</u>
     STATAL ERROR(“STUDRANGE”, 2, N);
   <u>if</u> NU &lt; 1 ∨ ENTIER(NU) &lt; NU <u>then</u>
     STATAL ERROR(“STUDRANGE”, 3, NU);

   E[1] ≔ E[2] ≔ &#9192;-6; PI ≔ ARCTAN(1) × 4;
   LNSQRT2PI ≔ ·5 × LN(2 × PI); LN4 ≔ LN(4);
   LNSQRTPI4 ≔ ·5 × LN(PI) - LN4;
   STUDRANGE ≔ <u>if</u> Q &LessSlantEqual; 0 <u>then</u> 0 <u>else</u>
     1 - 2 × EXP(NU × (LN(NU) / 2 + LNSQRTPI4)
     - LOGGAMMA(NU / 2)) ×
     QADRAT(X, &#9192;-6, Q × 7, INTEGRAND(X), E);
<u>end</u> STUDRANGE;
<u>eop</u>
<u>code</u> 41561;
<u>real</u> <u>procedure</u> EXPON (X, LAMBDA);
   <u>value</u> X, LAMBDA; <u>real</u> X, LAMBDA;
   EXPON ≔ <u>if</u> LAMBDA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“EXPON”, 2, LAMBDA)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0
   <u>else</u> 1 - EXP(-LAMBDA × X);
<u>eop</u>
<u>code</u> 41562;
<u>real</u> <u>procedure</u> EXPONINV(PROB, LAMBDA);
   <u>value</u> PROB, LAMBDA; <u>real</u> PROB, LAMBDA;
   EXPONINV ≔ <u>if</u> LAMBDA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“EXPONINV”,2,LAMBDA)
   <u>else</u> <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1
     <u>then</u> STATAL3 ERROR(“EXPONINV”,1,PROB)
   <u>else</u> - LN(1 - PROB) / LAMBDA;
<u>eop</u>
<u>code</u> 41563;
<u>real</u> <u>procedure</u> ERLANG(X, N, SCALE);
   <u>value</u> X, N, SCALE; <u>real</u> X, N, SCALE;
   ERLANG ≔ <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“ERLANG”, 3, SCALE)
   <u>else</u> <u>if</u> N &LessSlantEqual; 0 ∨ ENTIER(N) &lt; N
     <u>then</u> STATAL3 ERROR(“ERLANG”, 2, N)
   <u>else</u> GAMMA(X, N, SCALE);
<u>eop</u>
<u>code</u> 41564;
<u>real</u> <u>procedure</u> ERLANGINV(PROB,ALPHA,SCALE);
   <u>value</u> PROB,ALPHA,SCALE; <u>real</u> PROB,ALPHA,SCALE;
   <u>if</u> PROB &LessSlantEqual; &#9192;-10 ∨ PROB &GreaterSlantEqual; 1 - &#9192;-10 <u>then</u>
     STATAL3 ERROR(“ERLANGINV”,1,PROB)
     <u>else</u> <u>if</u> ALPHA &LessSlantEqual; 0 ∨ ENTIER(ALPHA) &lt; ALPHA <u>then</u>
     STATAL3 ERROR(“ERLANGINV”,2,ALPHA)
     <u>else</u> <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“ERLANGINV”,3,SCALE)
   <u>else</u> ERLANGINV ≔ GAMMAINV(PROB,ALPHA, SCALE);
<u>eop</u>
<u>code</u> 41565;
<u>real</u> <u>procedure</u> LAPLACE(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
<u>begin</u>
   <u>if</u> SIGMA &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“LAPLACE”, 3, SIGMA);
   X ≔ (X - MU) / SIGMA;
   LAPLACE ≔ ·5 × (1 + (1 - EXP(-ABS(X))) × SIGN(X))
<u>end</u> LAPLACE;
<u>eop</u>
<u>code</u> 41566;
<u>real</u> <u>procedure</u> LAPLACEINV(PROB,LOC,SCALE);
   <u>value</u> PROB, LOC, SCALE; <u>real</u> PROB, LOC, SCALE;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“LAPLACEINV”,3,SCALE);
   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“LAPLACEINV”,1,PROB);
   <u>if</u> PROB &LessSlantEqual; ·5 <u>then</u>
     LAPLACEINV ≔ LOC + LN(2 × PROB) × SCALE
   <u>else</u>
     LAPLACEINV ≔ LOC - LN(2 × (1 - PROB)) × SCALE;
<u>end</u> LAPLACEINV;
<u>eop</u>
<u>code</u> 41567;
<u>real</u> <u>procedure</u> UNIFORM(X, A, B);
   <u>value</u> X, A, B; <u>real</u> X, A, B;
<u>begin</u>
   <u>if</u> B &LessSlantEqual; A <u>then</u>
     STATAL3ERROR(“UNIFORM”, 2, B);
   UNIFORM ≔ <u>if</u> X &LessSlantEqual; A <u>then</u> 0 <u>else</u>
     <u>if</u> X &GreaterSlantEqual; B <u>then</u> 1 <u>else</u> (X - A) / (B - A)
<u>end</u> UNIFORM;
<u>eop</u>
<u>code</u> 41568;
<u>real</u> <u>procedure</u> UNIFORMINV(PROB, A, B);
   <u>value</u> PROB, A, B; <u>real</u> PROB, A, B;
<u>begin</u>
   <u>if</u> B &LessSlantEqual; A <u>then</u> STATAL3ERROR(“UNIFORMINV”, 2, B);
   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3ERROR(“UNIFORMINV”, 1, PROB);
   UNIFORMINV ≔ (B - A) × PROB + A
<u>end</u> UNIFORMINV;
<u>eop</u>
<u>code</u> 41569;
<u>real</u> <u>procedure</u> BINORCOR(R,RHO,N);
   <u>value</u> R, RHO, N; <u>real</u> R, RHO, N;
<u>begin</u>
   <u>real</u> <u>procedure</u> SAMCORBIVNORDEN(R,RHO,N);
      <u>value</u> R, RHO, N; <u>real</u> R, RHO, N;
   <u>begin</u>
      <u>if</u> ABS(R) &GreaterSlantEqual; 1 <u>then</u> SAMCORBIVNORDEN ≔ 0
      <u>else</u>
      <u>begin</u>
         <u>real</u> W1, W3, Y1, Y2, Y3, Y4, N1, R2, RRHO,
           R2RHO2, W2, PI, RHO2;
         R2 ≔ R × R;
         RHO2 ≔ RHO × RHO;
         RRHO ≔ R × RHO;
         R2RHO2 ≔ R2 × RHO2;
         W1 ≔ SQRT(1 - R2);
         W2 ≔ SQRT(1 - RHO2);
         W3 ≔ SQRT(1 - RHO2 × R2);
         PI ≔ ARCTAN(1) × 4;
         N1 ≔ N - 1;
         <u>if</u> N &lt; 15 <u>then</u>
         <u>begin</u>
            <u>real</u> <u>array</u> SB[3:N]; <u>integer</u> I;
            SB[3] ≔               (1-RHO2) / PI / W1 × (1 + RRHO ×
              ARCCOS(-RRHO) / W3) / (1 - R2RHO2);
            <u>if</u> N =3 <u>then</u> SAMCORBIVNORDEN ≔ SB[3]
            <u>else</u>
            <u>begin</u>
               SB[4] ≔                  (1 - RHO2) × W2 / PI × (3 × RRHO +
                 (1 + 2 × R2RHO2) × ARCCOS(-RRHO) / W3)
                 / (1 - R2RHO2) / (1 - R2RHO2);
               <u>if</u> N = 4 <u>then</u> SAMCORBIVNORDEN ≔ SB[4]
               <u>else</u>
               <u>begin</u> <u>for</u> I ≔ 5 <u>step</u> 1 <u>until</u> N <u>do</u>
                       SB[I] ≔                        (2 × I - 5) / (I - 3) × RRHO × W1 × W2
                       / (1 - R2RHO2) × SB[I-1] +
                       (I - 3) / (I - 4) × (1 - RHO2) ×
                       (1 - R2) / (1 - R2RHO2) × SB[I-2];
                  SAMCORBIVNORDEN ≔ SB[N];
               <u>end</u>;
            <u>end</u>;
         <u>end</u>
         <u>else</u>
         <u>begin</u>
            Y1 ≔ (RRHO + 2) / 8;
            Y2 ≔ (3 × RRHO + 2) × (3 × RRHO + 2) / 128;
            Y3 ≔ (((15 × RRHO + 18) × RRHO - 4)× RRHO - 8) × 5 / 1024;
            Y4 ≔ ((((3675 × RRHO + 4200) × RRHO - 2520)× RRHO - 3360) × RRHO - 336) / 32768;
            SAMCORBIVNORDEN ≔               (N - 2) / SQRT(N - 1) × (1 - RHO2) × W2× (W1 × W2 / (1 - RRHO)) ⭡ N1 ×
              SQRT((1 - RRHO) / 2 / PI)
              / ((1 - R2) × W1 × (1 - RHO2) × W2)× ((((Y4 / N1 + Y3) / N1 + Y2) / N1 + Y1)
              / N1 + 1);
         <u>end</u>;
      <u>end</u>;
   <u>end</u> SAMCORBIVNORDEN;
   <u>if</u> ABS(RHO) &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“BINORCOR”, 2, RHO)
     <u>else</u> <u>if</u> N &gt; ENTIER(N) ∨ N &lt; 3 <u>then</u>
     STATAL3 ERROR(“BINORCOR”, 3, N)
     <u>else</u> <u>if</u> R &LessSlantEqual; -1 <u>then</u> BINORCOR ≔ 0
     <u>else</u> <u>if</u> R &GreaterSlantEqual; 1 <u>then</u> BINORCOR ≔ 1
     <u>else</u> <u>if</u> RHO = 0 <u>then</u>
     BINORCOR ≔      STUDENT(R × SQRT((N - 2) / (1 - R × R)), N - 2)
     <u>else</u>
   <u>if</u> N &LessSlantEqual; 500 <u>then</u>
   <u>begin</u> <u>real</u> W1, W2, W3, PI, R2, RHO2, RHO3,
        RHO4, RRHO, R2RHO2;
      R2 ≔ R × R;
      RHO2 ≔ RHO × RHO;
      RHO3 ≔ RHO2 × RHO;
      RHO4 ≔ RHO2 × RHO2;
      RRHO ≔ R × RHO;
      R2RHO2 ≔ R2 × RHO2;
      W1 ≔ SQRT(1 - R2);
      W2 ≔ SQRT(1 - RHO2);
      W3 ≔ SQRT(1 - RHO2 × R2);
      PI ≔ ARCTAN(1) × 4;
      <u>if</u> N = 3 <u>then</u>
        BINORCOR ≔         (ARCCOS(-R) - RHO × W1 / W3 × ARCCOS(-RRHO)) / PI
        <u>else</u> <u>if</u> N = 4 <u>then</u>
        BINORCOR ≔         W1 × W2 × SAMCORBIVNORDEN(R, RHO, 3) / RHO -
        (W2 / RHO - ARCCOS(RHO)) / PI
        <u>else</u> <u>if</u> N = 5 <u>then</u>
        BINORCOR ≔         W1 × W2 × SAMCORBIVNORDEN(R, RHO, 4) / 2 / RHO
        - R × (1 - R2) / 2 × SAMCORBIVNORDENC(R, RHO, 3)
        - W1 × (1 + RHO2) / (2 × PI × RHO) × ARCCOS(-RRHO)
        / W3 + ARCCOS(-R) / PI
        <u>else</u>
      <u>if</u> N = 6 <u>then</u>
        BINORCOR ≔         W2 × (1 - 4 × RHO2) / (3 × PI × RHO3)
        + ARCCOS(RHO) / PI
        - (1 - RHO2) × W1 × W2 / 3 / RHO3 ×
        SAMCORBIVNORDEN(R, RHO, 3)
        + (1 - RHO2) × R / 3 / RHO2 ×
        SAMCORBIVNORDEN(R, RHO, 4)
        + W1 × W2 / 3 / RHO × SAMCORBIVNORDEN(R, RHO, 5)
        <u>else</u> <u>if</u> N = 7 <u>then</u>
        BINORCOR ≔         ARCCOS(-R) / PI - (3 + 6 × RHO2 - RHO4) ×
        ARCCOS(-RRHO) / W3 × W1 / (8 × PI × RHO)
        -R × (1 - R2) × (4 - 3 × RHO2 + 3 × RHO4) / 8 /
        RHO2 × SAMCORBIVNORDEN(R, RHO, 3)
        - R2 × W1 × W2 × (2 - RHO2) / 8 / RHO ×
        SAMCORBIVNORDEN(R, RHO, 4)
        + (1 - RHO2) × R / 4 / RHO2 ×
        SAMCORBIVNORDEN(R, RHO, 5)
        + W1 × W2 / 4 / RHO × SAMCORBIVNORDEN(R, RHO, 6)
        <u>else</u> <u>if</u> N = 8 <u>then</u>
        BINORCOR ≔ ARCCOS(RHO)
        / PI - W2 × (3 - 11 × RHO2 + 23 × RHO4)
        / 15 / PI / RHO4 / RHO
        + (W2 / RHO) ⭡ 5 × W1 / 5 ×
        SAMCORBIVNORDEN(R, RHO, 3)
        - R × (1-RHO2) × (1-RHO2) / 5 / RHO4 ×
        SAMCORBIVNORDEN(R, RHO, 4)
        + (3 × R2 - 1) × (1 - RHO2) × W2 / W1 / 15 / RHO3× SAMCORBIVNORDEN(R, RHO, 5)
        + (1 - RHO2) × R / 5 / RHO2 ×
        SAMCORBIVNORDEN(R, RHO, 6)
        + W1 × W2 / 5 / RHO × SAMCORBIVNORDENC(R, RHO, 7)
      <u>else</u>
      <u>begin</u> <u>real</u> <u>array</u> E[1:3]; <u>real</u> X;
         E[1] ≔ E[2] ≔ &#9192;-6;
         BINORCOR ≔            STUDENT(-RHO × SQRT(N - 1) / W2, N - 1)
           + QADRAT(X, 0, R, SAMCORBIVNORDEN(X, RHO, N), E)
      <u>end</u>;
   <u>end</u>
   <u>else</u>
   <u>begin</u> <u>real</u> R2, RHO2, RHO3; <u>integer</u> N1, N2, N3;
      N1 ≔ N - 1; N2 ≔ N1 × N1; N3 ≔ N1 × N2;
      R2 ≔ R × R;
      RHO2 ≔ RHO × RHO;
      RHO3 ≔ RHO2 × RHO;
      BINORCOR ≔         <u>if</u> ABS(RHO) &LessSlantEqual; ·7 <u>then</u>
        PHI((R × SQRT((N - 2·5) / (1 - R2)) -
        RHO × SQRT((N - 1·5) / (1 - RHO2)))
        / SQRT(1 + RHO2 / 2 / (1 - RHO2) + R2 /
        2 / (1 - R2)))
      <u>else</u>
        PHI((·5 × LN((1 + R) × (1 - RHO) / (1 - R) /
        (1 + RHO)) - RHO / 2/ N1 -
        (5 × RHO + RHO3) / 8 / N2 - (11 × RHO +
        (2 + RHO2) × 3 × RHO3) / 16 / N3)
        / SQRT(1 / N1 + (4 - RHO2) / 2 / N2 +
        (22 - (6 - 3 × RHO2) × RHO2) / 6 / N3));
   <u>end</u>;
<u>end</u>  BINORCOR;
<u>eop</u>
<u>code</u> 41571;
<u>real</u> <u>procedure</u> EXTVAL(X, LOC, SCALE);
   <u>value</u> X, LOC, SCALE; <u>real</u> X, LOC, SCALE;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“EXTVAL”, 3, SCALE);
   X ≔ -(X - LOC) / SCALE;
   EXTVAL ≔ <u>if</u> X &gt; LN(-LN(MINREAL))
     <u>then</u> 0
   <u>else</u> EXP(-EXP(X));
<u>end</u> EXTVAL;
<u>eop</u>
<u>code</u> 41572;
<u>real</u> <u>procedure</u> EXTVALINV(PROB, LOC, SCALE);
   <u>value</u> PROB, LOC, SCALE; <u>real</u> PROB, LOC, SCALE;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“EXTVALINV”, 3, SCALE);
   <u>if</u> PROB &LessSlantEqual; 0 ∨ PROB &GreaterSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“EXTVALINV”, 1, PROB);
   EXTVALINV ≔ -SCALE × LN(-LN(PROB)) + LOC
<u>end</u> EXTVALINV;
<u>eop</u>
<u>code</u> 41751;
<u>real</u> <u>procedure</u> UNIFORMDENS(X, A, B);
   <u>value</u> X, A, B; <u>real</u> X,A,B;
<u>begin</u>
   <u>if</u> B &LessSlantEqual; A
     <u>then</u> STATAL3ERROR(“UNIFORMDENS”, 2, B);
   UNIFORMDENS ≔ <u>if</u> X &LessSlantEqual; A ∨ X &gt; B
     <u>then</u> 0 <u>else</u> 1 / (B - A)
<u>end</u> UNIFORMDENS;
<u>eop</u>
<u>code</u> 41752;
<u>real</u> <u>procedure</u> PHIDENS(X); <u>value</u> X;
   PHIDENS ≔ ·39894228040143 × EXP(- X × X / 2);
<u>eop</u>
<u>code</u> 41753;
<u>real</u> <u>procedure</u> NORMALDENS(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
   NORMALDENS ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u>
     STATAL3 ERROR(“NORMALDENS”, 3, SIGMA)
   <u>else</u> EXP(-(((X - MU) / SIGMA) ⭡ 2) / 2)× ·39894228040143 / SIGMA;
<u>eop</u>
<u>code</u> 41754;
<u>real</u> <u>procedure</u> LOGNORMALDENS(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
   LOGNORMALDENS ≔ <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u>
     STATAL3 ERROR(“LOGNORMALDENS”, 3, SIGMA)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0
   <u>else</u>
     EXP(-(((LN(X) - MU) / SIGMA) ⭡ 2) / 2)× ·39894228040143 / X / SIGMA;
<u>eop</u>
<u>code</u> 41755;
<u>real</u> <u>procedure</u> EXPONDENS(X, LAMBDA); <u>value</u> X, LAMBDA;
   <u>real</u> X, LAMBDA;
   EXPONDENS ≔ <u>if</u> LAMBDA &LessSlantEqual; 0
     <u>then</u>
     STATAL3 ERROR(“EXPONDENS”, 2, LAMBDA)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0
   <u>else</u> LAMBDA × EXP(- LAMBDA × X);
<u>eop</u>
<u>code</u> 41756;
<u>real</u> <u>procedure</u> GAMMADENS(X,ALPHA, SCALE);
   <u>value</u> X,ALPHA,SCALE; <u>real</u> X,ALPHA,SCALE;
   <u>if</u> X &LessSlantEqual; 0 <u>then</u> GAMMADENS ≔ 0 <u>else</u>
   <u>begin</u>
      <u>if</u> ALPHA &LessSlantEqual; 0
        <u>then</u> STATAL3 ERROR(“GAMMADENS”,2,ALPHA)
        <u>else</u> <u>if</u> SCALE &LessSlantEqual; 0
        <u>then</u> STATAL3 ERROR(“GAMMADENS”, 35,SCALE);

      GAMMADENS ≔         EXP(- ALPHA × LN(SCALE) - LOGGAMMA(ALPHA) -
        X / SCALE + (ALPHA - 1) × LN(X))
   <u>end</u> GAMMADENS;
<u>eop</u>
<u>code</u> 41757;
<u>real</u> <u>procedure</u> ERLANGDENS(X,ALPHA,SCALE);
   <u>value</u> X,ALPHA,SCALE; <u>real</u> X,ALPHA,SCALE;
   <u>if</u> X &lt; 0
     <u>then</u> STATAL3 ERROR(“ERLANGDENS”,1,X) <u>else</u>
   <u>if</u> ALPHA &LessSlantEqual; 0 ∨ ENTIER(ALPHA) &lt; ALPHA <u>then</u>
     STATAL3 ERROR(“ERLANGDENS”,2,ALPHA) <u>else</u>
   <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“ERLANGDENS”,3,SCALE)
   <u>else</u> ERLANGDENS ≔ <u>if</u> X = 0 <u>then</u> 0 <u>else</u>
     EXP(-ALPHA × LN(SCALE) - LOGGAMMA(ALPHA) - X / SCALE +
     (ALPHA - 1) × LN(X));
<u>eop</u>
<u>code</u> 41758;
<u>real</u> <u>procedure</u> CHISQDENS(X, DF);
   <u>value</u> X, DF; <u>real</u> X, DF;
   CHISQDENS ≔ <u>if</u> DF &LessSlantEqual; 0
     <u>then</u> STATAL3ERROR(“CHISQDENS”, 2, DF)
   <u>else</u> <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0 <u>else</u>
     EXP((DF / 2 - 1) × LN(X) - X / 2 -
     DF × LN(2) / 2 - LOGGAMMA(DF / 2));
<u>eop</u>
<u>code</u> 41759;
<u>real</u> <u>procedure</u> WEIBULLDENS(X,LOC,SCALE,ALPHA);
   <u>value</u> X,LOC,SCALE,ALPHA; <u>real</u> X,LOC,SCALE,ALPHA;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“WEIBULLDENS”,3,SCALE) <u>else</u>
   <u>if</u> ALPHA &LessSlantEqual; 0 
     <u>then</u> STATAL3 ERROR(“WEIBULLDENS”,4,ALPHA);

   WEIBULLDENS ≔ <u>if</u> X &LessSlantEqual; LOC <u>then</u> 0 <u>else</u>
     (ALPHA / SCALE) × EXP((ALPHA - 1) ×
     LN((X - LOC) / SCALE) - ((X - LOC) / SCALE) ⭡ ALPHA)
<u>end</u> WEIBULLDENS;
<u>eop</u>
<u>code</u> 41760;
<u>real</u> <u>procedure</u> BETADENS(X,ALPHA1,ALPHA2);
   <u>value</u> X,ALPHA1,ALPHA2; <u>real</u> X,ALPHA1,ALPHA2;
<u>begin</u> <u>real</u> BET;

   <u>if</u> ALPHA1 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“BETADENS”,2,ALPHA1);
   <u>if</u> ALPHA2 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“BETADENS”,3,ALPHA2);

   <u>if</u> X &LessSlantEqual; 0 ∨ X &GreaterSlantEqual; 1 <u>then</u> BETADENS ≔ 0 <u>else</u>
   <u>begin</u> BET ≔ EXP(LOGGAMMA(ALPHA1 + ALPHA2) -
        LOGGAMMA(ALPHA1) - LOGGAMMA(ALPHA2));
      BETADENS ≔ BET × EXP((ALPHA1 - 1) × LN(X) +
        (ALPHA2 - 1 ) × LN(1 - X))
   <u>end</u>;
<u>end</u> BETADENS;
<u>eop</u>
<u>code</u> 41761;
<u>real</u> <u>procedure</u> FISHERDENS(X, DF1, DF2);
   <u>value</u> X, DF1, DF2;
   <u>real</u> X, DF1, DF2;
   FISHERDENS ≔ <u>if</u> DF1 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“FISHERDENS”, 2, DF1)
   <u>else</u>
     <u>if</u> DF2 &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“FISHERDENS”, 3, DF2)
   <u>else</u>
     <u>if</u> X &LessSlantEqual; 0 <u>then</u> 0 <u>else</u>
     EXP(LOGGAMMA((DF1 + DF2) / 2) -
     LOGGAMMA(DF1 / 2) - LOGGAMMA(DF2 / 2) +
     (DF1 × LN(DF1) + DF2 × LN(DF2)) / 2 +
     (DF1 / 2 - 1) × LN(X) - (DF1 + DF2) / 2 ×
     LN(DF1 × X + DF2));
<u>eop</u>
<u>code</u> 41762;
<u>real</u> <u>procedure</u> STUDENTDENS(X, DF);
   <u>value</u> X, DF; <u>real</u> X, DF;
   STUDENTDENS ≔ <u>if</u> DF &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“STUDENTDENS”, 2, DF)
   <u>else</u>
     EXP(LOGGAMMA((DF + 1) / 2) - LOGGAMMA(DF / 2) -
     (DF + 1) / 2 × LN(1 + X × X / DF) -
     LN(DF) / 2 - ·57236494299247);
<u>eop</u>
<u>code</u> 41763;
<u>real</u> <u>procedure</u> CAUCHYDENS(X,LOC,SCALE);
   <u>value</u> X,LOC,SCALE; <u>real</u> X,LOC,SCALE;
<u>begin</u> <u>real</u> PI,Q;

   <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“CAUCHYDENS”,3,SCALE);
   PI ≔ 3·1415926535898;
   Q ≔ (X - LOC) / SCALE;
   CAUCHYDENS ≔ 1 / (PI × SCALE × (1 + Q × Q))
<u>end</u> CAUCHYDENS;
<u>eop</u>
<u>code</u> 41764;
<u>real</u> <u>procedure</u> LAPLACEDENS(X,LOC,SCALE);
   <u>value</u> X, LOC, SCALE; <u>real</u> X, LOC, SCALE;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“LAPLACEDENS”,3,SCALE);
   X ≔ (X - LOC) / SCALE;
   LAPLACEDENS ≔ ·5 / SCALE × EXP(-ABS(X));
<u>end</u> LAPLACEDENS;
<u>eop</u>
<u>code</u> 41765;
<u>real</u> <u>procedure</u> LOGISTICDENS(X, MU, SIGMA);
   <u>value</u> X, MU, SIGMA; <u>real</u> X, MU, SIGMA;
<u>begin</u>
   <u>if</u> SIGMA &LessSlantEqual; 0
     <u>then</u> STATAL3 ERROR(“LOGISTICDENS”, 3, SIGMA);
   X ≔ EXP(-(X - MU) / SIGMA);
   LOGISTICDENS ≔ X / ((1 + X) × (1 + X) × SIGMA)
<u>end</u> LOGISTICDENS;
<u>eop</u>
<u>code</u> 41766;
<u>real</u> <u>procedure</u> EXTVALDENS(X, LOC, SCALE);
   <u>value</u> X, LOC, SCALE; <u>real</u> X, LOC, SCALE;
<u>begin</u>
   <u>if</u> SCALE &LessSlantEqual; 0 <u>then</u>
     STATAL3 ERROR(“EXTVALDENS”, 3, SCALE);
   X ≔ (X - LOC) / SCALE;
   EXTVALDENS ≔ EXP(-(X + EXP(-X))) / SCALE
<u>end</u> EXTVALDENS;
<u>eop</u>
<u>code</u> 49999;
<u>real</u> <u>procedure</u> ANDERSON DARLING(X, L, U, SORTED);
   <u>value</u> L, U, SORTED;
   <u>array</u> X; <u>integer</u> L, U; <u>Boolean</u> SORTED;
<u>begin</u> <u>integer</u> I, N;
   <u>real</u> MU, SIGMA, XI, FACTOR, SUM, ESTIMATE;

   N ≔ U - L +1;
   <u>if</u> N &LessSlantEqual; 1 <u>then</u>
     STATAL3 ERROR(“ANDERSON-DARLING”, 3, U);
   <u>if</u> ¬ SORTED <u>then</u> VECQSORT(X, L, U);
   <u>if</u> X[L] = X[U] <u>then</u>
     STATAL3 ERROR(“ANDERSON-DARLING”, 1, X[L]);

   <u>comment</u> FIRST THE ESTIMATION (IN THE USUAL WAY) OF
     EXPECTATION AND STANDARD DEVIATION OF THE NORMAL
     DISTRIBUTION. ;
   MU ≔ SIGMA ≔ 0; ESTIMATE ≔ (X[L] + X[U]) / 2;
   <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> XI ≔ X[I] ≔ X[I] - ESTIMATE;
         MU ≔ MU + XI; SIGMA ≔ SIGMA + XI × XI;
      <u>end</u>;
   MU ≔ MU / N;
   SIGMA ≔ SQRT((SIGMA - N × MU × MU) / (N - 1));

   <u>comment</u> TRANSFORMATION OF THE OBSERVATIONS TO
     UNIFORM(0, 1)-DISTRIBUTED QUANTITIES.;
   <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
        X[I] ≔ HI((X[I] - MU) / SIGMA);

   <u>comment</u> ANDERSON-DARLING TEST QUANTITY;

   SUM ≔ 0; FACTOR ≔ -1;
   <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> FACTOR ≔ FACTOR + 2;
         SUM ≔ SUM +
           FACTOR × (LN(X[I]) + LN(1 - X[L + U - I]))
      <u>end</u>;
   ANDERSON DARLING ≔      (1 + 4 / N - 25 / N / N) × (-SUM / N - N)
<u>end</u> OF ANDERSON DARLING;
<u>eop</u>
</pre></body></html>
