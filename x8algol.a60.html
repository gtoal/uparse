<html><head><meta charset="utf-8"></head><body><pre><u>begin</u>
   <u>comment</u>         ALGOL 60 - version of the ALGOL 60 - translator
     for the EL - X8, F.E.J. Kruseman Aretz;

   <u>comment</u>         basic symbols;
   <u>integer</u> plus, minus, mul, div, idi, ttp, equ, uqu, les, mst, mor, lst,
     non, qvl, imp, or, and, goto, for, step, until, while, do,
     comma, period, ten, colon, semicolon, colonequal, space sbl,
     if, then, else, comment, open, close, sub, bus, quote, unquote,
     begin, end, own, rea, integ, boole, stri, array, proced, switch,
     label, value, true, false, new line, underlining, bar;

   <u>comment</u>         other global integers;
   <u>integer</u> case, lower case, stock, stock1, last symbol, line counter,
     last identifier, last identifierl,
     quote counter, run number, shift,
     type, chara, character, value character, arr decla macro,
     value of constant, decimal exponent, decimal count,
     word count, nlp, last nlp, n, integer label,
     block cell pointer, next block cell pointer,
     dimension, for count, instruct counter, dp0,
     function letter, function digit, c variant,
     nl base, prog base, text base, text pointer,
     end of text, end of memory, start, end of list,
     d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14,
     d15, d16, d17, d18, d19, d20, d21, d22, d23, d24, d25,
     re, in, bo, st, ar, nondes, des, un, arbo, intlab;

   <u>comment</u>         macro identifiers;
   <u>integer</u> STACK, NEG, ADD, SUB, MUL, DIV, IDI, TTP,
     EQU, UQU, LES, MST, MOR, LST, STAB, NON, QVL, IMP, OR, AND,
     STAA, TSR, TSI, TSB, TSST, TFSU, TSL, TFSL, TCST,
     STSR, STSI, SSTSI, STSB, STSST, STFSU,
     ENTRIS, TFD, SAS, DECS, FAD, TASR, TASI, TASB, TASST, TASU,
     EXITIS, FADCV, TRSCV, TISCV, TSCVU, EXIT, TEST1, TEST2,
     CRV, CIV, CBV, CSTV, CLV, CEN, CLPN, TAV, TIAV,
     RAD, IAD, BAD, STAD, ORAD, OIAD, OBAD, OSTAD,
     LOS, EXITP, EXITPC, REJST, JUA, EMPTY,
     ABS, SIGN, ENTIER, SQRT, EXP, LN, END;

   <u>comment</u>         macro2 identifiers;
   <u>integer</u> TRV, TIV, TRC, TIC, TSIC, TBV, TBC, TSTV, TLV, TAK, TSWE,
     STR, STI, SSTI, STB, STST, DOS, DOS2, DOS3,
     JU, JU1, LJU, LJU1, COJU, YCOJU, SUBJ, ISUBJ, DECB, DO,
     TBL, ENTRB, DPTR, INCRB, TDL, ENTRPB, NIL, LAST,
     LAD, TDA, TNA, TAA, SWP, EXITB, EXITC, EXITSV,
     CODE, SLNC, RLNC, LNC;

   <u>comment</u>         global Booleans;
   <u>Boolean</u> letter last symbol, digit last symbol, arr declarator last symbol,
     type declarator last symbol, in array declaration, in formal list,
     text in memory, own type, int labels, real number, small,
     erroneous, derroneous, wanted;





   <u>comment</u>         global arrays;
   <u>integer</u>  <u>array</u> internal representation[0 : 127], word delimiter[0 : 23],
     macro list[0 : 511], tabel[5 : 59],
     instruct list[0 : 203], mask[0 : 9];

   <u>comment</u>         start of initialization;
   plus ≔ read;    minus ≔ read;   mul ≔ read;     div ≔ read;
   idi ≔ read;     ttp ≔ read;     equ ≔ read;     uqu ≔ read;
   les ≔ read;     mst ≔ read;     mor ≔ read;     lst ≔ read;
   non ≔ read;     qvl ≔ read;     imp ≔ read;     or ≔ read;
   and ≔ read;     goto ≔ read;    for ≔ read;     step ≔ read;
   until ≔ read;   while ≔ read;   do ≔ read;      comma ≔ read;
   period ≔ read;  ten ≔ read;     colon ≔ read;   semicolon ≔ read;
   colonequal ≔ read; space sbl ≔ read; if ≔ read; then ≔ read;
   else ≔ read;    comment ≔ read; open ≔ read;    close ≔ read;
   sub ≔ read;     bus ≔ read;     quote ≔ read;   unquote ≔ read;
   begin ≔ read;   end ≔ read;     own ≔ read;     rea ≔ read;
   integ ≔ read;   boole ≔ read;   stri ≔ read;    array ≔ read;
   proced ≔ read;  switch ≔ read;  label ≔ read;   value ≔ read;
   true ≔ read;    false ≔ read;   new line ≔ read;
   underlining ≔ read; bar ≔ read; lower case ≔ read;

   STACK ≔ read;   NEG ≔ read;     ADD ≔ read;     SUB ≔ read;
   MUL ≔ read;     DIV ≔ read;     IDI ≔ read;     TTP ≔ read;
   EQU ≔ read;     UQU ≔ read;     LES ≔ read;     MST ≔ read;
   MOR ≔ read;     LST ≔ read;     STAB ≔ read;    NON ≔ read;
   QVL ≔ read;     IMP ≔ read;     OR ≔ read;      AND ≔ read;
   STAA ≔ read;    TSR ≔ read;     TSI ≔ read;     TSB ≔ read;
   TSST ≔ read;    TFSU ≔ read;    TSL ≔ read;     TFSL ≔ read;
   TCST ≔ read;    STSR ≔ read;    STSI ≔ read;    SSTSI ≔ read;
   STSB ≔ read;    STSST ≔ read;   STFSU ≔ read;   ENTRIS ≔ read;
   TFD ≔ read;     SAS ≔ read;     DECS ≔ read;    FAD ≔ read;
   TASR ≔ read;    TASI ≔ read;    TASB ≔ read;    TASST ≔ read;
   TASU ≔ read;    EXITIS ≔ read;  FADCV ≔ read;   TRSCV ≔ read;
   TISCV ≔ read;   TSCVU ≔ read;   EXIT ≔ read;    TEST1 ≔ read;
   TEST2 ≔ read;   CRV ≔ read;     CIV ≔ read;     CBV ≔ read;
   CSTV ≔ read;    CLV ≔ read;     CEN ≔ read;     CLPN ≔ read;
   TAV ≔ read;     TIAV ≔ read;    RAD ≔ read;     IAD ≔ read;
   BAD ≔ read;     STAD ≔ read;    ORAD ≔ read;    OIAD ≔ read;
   OBAD ≔ read;    OSTAD ≔ read;   LOS ≔ read;     EXITP ≔ read;
   EXITPC ≔ read;  REJST ≔ read;   JUA ≔ read;     EMPTY ≔ read;
   ABS ≔ read;     SIGN ≔ read;    ENTIER ≔ read;  SQRT ≔ read;
   EXP ≔ read;     LN ≔ read;      END ≔ read;





   TRV ≔ read;     TIV ≔ read;     TRC ≔ read;      TIC ≔ read;
   TSIC ≔ read;    TBV ≔ read;     TBC ≔ read;      TSTV ≔ read;
   TLV ≔ read;     TAK ≔ read;     TSWE ≔ read;     STR ≔ read;
   STI ≔ read;     SSTI ≔ read;    STB ≔ read;      STST ≔ read;
   DOS ≔ read;     DOS2 ≔ read;    DOS3 ≔ read;     JU ≔ read;
   JU1 ≔ read;     LJU ≔ read;     LJU1 ≔ read;     COJU ≔ read;
   YCOJU ≔ read;   SUBJ ≔ read;    ISUBJ ≔ read;    DECB ≔ read;
   DO ≔ read;      TBL ≔ read;     ENTRB ≔ read;    DPTR ≔ read;
   INCRB ≔ read;   TDL ≔ read;     ENTRPB ≔ read;   NIL ≔ read;
   LAST ≔ read;    LAD ≔ read;     TDA ≔ read;      TNA ≔ read;
   TAA ≔ read;     SWP ≔ read;     EXITB ≔ read;    EXITC ≔ read;
   EXITSV ≔ read;  CODE ≔ read;    SLNC ≔ read;     RLNC ≔ read;
   LNC ≔ read;

   d0 ≔ 1;        d1 ≔ 2;        d2 ≔ 4;         d3 ≔ 8;
   d4 ≔ 16;       d5 ≔ 32;       d6 ≔ 64;        d7 ≔ 128;
   d8 ≔ 256;      d9 ≔ 512;      d10 ≔ 1024;      d11 ≔ 2048;
   d12 ≔ 4096;     d13 ≔ 8192;     d14 ≔ 16384;     d15 ≔ 32768;
   d16 ≔ 65536;    d17 ≔ 131072;   d18 ≔ 262144;    d19 ≔ 524288;
   d20 ≔ 1048576;  d21 ≔ 2097152;  d22 ≔ 4194304;   d23 ≔ 8388608;
   d24 ≔ 16777216; d25 ≔ 33554432;

   re ≔ 0;         in ≔ 1;         bo ≔ 2;          st ≔ 3;
   ar ≔ 4;         nondes ≔ 5;     des ≔ 6;         un ≔ 7;
   arbo ≔ 8;       intlab ≔ 9;

   function letter ≔ read; function digit ≔ read; c variant ≔ read;

   <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> 127 <u>do</u> internal representation[n] ≔ read;
   <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u>  23 <u>do</u> word delimiter[n] ≔ read;
   <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> 511 <u>do</u> macro list[n] ≔ read;
   <u>for</u> n ≔ 5 <u>step</u> 1 <u>until</u>  59 <u>do</u> tabel[n] ≔ read;
   <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> 203 <u>do</u> instruct list[n] ≔ read;
   <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u>   9 <u>do</u> mask[n] ≔ d20 × read;

   end of memory ≔ read;
   end of list ≔ instruct list[174];
   text in memory ≔ true; erroneous ≔ derroneous ≔ false;
   wanted ≔ read = 0;


   <u>begin</u>   <u>integer</u> <u>array</u> space[0 : end of memory];

      <u>procedure</u> ERRORMESSAGE (n); <u>integer</u> n;
      <u>begin</u>   <u>integer</u> i;
         erroneous ≔ true;
         <u>if</u> n = 122 ∨ n = 123 ∨ n = 126 ∨ n = 127 ∨ n = 129
           <u>then</u> derroneous ≔ true;
         <u>if</u> n &GreaterSlantEqual; run number
           <u>then</u> <u>begin</u> NLCR; PRINTTEXT (“er”); print (n);
            print (line counter); print (last symbol);
            <u>for</u> i ≔ 0 <u>step</u> 1 <u>until</u> word count <u>do</u>
                 print (space[nl base - last nlp - i])
         <u>end</u>
      <u>end</u> ERRORMESSAGE;





      <u>integer</u> <u>procedure</u> next symbol;
      <u>begin</u>   <u>integer</u> symbol;
         next0:  symbol ≔ <u>if</u> stock1 &GreaterSlantEqual; 0 <u>then</u> stock1 <u>else</u> next basic symbol;
         stock1 ≔ -1;
         <u>if</u> (last symbol = semicolon ∨ last symbol = begin) ∧
           symbol = comment
           <u>then</u> <u>begin</u> skip0: symbol ≔ next basic symbol;
            <u>if</u> symbol ≠ semicolon <u>then</u> <u>goto</u> skip0;
            <u>goto</u> next0
         <u>end</u>;
         <u>if</u> last symbol = end
           <u>then</u> <u>begin</u>
            skip1: <u>if</u> symbol ≠ end ∧ symbol ≠ semicolon ∧ symbol ≠ else
              <u>then</u> <u>begin</u> symbol ≔ next basic symbol; <u>goto</u> skip1 <u>end</u>
         <u>end</u>
           <u>else</u>
         <u>if</u> symbol = 125
           <u>then</u> <u>begin</u> stock1 ≔ next basic symbol;
            <u>if</u> stock1 &gt; 9 ∧ stock1 &lt; 64
              <u>then</u> <u>begin</u> skip2: stock1 ≔ next basic symbol;
               <u>if</u> stock1 &gt; 9 ∧ stock1 &lt; 64
                 <u>then</u> <u>goto</u> skip2;
               <u>if</u> stock1 = colon
                 <u>then</u> stock1 ≔ next basic symbol
               <u>else</u> ERRORMESSAGE (100);
               <u>if</u> stock1 = open  <u>then</u> stock1 ≔ - stock1
               <u>else</u> ERRORMESSAGE (101);
               symbol ≔ comma
            <u>end</u>
            <u>else</u> symbol ≔ close
         <u>end</u>;
         digit last symbol ≔ symbol &lt; 10 ∨ symbol = period ∨
           symbol = ten;
         letter last symbol ≔ symbol &lt; 64 ∧ ¬ digit last symbol;
         next symbol ≔ last symbol ≔ symbol;
         outsymbol (run number, symbol);
         test pointers
      <u>end</u>  next symbol;


      <u>integer</u> <u>procedure</u>  next basic symbol;
      <u>begin</u>   <u>integer</u>  symbol;
         next0:  insymbol (run number, symbol);
         <u>if</u> symbol = new line
           <u>then</u> <u>begin</u> line counter ≔ line counter + 1;
            <u>if</u> quote counter = 0
              <u>then</u> <u>begin</u> outsymbol (run number, symbol);
               <u>goto</u> next0
            <u>end</u>
         <u>end</u>;
         next basic symbol ≔ symbol
      <u>end</u>  next basic symbol;







      <u>procedure</u>  insymbol (source, destination); <u>integer</u>  source, destination;
      <u>begin</u>   <u>integer</u>  symbol, i;
         <u>if</u> (source = 200 ∨ source = 300) ∧ text in memory
           <u>then</u>
         <u>begin</u> destination ≔ bit string(d8 × shift, shift,
              space[text base + text pointer]);
            <u>if</u> shift &lt; 257
              <u>then</u> shift ≔ d8 × shift
            <u>else</u> <u>begin</u> shift ≔ 1; text pointer ≔ text pointer + 1 <u>end</u>
         <u>end</u>
         <u>else</u>
         <u>begin</u> symbol ≔ <u>if</u> stock &gt; 0 <u>then</u> stock <u>else</u> next tape symbol;
            stock ≔ - 1;
            <u>if</u> symbol &gt; bus
              <u>then</u>
            <u>begin</u> <u>if</u> symbol = 123 <u>then</u> symbol ≔ space sbl;
               <u>if</u> quote counter &gt; 0
                 <u>then</u>
               <u>begin</u> <u>if</u> symbol = bar
                    <u>then</u>
                  <u>begin</u> next0: stock ≔ next tape symbol;
                     <u>if</u> stock = bar <u>then</u> <u>goto</u> next0;
                     <u>if</u> stock = les
                       <u>then</u> quote counter ≔ quote counter + 1
                       <u>else</u>
                     <u>if</u> stock = mor
                       <u>then</u>
                     <u>begin</u> <u>if</u> quote counter = 1
                          <u>then</u> <u>begin</u> symbol ≔ unquote;
                           stock ≔ - symbol
                        <u>end</u>
                        <u>else</u> quote counter ≔                           quote counter - 1
                     <u>end</u>
                  <u>end</u>
                    <u>else</u> <u>if</u> symbol = 124
                    <u>then</u> symbol ≔ colon
                    <u>else</u> <u>if</u> symbol = 125 <u>then</u> symbol ≔ close
               <u>end</u>
                 <u>else</u>
               <u>if</u> symbol &GreaterSlantEqual; newline
                 <u>then</u>
               <u>begin</u> <u>if</u> symbol = bar
                    <u>then</u>
                  <u>begin</u> next1: symbol ≔ next tape symbol;
                     <u>if</u> symbol = bar <u>then</u> <u>goto</u> next1;
                     symbol ≔ <u>if</u> symbol = and <u>then</u> ttp <u>else</u>
                       <u>if</u> symbol = equ <u>then</u> uqu <u>else</u>
                       <u>if</u> symbol = les <u>then</u> quote <u>else</u>
                       <u>if</u> symbol = mor <u>then</u> unquote
                     <u>else</u> 160
                  <u>end</u>
                    <u>else</u>
                  <u>if</u> symbol = underlining
                    <u>then</u>
                  <u>begin</u> symbol ≔ the underlined symbol;
                     <u>if</u> symbol &gt; 63
                       <u>then</u> symbol ≔                        <u>if</u> symbol = 124 <u>then</u> idi <u>else</u>
                       <u>if</u> symbol = les <u>then</u> mst <u>else</u>
                       <u>if</u> symbol = mor <u>then</u> lst <u>else</u>
                       <u>if</u> symbol = non <u>then</u> imp <u>else</u>
                       <u>if</u> symbol = equ <u>then</u> qvl
                     <u>else</u> 161
                     <u>else</u>
                     <u>begin</u> stock ≔ next tape symbol;
                        <u>if</u> stock = underlining
                          <u>then</u>
                        <u>begin</u>
                           symbol ≔ the underlined symbol +
                             d7 × symbol;
                           <u>for</u> i ≔ 0 <u>step</u> 1 <u>until</u> 23 <u>do</u>
                              <u>begin</u>
                                 <u>if</u> word delimiter[i] ÷ d7 = symbol
                                   <u>then</u>
                                 <u>begin</u>
                                    symbol ≔ word delimiter[i];
                                    symbol ≔ symbol -
                                      symbol ÷ d7 × d7;
                                    <u>goto</u> next2
                                 <u>end</u>
                              <u>end</u>;
                           symbol ≔ 162;
                           next2: stock ≔ next tape symbol;
                           <u>if</u> stock = underlining
                             <u>then</u>
                           <u>begin</u> the underlined symbol;
                              <u>goto</u> next2
                           <u>end</u>
                        <u>end</u>
                        <u>else</u> symbol ≔ 161
                     <u>end</u>
                  <u>end</u>
                    <u>else</u>
                  <u>if</u> symbol = 124
                    <u>then</u> <u>begin</u> stock ≔ next tape symbol;
                     <u>if</u> stock = equ
                       <u>then</u> <u>begin</u> symbol ≔ colonequal;
                        stock ≔ - symbol
                     <u>end</u>
                     <u>else</u> symbol ≔ colon
                  <u>end</u>
               <u>end</u>
               <u>else</u> insymbol (runnumber, symbol)
            <u>end</u>;
            destination ≔ symbol
         <u>end</u>
      <u>end</u>  insymbol;





      <u>integer</u> <u>procedure</u>  the underlined symbol;
      <u>begin</u>   <u>integer</u>  symbol;
         symbol ≔ next tape symbol;
         the underlined symbol ≔ <u>if</u> symbol = underlining
           <u>then</u> the underlined symbol
         <u>else</u> symbol
      <u>end</u>  the underlined symbol;

      <u>integer</u> <u>procedure</u>  next tape symbol;
      <u>begin</u>   <u>integer</u>  symbol, head;
         symbol ≔ internal representation[REHEP];
         <u>if</u> symbol &gt; 0
           <u>then</u> <u>begin</u> head ≔ symbol ÷ d8;
            next tape symbol ≔ abs (<u>if</u> case = lower case
              <u>then</u> symbol - d8 × head
            <u>else</u> head)
         <u>end</u>
         <u>else</u> <u>begin</u> <u>if</u> symbol &lt; - 2 <u>then</u> case ≔ - symbol <u>else</u>
            <u>if</u> symbol =   0 <u>then</u> ERRORMESSAGE (102) <u>else</u>
            <u>if</u> symbol = - 1 <u>then</u> ERRORMESSAGE (103);
            next tape symbol ≔ next tape symbol
         <u>end</u>
      <u>end</u>  next tape symbol;

      <u>procedure</u>  outsymbol (destination, source); <u>integer</u> destination, source;
      <u>begin</u>   <u>if</u> destination = 100 ∧ text in memory
           <u>then</u> <u>begin</u> space[text base + text pointer] ≔               space[text base + text pointer] + shift × source;
            <u>if</u> shift &lt; 257
              <u>then</u> shift ≔ d8 × shift
            <u>else</u> <u>begin</u> shift ≔ 1; text pointer ≔ text pointer + 1;
               space[text base + text pointer] ≔ 0
            <u>end</u>
         <u>end</u>
      <u>end</u>  outsymbol;


      <u>Boolean</u> <u>procedure</u>  arithoperator last symbol;
      <u>begin</u>   arithoperator last symbol ≔ last symbol = plus  ∨
           last symbol = minus ∨
           last symbol = mul   ∨
           last symbol = div   ∨
           last symbol = idi   ∨
           last symbol = ttp
      <u>end</u>  arithoperator last symbol;






      <u>Boolean</u> <u>procedure</u>  relatoperator last symbol;
      <u>begin</u>   relatoperator last symbol ≔ last symbol = les ∨
           last symbol = mst ∨
           last symbol = equ ∨
           last symbol = lst ∨
           last symbol = mor ∨
           last symbol = uqu
      <u>end</u>  relatoperator last symbol;


      <u>Boolean</u> <u>procedure</u>  booloperator last symbol;
      <u>begin</u>   booloperator last symbol ≔ last symbol = qvl ∨
           last symbol = imp ∨
           last symbol = or  ∨
           last symbol = and
      <u>end</u>  booloperator last symbol;


      <u>Boolean</u> <u>procedure</u>  declarator last symbol;
      <u>begin</u>   own type ≔ last symbol = own; <u>if</u>  own type <u>then</u>  next symbol;
         type ≔ <u>if</u> last symbol = rea   <u>then</u> 0 <u>else</u>
           <u>if</u> last symbol = integ <u>then</u> 1 <u>else</u>
           <u>if</u> last symbol = boole <u>then</u> 2 <u>else</u>
           <u>if</u> last symbol = stri  <u>then</u> 3 <u>else</u> 1000;
         <u>if</u> type &lt; 4 <u>then</u> next symbol
         <u>else</u> <u>begin</u> <u>if</u> own type <u>then</u>  ERRORMESSAGE (104);
            <u>if</u> last symbol = array <u>then</u>  type ≔ 0
         <u>end</u>;
         arr declarator last symbol ≔ last symbol = array;
         <u>if</u> arr declarator last symbol ∧ run number = 300
           <u>then</u> arr decla macro ≔ <u>if</u> own type
           <u>then</u> (<u>if</u> type = 0 <u>then</u> ORAD <u>else</u>
           <u>if</u> type = 1 <u>then</u> OIAD <u>else</u>
           <u>if</u> type = 2 <u>then</u> OBAD <u>else</u> OSTAD)
         <u>else</u> (<u>if</u> type = 0 <u>then</u> RAD <u>else</u>
           <u>if</u> type = 1 <u>then</u> IAD <u>else</u>
           <u>if</u> type = 2 <u>then</u> BAD <u>else</u> STAD);
         chara ≔ <u>if</u> arr declarator last symbol
           <u>then</u> 8
         <u>else</u> <u>if</u> last symbol = switch
           <u>then</u> 14
         <u>else</u> <u>if</u> last symbol = proced
           <u>then</u> (<u>if</u> type &lt; 4 <u>then</u> 16 <u>else</u> 24)
         <u>else</u> type;
         type declarator last symbol ≔ chara &lt; 4;
         <u>if</u> own type ∧ chara &gt; 8 <u>then</u> ERRORMESSAGE (105);
         <u>if</u> type &lt; 4 ∧ last symbol = switch <u>then</u> ERRORMESSAGE (106);
         <u>if</u> chara &lt; 25 ∧ run number = 100
           <u>then</u> character ≔ ((<u>if</u> type declarator last symbol
           <u>then</u> type
         <u>else</u> <u>if</u> type &lt; 4
           <u>then</u> type + chara
         <u>else</u> chara) +
           (<u>if</u> own type <u>then</u> 32 <u>else</u> 0)) × d19;
         declarator last symbol ≔ chara &lt; 25
      <u>end</u>  declarator last symbol;






      <u>Boolean</u> <u>procedure</u>  specifier last symbol;
      <u>begin</u>   type ≔ <u>if</u> last symbol = rea   <u>then</u> 0 <u>else</u>
           <u>if</u> last symbol = integ <u>then</u> 1 <u>else</u>
           <u>if</u> last symbol = boole <u>then</u> 2 <u>else</u>
           <u>if</u> last symbol = stri  <u>then</u> 3 <u>else</u>
           <u>if</u> last symbol = array <u>then</u> 5 <u>else</u> 1000;
         <u>if</u> type &lt; 4 <u>then</u> next symbol;
         chara ≔ <u>if</u> last symbol = label  <u>then</u> 6 <u>else</u>
           <u>if</u> last symbol = switch <u>then</u> 14 <u>else</u> 1000;
         <u>if</u> type + chara &lt; 1000 <u>then</u> ERRORMESSAGE(107);
         chara ≔ <u>if</u> last symbol = array  <u>then</u> 8 <u>else</u>
           <u>if</u> last symbol = proced <u>then</u> (<u>if</u> type &lt; 4 <u>then</u> 16
         <u>else</u> 24)
         <u>else</u> chara;
         <u>if</u> chara &lt; 25 <u>then</u> next symbol;
         <u>if</u> chara + type &lt; 2000 ∧ run number = 100
           <u>then</u> <u>begin</u> value character ≔ (<u>if</u> chara &gt; 8 <u>then</u> type <u>else</u>
              <u>if</u> chara = 6 <u>then</u>    6 <u>else</u>
              <u>if</u>  type = 5 <u>then</u>    8
            <u>else</u> type + chara) + 64;
            character ≔ ((<u>if</u> type &gt; 5
              <u>then</u> chara
            <u>else</u> (<u>if</u> type &gt; 1 <u>then</u> type <u>else</u> 4) +
              (<u>if</u> chara &lt; 1000 <u>then</u> chara
            <u>else</u> 0))
              + 96) × d19
         <u>end</u>;
         specifier last symbol ≔ chara + type &lt; 2000
      <u>end</u>  specifier last symbol;


      <u>Boolean</u> <u>procedure</u>  operator last symbol;
      <u>begin</u>   operator last symbol ≔ arithoperator last symbol ∨
           relatoperator last symbol ∨
           booloperator last symbol
      <u>end</u>  operator last symbol;






      <u>procedure</u>  unsigned number;
      <u>begin</u>   <u>integer</u>  sign of exponent;
         <u>if</u> last symbol &lt; 10
           <u>then</u> <u>begin</u> value of constant ≔ unsigned integer (0);
            real number ≔ digit last symbol
         <u>end</u>
         <u>else</u> <u>begin</u> value of constant ≔ <u>if</u> last symbol = ten <u>then</u> 1
            <u>else</u> 0;
            real number ≔ true
         <u>end</u>;
         decimal exponent ≔ 0;
         <u>if</u> real number
           <u>then</u> <u>begin</u>
            next0: <u>if</u> last symbol &lt; 10
              <u>then</u> <u>begin</u> decimal exponent ≔ decimal exponent + 1;
               next symbol; <u>goto</u> next0
            <u>end</u>;
            <u>if</u> last symbol = period
              <u>then</u> <u>begin</u> next symbol;
               value of constant ≔                  unsigned integer (value of constant);
               decimal exponent ≔ decimal exponent -
                 decimal count;
               next1: <u>if</u> last symbol &lt; 10
                 <u>then</u> <u>begin</u> next symbol; <u>goto</u> next1 <u>end</u>
            <u>end</u>;
            <u>if</u> last symbol = ten
              <u>then</u> <u>begin</u> next symbol; sign of exponent ≔ 1;
               <u>if</u> last symbol = plus
                 <u>then</u> next symbol
                 <u>else</u> <u>if</u> last symbol = minus
                 <u>then</u> <u>begin</u> next symbol;
                  sign of exponent ≔ - 1
               <u>end</u>;
               decimal exponent ≔ decimal exponent +
                 sign of exponent ×
                 unsigned integer (0);
               <u>if</u> last symbol &lt; 10
                 <u>then</u> <u>begin</u>  ERRORMESSAGE (108);
                  next2: <u>if</u> next symbol &lt; 9
                    <u>then</u> <u>goto</u> next2
               <u>end</u>
            <u>end</u>
         <u>end</u>;
         small ≔ value of constant &lt; d15 ∧ ¬ real number
      <u>end</u>  unsigned number;






      <u>integer</u> <u>procedure</u>  unsigned integer (start); <u>integer</u> start;
      <u>begin</u>   <u>integer</u>  word;
         word ≔ start; decimal count ≔ 0;
         <u>if</u> last symbol &gt; 9 <u>then</u> ERRORMESSAGE (109);
         next0:  <u>if</u> last symbol &lt; 10
           <u>then</u> <u>begin</u> <u>if</u> word &lt; 6710886 ∨ (word = 6710886 ∧ last symbol &lt; 4)
              <u>then</u> <u>begin</u> word ≔ 10 × word + last symbol;
               decimal count ≔ decimal count + 1;
               next symbol; <u>goto</u> next0
            <u>end</u>
         <u>end</u>;
         unsigned integer ≔ word
      <u>end</u>  unsigned integer;


      <u>procedure</u>  read identifier;
      <u>begin</u>   <u>integer</u>  word, count;
         word ≔ count ≔ word count ≔ 0;
         <u>if</u> letter last symbol
           <u>then</u>
         <u>begin</u>
            next0: <u>if</u> last symbol &lt; 64
              <u>then</u>
            <u>begin</u> <u>if</u> count = 4
                 <u>then</u> <u>begin</u> word count ≔ word count + 1;
                  word ≔ count ≔ 0
               <u>end</u>;
               word ≔ space[nl base - nlp - word count] ≔                  d6 × word - last symbol - 1;
               count ≔ count + 1; next symbol; <u>goto</u> next0
            <u>end</u>
            <u>else</u>
            <u>begin</u> last identifier ≔ space[nl base - nlp];
               last identifierl ≔ <u>if</u> word count = 0
                 <u>then</u> 0
               <u>else</u> space[nl base - nlp - 1]
            <u>end</u>
         <u>end</u>
         <u>else</u> <u>begin</u> ERRORMESSAGE (110); space[nl base - nlp] ≔ - 1 <u>end</u>;
         space[nl base - nlp - word count - 1] ≔ 127 × d19
      <u>end</u>  read identifier;


      <u>integer</u> <u>procedure</u>  next pointer (n); <u>integer</u> n;
      <u>begin</u>   <u>integer</u>  word, pointer;
         pointer ≔ n;
         next0:  word ≔ - space[nl base - pointer];
         <u>if</u> word &LessSlantEqual;   0 <u>then</u> <u>begin</u> pointer ≔ pointer + 1; <u>goto</u> next0 <u>end</u>;
         <u>if</u> word &GreaterSlantEqual; d25 <u>then</u> <u>begin</u> pointer ≔ word - word ÷ d13 × d13;
            <u>goto</u> next0
         <u>end</u>;
         next pointer ≔ pointer
      <u>end</u>  next pointer;






      <u>integer</u> <u>procedure</u>  look up;
      <u>begin</u>   <u>integer</u>  count, pointer;
         pointer ≔ block cell pointer +
           (<u>if</u> in formal list ∨ in array declaration
           <u>then</u> 5 <u>else</u> 4);
         next0:  pointer ≔ next pointer (pointer);
         <u>for</u> count ≔ 0 <u>step</u> 1 <u>until</u> word count <u>do</u>
            <u>begin</u> <u>if</u> space[nl base - pointer - count] ≠
                 space[nl base - last nlp - count]
                 <u>then</u> <u>goto</u> next1
            <u>end</u>;
         pointer ≔ pointer + word count + 1;
         <u>if</u> space[nl base - pointer] &lt; 0
           <u>then</u> <u>begin</u> next1: pointer ≔ pointer + 1;
            <u>goto</u> <u>if</u> space[nl base - pointer] &lt; 0 <u>then</u> next1
            <u>else</u> next0
         <u>end</u>;
         look up ≔ pointer
      <u>end</u>  look up;


      <u>Boolean</u> <u>procedure</u>  in name list;
      <u>begin</u>   <u>integer</u> head;
         <u>if</u> real number ∨ ¬ int labels
           <u>then</u> in name list ≔ false
         <u>else</u> <u>begin</u> head ≔ value of constant ÷ d18;
            space[nl base - nlp] ≔ - d12 - head;
            space[nl base - nlp - 1] ≔               (head - 1) × d18 - value of constant;
            word count ≔ 1;
            space[nl base - nlp - 2] ≔ 6 × d19;
            last nlp ≔ nlp; integer label ≔ look up;
            in name list ≔ integer label &lt; nlp
         <u>end</u>
      <u>end</u>  in name list;


      <u>integer</u> <u>procedure</u>  next identifier (n); <u>integer</u> n;
      <u>begin</u>   <u>integer</u>  pointer;
         pointer ≔ next pointer (n) + 1;
         next0:  <u>if</u> space[nl base - pointer] &lt; 0
           <u>then</u> <u>begin</u> pointer ≔ pointer + 1; <u>goto</u> next0 <u>end</u>;
         next identifier ≔ pointer
      <u>end</u>  next identifier;






      <u>procedure</u>  skip identifier;
      <u>begin</u>   <u>if</u> last symbol &lt; 64 <u>then</u> <u>begin</u> next symbol; skip identifier <u>end</u>
      <u>end</u>  skip identifier;


      <u>procedure</u>  skip type declaration;
      <u>begin</u>   <u>if</u> letter last symbol <u>then</u> skip identifier;
         <u>if</u> last symbol = comma
           <u>then</u> <u>begin</u> next symbol; skip type declaration <u>end</u>
      <u>end</u>  skip type declaration;


      <u>procedure</u>  skip value list;
      <u>begin</u>   <u>if</u> last symbol = value
           <u>then</u> <u>begin</u> next symbol; skip type declaration;
            <u>if</u> last symbol = semicolon <u>then</u> next symbol
         <u>end</u>
      <u>end</u>  skip value list;


      <u>procedure</u>  skip specification list;
      <u>begin</u>   <u>if</u> specifier last symbol
           <u>then</u> <u>begin</u> skip type declaration;
            <u>if</u> last symbol = semicolon <u>then</u> next symbol;
            skip specification list
         <u>end</u>
      <u>end</u>  skip specification list;


      <u>procedure</u> skip string;
      <u>begin</u>   quote counter ≔ 1;
         next0:  <u>if</u> next symbol ≠ unquote <u>then</u> <u>goto</u> next0;
         quote counter ≔ 0
      <u>end</u>  skip string;


      <u>procedure</u> skip rest of statement (pr); <u>procedure</u> pr;
      <u>begin</u>   <u>if</u> last symbol = do
           <u>then</u> <u>begin</u> next symbol; pr <u>end</u>
           <u>else</u>
         <u>if</u> last symbol = goto ∨ last symbol = for ∨
           last symbol = begin
           <u>then</u> pr;
         <u>if</u> last symbol = quote <u>then</u> skip string;
         <u>if</u> last symbol ≠ semicolon ∧ last symbol ≠ end
           <u>then</u> <u>begin</u> next symbol;
            skip rest of statement (pr)
         <u>end</u>
      <u>end</u>  skip rest of statement;






      <u>integer</u> <u>procedure</u> bit string (kn, n, code word); <u>integer</u> kn,n,code word;
      <u>begin</u>   <u>integer</u>  k;
         k ≔ code word ÷ kn; bit string ≔ (code word - k × kn) ÷ n
      <u>end</u>  bit string;


      <u>integer</u> <u>procedure</u>  display level;
      <u>begin</u>   display level ≔            bit string (d6, d0, space[nl base - block cell pointer - 1])
      <u>end</u>  display level;


      <u>integer</u> <u>procedure</u>  top of display;
      <u>begin</u>   top of display ≔            bit string (d13, d6, space[nl base - block cell pointer - 1])
      <u>end</u>  top of display;


      <u>integer</u> <u>procedure</u>  local space;
      <u>begin</u>   local space ≔ space[nl base - block cell pointer - 1] ÷ d13
      <u>end</u>  local space;


      <u>integer</u> <u>procedure</u>  proc level;
      <u>begin</u>   proc level ≔            bit string (d6, d0, space[nl base - block cell pointer - 2])
      <u>end</u>  proc level;


      <u>Boolean</u> <u>procedure</u>  use of counter stack;
      <u>begin</u>   use of counter stack ≔            bit string (d7, d6, space[nl base - block cell pointer - 2]) = 1
      <u>end</u>  use of counter stack;


      <u>integer</u> <u>procedure</u>  status;
      <u>begin</u>   status ≔ space[nl base - block cell pointer - 2] ÷ d13
      <u>end</u> status;


      <u>Boolean</u> <u>procedure</u>  in code (n); <u>integer</u> n;
      <u>begin</u>   in code ≔ bit string (d25, d24, space[nl base - n - 1]) = 1
      <u>end</u>  in code;


      <u>integer</u> <u>procedure</u>  type bits (n); <u>integer</u> n;
      <u>begin</u>   type bits ≔ bit string (d22, d19, space[nl base - n])
      <u>end</u> type bits;






      <u>Boolean</u> <u>procedure</u>  local label (n); <u>integer</u> n;
      <u>begin</u>   local label ≔            nonformal label (n) ∧
           bit string(d6, d0,
           space[nl base - corresponding block cell pointer (n) - 1]) =
           display level
      <u>end</u>  local label;


      <u>Boolean</u> <u>procedure</u>  nonformal label (n); <u>integer</u> n;
      <u>begin</u>   nonformal label ≔ space[nl base - n] ÷ d19 = 6
      <u>end</u> nonformal label;


      <u>integer</u> <u>procedure</u>  corresponding block cell pointer (n); <u>integer</u> n;
      <u>begin</u>   <u>integer</u> p;
         p ≔ block cell pointer;
         next0:  <u>if</u> n &lt; p ∨ (n &gt; space[nl base - p - 2] ÷ d13 ∧ p &gt; 0)
           <u>then</u> <u>begin</u> p ≔ space[nl base - p] ÷ d13; <u>goto</u> next0 <u>end</u>;
         corresponding block cell pointer ≔ p
      <u>end</u>  corresponding block cell pointer;


      <u>procedure</u>  entrance block;
      <u>begin</u>   block cell pointer ≔ next block cell pointer;
         next block cell pointer ≔            bit string (d13, d0, space[nl base - block cell pointer])
      <u>end</u>  entrance block;


      <u>procedure</u>  exit block;
      <u>begin</u>   block cell pointer ≔ space[nl base - block cell pointer] ÷ d13
      <u>end</u>  exit block;


      <u>procedure</u>  init;
      <u>begin</u>   stock ≔ stock1 ≔ last symbol ≔ word count ≔ - 1;
         shift ≔ 1;
         line counter ≔ quote counter ≔ for count ≔ 0;
         in formal list ≔ in array declaration ≔ false;
         case ≔ lower case; text pointer ≔ 0
      <u>end</u>  init;






      <u>procedure</u> test pointers;
      <u>begin</u>   <u>integer</u> fprog, fnl, i, shift;
         <u>if</u> text in memory
           <u>then</u>
         <u>begin</u> fprog ≔ text base +
              (<u>if</u> runnumber = 300 <u>then</u> text pointer <u>else</u> 0) -
              instruct counter;
            fnl ≔ nl base - nlp -
              (text base +
              (<u>if</u> runnumber = 100 <u>then</u> text pointer
            <u>else</u> end of text));
            <u>if</u> fprog + fnl &lt; 40
              <u>then</u> <u>begin</u> text in memory ≔ false; test pointers <u>end</u>
              <u>else</u> <u>if</u> fprog &lt; 20
              <u>then</u> <u>begin</u> shift ≔ (fnl - fprog) ÷ 2;
               <u>for</u> i ≔ text base + text pointer
                 <u>step</u> - 1 <u>until</u> text base <u>do</u>
                    space[i + shift] ≔ space[i];
               text base ≔ text base + shift
            <u>end</u>
              <u>else</u> <u>if</u> fnl &lt; 20
              <u>then</u>
            <u>begin</u> shift ≔ (fprog - fnl) ÷ 2;
               <u>for</u> i ≔ text base <u>step</u> 1
                 <u>until</u> text base + text pointer <u>do</u>
                    space[i] ≔ space[i + shift];
               text base ≔ text base - shift
            <u>end</u>
         <u>end</u>
           <u>else</u> <u>if</u> nl base - nlp - instruct counter &lt; 20
           <u>then</u> <u>begin</u> ERRORMESSAGE (492); <u>goto</u> endrun <u>end</u>
      <u>end</u>  test pointers;






      <u>procedure</u> prescan0;
      <u>begin</u>   <u>integer</u> old block cell pointer, displ level, prc level,
           global count, local count, label count, local for count,
           max for count, internal block depth, string occurrence,
           subcount, array pointer;


         <u>procedure</u>  Program;
         <u>begin</u>   <u>integer</u>  n;
            character ≔ 6 × d19;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> read identifier;
               <u>if</u> last symbol = colon
                 <u>then</u> <u>begin</u> n ≔ Process identifier;
                  Label declaration (n)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (111);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> last symbol = colon <u>then</u> Int lab declaration
               <u>else</u> ERRORMESSAGE (112);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = begin
              <u>then</u> Begin statement
            <u>else</u> <u>begin</u> ERRORMESSAGE (113); next symbol; Program <u>end</u>
         <u>end</u>  Program;


         <u>integer</u> <u>procedure</u>  Block (proc identifier); <u>integer</u>  proc identifier;
         <u>begin</u>   <u>integer</u>  dump1, dump2, dump3, dump4, dump5, dump6, dump7, dump8,
              n, formal count;
            dump1 ≔ block cell pointer; dump2 ≔ local for count;
            dump3 ≔ max for count;      dump4 ≔ local count;
            dump5 ≔ label count;        dump6 ≔ internal block depth;
            dump7 ≔ string occurrence;  dump8 ≔ prc level;
            local for count ≔ max for count ≔ local count ≔ label count ≔               internal block depth ≔ string occurrence ≔ 0;
            block cell pointer ≔ nlp + 1;
            space[nl base - old block cell pointer] ≔               space[nl base - old block cell pointer] + block cell pointer;
            old block cell pointer ≔ block cell pointer;
            space[nl base - block cell pointer] ≔ dump1 × d13;
            space[nl base - block cell pointer - 1] ≔ displ level ≔               displ level + 1;
            space[nl base - block cell pointer - 3] ≔ 0;
            nlp ≔ nlp + 6;




            <u>if</u> proc identifier &gt; 0
              <u>then</u>
            <u>begin</u> prc level ≔ displ level; formal count ≔ 0;
               space[nl base - block cell pointer - 4] ≔ - d25 - nlp;
               <u>if</u> last symbol = open
                 <u>then</u> <u>begin</u>  character ≔ 127 × d19;
                  next0: next symbol; Identifier;
                  space[nl base - nlp] ≔ 0; nlp ≔ nlp + 1;
                  formal count ≔ formal count + 1;
                  <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next0;
                  <u>if</u> last symbol = close <u>then</u> next symbol
                  <u>else</u> ERRORMESSAGE (114)
               <u>end</u>;
               <u>if</u> last symbol = semicolon <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (115);
               space[nl base - proc identifier - 1] ≔                  d22 + formal count + 1 ;
               <u>if</u> last symbol = value
                 <u>then</u>
               <u>begin</u>
                  next1: next symbol; n ≔ Identifier;
                  <u>if</u> n &gt; last nlp  <u>then</u> ERRORMESSAGE (116)
                  <u>else</u> space[nl base - n] ≔ 95 × d19;
                  nlp ≔ last nlp;
                  <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next1;
                  <u>if</u> last symbol = semicolon <u>then</u> next symbol
                  <u>else</u> ERRORMESSAGE (117)
               <u>end</u>;
               next2: <u>if</u> specifier last symbol
                 <u>then</u>
               <u>begin</u>
                  next3: n ≔ Identifier;
                  <u>if</u> n &gt; last nlp
                    <u>then</u> ERRORMESSAGE (118)
                    <u>else</u> <u>if</u> space[nl base - n] = 127 × d19
                    <u>then</u> space[nl base - n] ≔ character
                    <u>else</u> <u>if</u> space[nl base - n] ≠  95 × d19
                    <u>then</u> ERRORMESSAGE (119)
                    <u>else</u> <u>if</u> value character &gt; 75
                    <u>then</u> ERRORMESSAGE (120)
                  <u>else</u>
                  <u>begin</u> space[nl base - n] ≔                        value character × d19;
                     <u>if</u> type = 3
                       <u>then</u> string occurrence ≔ d6
                  <u>end</u>;
                  nlp ≔ last nlp;
                  <u>if</u> last symbol = comma
                    <u>then</u> <u>begin</u> next symbol; <u>goto</u> next3 <u>end</u>;
                  <u>if</u> last symbol = semicolon <u>then</u> next symbol
                  <u>else</u> ERRORMESSAGE (121);
                  <u>goto</u> next2
               <u>end</u>;




               space[nl base - nlp] ≔ - d25 - 4 - dump1; nlp ≔ nlp + 1;
               space[nl base - block cell pointer - 4] ≔ - d25 - nlp;
               <u>if</u> last symbol = quote
                 <u>then</u> <u>begin</u>  space[nl base - proc identifier - 1] ≔                     space[nl base - proc identifier - 1] + d24;
                  next4: next symbol;
                  <u>if</u> last symbol ≠ unquote <u>then</u> <u>goto</u> next4;
                  next symbol
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = begin
                 <u>then</u> <u>begin</u> next symbol;
                  <u>if</u> declarator last symbol <u>then</u> Declaration list;
                  Compound tail; next symbol
               <u>end</u>
               <u>else</u> Statement
            <u>end</u>
            <u>else</u>
            <u>begin</u> space[nl base - nlp] ≔ - d25 - 4 - dump1; nlp ≔ nlp + 1;
               space[nl base - block cell pointer - 4] ≔ - d25 - nlp;
               Declaration list; Compound tail
            <u>end</u>;

            space[nl base - block cell pointer - 2] ≔               d13 × nlp + string occurrence + prc level;
            <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> max for count - 1 <u>do</u>
                 space[nl base - nlp - 1] ≔ d19;
            space[nl base - block cell pointer - 1] ≔               space[nl base - block cell pointer - 1] +
              d6 × (internal block depth + 1);
            <u>if</u> prc level &gt; 1
              <u>then</u> space[nl base - block cell pointer - 1] ≔               space[nl base - block cell pointer - 1] +
              d13 × (max for count + local count)
            <u>else</u> global count ≔ global count + max for count +
              local count + label count;
            nlp ≔ nlp + max for count;
            space[nl base - nlp] ≔ - d25 - 5 - block cell pointer;
            nlp ≔ nlp + 1;
            space[nl base - block cell pointer + 1] ≔ - d25 - nlp;
            displ level ≔ space[nl base - dump1 - 1];
            Block ≔ internal block depth + 1;
            block cell pointer ≔ dump1; local for count ≔ dump2;
            max for count ≔ dump3;      local count ≔ dump4;
            label count ≔ dump5;        internal block depth ≔ dump6;
            string occurrence ≔ dump7;  prc level ≔ dump8
         <u>end</u>  Block;


         <u>procedure</u>  Compound tail;
         <u>begin</u>   Statement; <u>if</u>  last symbol = semicolon
              <u>then</u> <u>begin</u> next symbol; Compound tail <u>end</u>
         <u>end</u>  Compound tail;






         <u>procedure</u>  Declaration list;
         <u>begin</u>   <u>integer</u>  n, count;
            next0:  <u>if</u> type declarator last symbol
              <u>then</u> <u>begin</u>  count ≔ 0;
               next1: count ≔ count + 1;
               n ≔ Identifier;
               <u>if</u> n &lt; last nlp <u>then</u> ERRORMESSAGE (122);
               <u>if</u> last symbol = comma
                 <u>then</u> <u>begin</u> next symbol; <u>goto</u> next1 <u>end</u>;
               <u>if</u> type = 0 ∨ type = 3 <u>then</u> count ≔ 2 × count;
               <u>if</u> own type <u>then</u> global count ≔ global count + count
               <u>else</u> local count ≔ local count + count;
               <u>if</u> type = 3 <u>then</u> string occurrence ≔ d6
            <u>end</u>
              <u>else</u>
            <u>if</u> arr declarator last symbol
              <u>then</u> <u>begin</u>  count ≔ array pointer ≔ 0;
               next2:  count ≔ count + 1;
               next symbol; n ≔ Identifier;
               <u>if</u> n &lt; last nlp <u>then</u> ERRORMESSAGE (123);
               space[nl base - nlp] ≔ array pointer;
               array pointer ≔ nlp; nlp ≔ nlp + 1;
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next2;
               dimension ≔ 0;
               <u>if</u> last symbol = sub
                 <u>then</u>
               <u>begin</u>  subcount ≔ 1;
                  next3: next symbol;
                  <u>if</u> letter last symbol
                    <u>then</u> skip identifier
                    <u>else</u> <u>if</u> digit last symbol
                    <u>then</u> <u>begin</u> unsigned number;
                     Store numerical constant
                  <u>end</u>;
                  <u>if</u> last symbol = quote <u>then</u> skip string;
                  <u>if</u> last symbol = colon
                    <u>then</u> <u>begin</u> dimension ≔ dimension + 1;
                     <u>goto</u> next3
                  <u>end</u>;
                  <u>if</u> last symbol = sub
                    <u>then</u> <u>begin</u> subcount ≔ subcount + 1;
                     <u>goto</u> next3
                  <u>end</u>;
                  <u>if</u> last symbol ≠ bus <u>then</u> <u>goto</u> next3;
                  <u>if</u> subcount &gt; 1
                    <u>then</u> <u>begin</u> subcount ≔ subcount - 1;
                     <u>goto</u> next3
                  <u>end</u>;
                  next symbol;
                  <u>if</u> dimension = 0 <u>then</u> ERRORMESSAGE (124)
                  <u>else</u> dimension ≔ dimension + 1
               <u>end</u>
               <u>else</u> ERRORMESSAGE (125);




               next4: n ≔ space[nl base - array pointer];
               space[nl base - array pointer] ≔ dimension;
               array pointer ≔ n;
               <u>if</u> n ≠ 0 <u>then</u> <u>goto</u> next4;
               <u>if</u> own type
                 <u>then</u> global count ≔                  global count + (3 × dimension + 3) × count
               <u>else</u> local count ≔ local count + count;
               <u>if</u> last symbol = comma
                 <u>then</u> <u>begin</u> count ≔ 0; <u>goto</u> next2 <u>end</u>;
               <u>if</u> type = 3 <u>then</u> string occurrence ≔ d6
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = switch
              <u>then</u> <u>begin</u> next symbol; n ≔ Identifier;
               <u>if</u> n &lt; last nlp <u>then</u> ERRORMESSAGE (126);
               space[nl base - nlp] ≔ 0; nlp ≔ nlp + 1;
               next5: next symbol;
               <u>if</u> letter last symbol
                 <u>then</u> skip identifier
                 <u>else</u> <u>if</u> digit last symbol
                 <u>then</u> <u>begin</u> unsigned number;
                  Store numerical constant
               <u>end</u>;
               <u>if</u> last symbol = quote <u>then</u> skip string;
               <u>if</u> last symbol ≠ semicolon <u>then</u> <u>goto</u> next5
            <u>end</u>
            <u>else</u> <u>begin</u> next symbol; n ≔ Identifier;
               <u>if</u> n &lt; last nlp <u>then</u> ERRORMESSAGE (127);
               nlp ≔ nlp + 1;
               <u>if</u> type &lt; 4
                 <u>then</u> <u>begin</u> space[nl base - nlp] ≔ type × d19;
                  nlp ≔ nlp + 1
               <u>end</u>;
               Block (n)
            <u>end</u>;
            <u>if</u> last symbol = semicolon <u>then</u> next symbol
            <u>else</u> ERRORMESSAGE (128);
            <u>if</u> declarator last symbol <u>then</u> <u>goto</u> next0
         <u>end</u>  Deciaration list;






         <u>procedure</u>  Statement;
         <u>begin</u>   <u>integer</u>  n, lfc;
            lfc ≔ local for count;
            next0:  character ≔ 6 × d19;
            next1:  <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> read identifier;
               <u>if</u> last symbol = colon
                 <u>then</u> <u>begin</u> n ≔ Process identifier;
                  Label declaration (n);
                  <u>goto</u> next1
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> last symbol = colon
                 <u>then</u> <u>begin</u> Int lab declaration; <u>goto</u> next1 <u>end</u>
               <u>else</u> Store numerical constant
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = for
              <u>then</u> <u>begin</u> local for count ≔ local for count + 1;
               <u>if</u> local for count &gt; max for count
                 <u>then</u> max for count ≔ local for count
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = begin
              <u>then</u> <u>begin</u> Begin statement; next symbol; <u>goto</u> next1 <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = quote <u>then</u> skip string;
            <u>if</u> last symbol ≠ semicolon ∧ last symbol ≠ end
              <u>then</u> <u>begin</u> next symbol; <u>goto</u> next1 <u>end</u>;
            local for count ≔ lfc
         <u>end</u>  Statement;


         <u>procedure</u>  Label declaration (n); <u>integer</u> n;
         <u>begin</u>   <u>if</u> n &lt; last nlp <u>then</u> ERRORMESSAGE (129);
            <u>if</u> label count = 0
              <u>then</u> space[nl base - block cell pointer - 3] ≔ d13 × (nlp - 1);
            label count ≔ label count + 2;
            space[nl base - nlp] ≔ d18; nlp ≔ nlp + 1;
            next symbol
         <u>end</u>  Label declaration;


         <u>procedure</u> Int lab declaration;
         <u>begin</u>   <u>if</u> real number
              <u>then</u> <u>begin</u> ERRORMESSAGE (130); next symbol <u>end</u>
            <u>else</u> <u>begin</u> int labels ≔ true;
               in name list; nlp ≔ nlp + 3;
               Label declaration (integer label)
            <u>end</u>
         <u>end</u>  Int lab declaration;






         <u>procedure</u> Begin statement;
         <u>begin</u>   <u>integer</u> n;
            next symbol;
            <u>if</u> declarator last symbol
              <u>then</u> <u>begin</u> n ≔ Block (0);
               <u>if</u> n &gt; internal block depth
                 <u>then</u> internal block depth ≔ n
            <u>end</u>
            <u>else</u> Compound tail
         <u>end</u>  Begin statement;


         <u>procedure</u>  Store numerical constant;
         <u>begin</u>   <u>if</u> ¬ small
              <u>then</u> <u>begin</u> space[prog base + instruct counter] ≔                  value of constant;
               space[prog base + instruct counter + 1] ≔                  decimal exponent;
               instruct counter ≔ instruct counter + 2
            <u>end</u>
         <u>end</u>  Store numerical constant;


         <u>integer</u> <u>procedure</u>  Process identifier;
         <u>begin</u>   last nlp ≔ nlp; nlp ≔ nlp + word count + 2;
            space[nl base - nlp + 1] ≔ character;
            Process identifier ≔ look up
         <u>end</u>  Process identifier;


         <u>integer</u> <u>procedure</u>  Identifier;
         <u>begin</u>   read identifier;
            Identifier ≔ Process identifier
         <u>end</u>  Identifier;






         main program of prescan0:
         runnumber ≔ 100; init;
         local for count ≔ max for count ≔ local count ≔ label count ≔            global count ≔ internal block depth ≔ string occurrence ≔            displ level ≔ prc level ≔ 0;
         old block cell pointer ≔ block cell pointer ≔ nlp;
         int labels ≔ false;
         space[text base] ≔            space[nl base - block cell pointer] ≔            space[nl base - block cell pointer - 1] ≔            space[nl base - block cell pointer - 3] ≔ 0;
         nlp ≔ block cell pointer + 6;
         space[nl base - block cell pointer - 4] ≔ - d25 - nlp;
         next symbol;
         Program;
         space[nl base - block cell pointer - 1] ≔            (global count + max for count + label count) × d13 +
           (internal block depth + 1) × (d13 + d6);
         space[nl base - block cell pointer - 2] ≔ nlp × d13;
         <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> max for count - 1 <u>do</u>
              space[nl base - nlp - n] ≔ d19;
         nlp ≔ nlp + max for count;
         space[nl base - block cell pointer - 5] ≔ - d25 - nlp;
         end of text ≔ text pointer;
         output
      <u>end</u>  prescan0;






      <u>procedure</u> prescan1;
      <u>begin</u>


         <u>procedure</u>  Arithexp;
         <u>begin</u>   <u>if</u> last symbol = if <u>then</u> Ifclause (Arithexp)
            <u>else</u> Simple arithexp
         <u>end</u>  Arithexp;


         <u>procedure</u>  Simple arithexp;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = plus ∨ last symbol = minus
              <u>then</u>
              next0:  next symbol;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; Arithexp;
               <u>if</u> last symbol = close <u>then</u> next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol <u>then</u> unsigned number
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier; Arithmetic (n);
               Subscripted variable(n); Function designator(n)
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = if <u>then</u> Arithexp;
            <u>if</u> arithoperator last symbol <u>then</u> <u>goto</u> next0
         <u>end</u>  Simple arithexp;


         <u>procedure</u>  Subscripted variable (n); <u>integer</u> n;
         <u>begin</u>   <u>if</u> last symbol = sub <u>then</u> <u>begin</u> Subscrvar (n);
               dimension ≔ Subscrlist;
               List length (n)
            <u>end</u>
         <u>end</u>  Subscripted variable;


         <u>integer</u> <u>procedure</u>  Subscrlist;
         <u>begin</u> next symbol;  Arithexp;
            <u>if</u> last symbol = comma <u>then</u> Subscrlist ≔ Subscrlist + 1
            <u>else</u> <u>begin</u> <u>if</u> last symbol = bus
                 <u>then</u> next symbol;
               Subscrlist ≔ 1
            <u>end</u>
         <u>end</u>  Subscrlist;


         <u>procedure</u>  Boolexp;
         <u>begin</u>   <u>if</u> last symbol = if <u>then</u> Ifclause (Boolexp)
            <u>else</u> Simple boolean
         <u>end</u>  Boolexp;






         <u>procedure</u>  Simple boolean;
         <u>begin</u>   <u>integer</u>  n, type;
            <u>if</u> last symbol = non  <u>then</u> next symbol;
            <u>if</u> last symbol = open <u>then</u> <u>begin</u> next symbol; Exp (type);
               <u>if</u> last symbol = close
                 <u>then</u> next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol <u>then</u> <u>begin</u> n ≔ Identifier;
               Subscripted variable (n);
               Function designator (n);
               <u>if</u> arithoperator last symbol ∨
                 relatoperator last symbol
                 <u>then</u> Arithmetic (n)
               <u>else</u> Boolean (n)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol ∨ last symbol = plus ∨ last symbol = minus
              <u>then</u> Simple arithexp
              <u>else</u>
            <u>if</u> last symbol = true ∨ last symbol = false <u>then</u> next symbol;
            Rest of exp (type)
         <u>end</u>  Simple boolean;


         <u>procedure</u>  Stringexp;
         <u>begin</u>   <u>if</u> last symbol = if <u>then</u> Ifclause (Stringexp)
            <u>else</u> Simple stringexp
         <u>end</u>  Stringexp;


         <u>procedure</u>  Simple stringexp;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; Stringexp;
               <u>if</u> last symbol = close <u>then</u> next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier; String (n);
               Subscripted variable (n);
               Function designator (n)
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = quote
              <u>then</u> <u>begin</u>  quote counter ≔ 1;
               next0: next symbol;
               <u>if</u> last symbol = unquote
                 <u>then</u> <u>begin</u> quote counter ≔ 0;
                  next symbol
               <u>end</u>
               <u>else</u> <u>goto</u> next0
            <u>end</u>
         <u>end</u>  Simple stringexp;






         <u>procedure</u>  Desigexp;
         <u>begin</u>   <u>if</u> last symbol = if <u>then</u> Ifclause (Desigexp)
            <u>else</u> Simple desigexp
         <u>end</u>  Desigexp;


         <u>procedure</u>  Simple desigexp;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; Desigexp;
               <u>if</u> last symbol = close <u>then</u> next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier; Designational (n);
               Subscripted variable (n)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> in name list
                 <u>then</u> Designational (integer label)
            <u>end</u>
         <u>end</u>  Simple desigexp;


         <u>procedure</u>  Exp (type); <u>integer</u> type;
         <u>begin</u>   <u>if</u> last symbol = if
              <u>then</u> <u>begin</u> next symbol; Boolexp;
               next symbol; Simplexp (type);
               <u>if</u> last symbol = else
                 <u>then</u> <u>begin</u> next symbol; Type exp (type) <u>end</u>
            <u>end</u>
            <u>else</u> Simplexp (type)
         <u>end</u>  Exp;


         <u>procedure</u>  Type exp (type); <u>integer</u> type;
         <u>begin</u>   <u>if</u> type = ar ∨ type = re ∨ type = in
              <u>then</u> Arithexp
              <u>else</u> <u>if</u> type = bo
              <u>then</u> Boolexp
              <u>else</u> <u>if</u> type = st
              <u>then</u> Stringexp
              <u>else</u> <u>if</u> type = des
              <u>then</u> Desigexp
            <u>else</u> Exp (type)
         <u>end</u>  Type exp;






         <u>procedure</u>  Simplexp (type); <u>integer</u> type;
         <u>begin</u>   <u>integer</u> n;
            type ≔ un;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; Exp ( type);
               <u>if</u> last symbol = close <u>then</u> next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier; Subscripted variable (n);
               Function designator (n);
               <u>if</u> arithoperator last symbol ∨
                 relatoperator last symbol
                 <u>then</u> Arithmetic (n)
                 <u>else</u> <u>if</u> booloperator last symbol
                 <u>then</u> Boolean (n)
               <u>else</u> <u>begin</u> <u>if</u> nonformal label (n)
                    <u>then</u> Designational (n);
                  type ≔ type bits (n)
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> in name list
                 <u>then</u> Designational (integer label)
               <u>else</u> type ≔ ar
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = plus ∨ last symbol = minus
              <u>then</u> <u>begin</u> Simple arithexp; type ≔ ar <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = non ∨ last symbol = true ∨ last symbol = false
              <u>then</u> <u>begin</u> Simple boolean; type ≔ bo <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = quote
              <u>then</u> <u>begin</u> Simple stringexp; type ≔ st; <u>goto</u> end <u>end</u>;
            Rest of exp (type);
            end:
         <u>end</u>  Simplexp;


         <u>procedure</u> Rest of exp (type); <u>integer</u> type;
         <u>begin</u>   <u>if</u> arithoperator last symbol
              <u>then</u> <u>begin</u> next symbol; Simple arithexp;
               type ≔ ar
            <u>end</u>;
            <u>if</u> relatoperator last symbol
              <u>then</u> <u>begin</u> next symbol; Simple arithexp;
               type ≔ bo
            <u>end</u>;
            <u>if</u> booloperator last symbol
              <u>then</u> <u>begin</u> next symbol; Simple boolean;
               type ≔ bo
            <u>end</u>
         <u>end</u>  Rest of exp;






         <u>procedure</u>  Assignstat (n); <u>integer</u> n;
         <u>begin</u>   Subscripted variable (n);
            <u>if</u>  last symbol = colonequal <u>then</u>  Right hand side (n)
         <u>end</u>  Assignstat;


         <u>procedure</u>  Right hand side (n); <u>integer</u> n;
         <u>begin</u>   <u>integer</u>  m, type, type n;
            Assigned to (n); type n ≔ type bits (n);
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u>  last symbol = colonequal
                 <u>then</u>
               <u>begin</u> Insert (type n, m);
                  Right hand side (m); type ≔ type bits (m)
               <u>end</u>
               <u>else</u>
               <u>begin</u> Function designator (m);
                  <u>if</u> arithoperator last symbol ∨
                    relatoperator last symbol
                    <u>then</u> Arithmetic (m)
                    <u>else</u> <u>if</u> booloperator last symbol
                    <u>then</u> Boolean (m)
                  <u>else</u>
                  <u>begin</u> Arbost (m);
                     type ≔ <u>if</u> type n = re ∨ type n = in
                       <u>then</u> ar
                     <u>else</u> type n;
                     Insert (type, m);
                     type ≔ type bits (m);
                     <u>if</u> type = re ∨ type = in
                       <u>then</u> type ≔ ar
                  <u>end</u>;
                  Rest of exp (type)
               <u>end</u>
            <u>end</u>
            <u>else</u> <u>begin</u> m ≔ type n; Type exp (type n);
               <u>if</u> m ≠ nondes <u>then</u> type n ≔ m;
               type ≔ <u>if</u> type n = re ∨ type n = in <u>then</u> ar
               <u>else</u> type n
            <u>end</u>;
            Insert (type, n)
         <u>end</u>  Right hand side;






         <u>procedure</u>  Insert (type, n); <u>integer</u>  type, n;
         <u>begin</u>   <u>if</u> type = re
              <u>then</u> Real (n)
              <u>else</u> <u>if</u> type = in
              <u>then</u> Integer (n)
              <u>else</u> <u>if</u> type = bo
              <u>then</u> Boolean (n)
              <u>else</u> <u>if</u> type = ar <u>then</u> Arithmetic (n)
         <u>end</u>  Insert;


         <u>procedure</u>  Function designator (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> last symbol = open <u>then</u> <u>begin</u> Function (n);
               dimension ≔ Parlist;
               List length (n)
            <u>end</u>
         <u>end</u>  Function designator;


         <u>integer</u> <u>procedure</u>  Parlist;
         <u>begin</u>   next symbol; Actual parameter;
            <u>if</u> last symbol = comma
              <u>then</u> Parlist ≔ Parlist + 1
            <u>else</u> <u>begin</u> <u>if</u> last symbol = close <u>then</u> next symbol;
               Parlist ≔ 1
            <u>end</u>
         <u>end</u>  Parlist;


         <u>procedure</u>  Actual parameter;
         <u>begin</u>   <u>integer</u>  type;
            Exp (type)
         <u>end</u>  Actual parameter;


         <u>procedure</u>  Procstat (n); <u>integer</u> n;
         <u>begin</u>   Proc (n);
            dimension ≔ <u>if</u> last symbol = open <u>then</u> Parlist <u>else</u> 0;
            List length (n)
         <u>end</u>  Procstat;






         <u>procedure</u>  Statement;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier;
               <u>if</u> last symbol = colon
                 <u>then</u> Labelled statement (n)
               <u>else</u> <u>begin</u> <u>if</u> last symbol = sub ∨
                    last symbol = colonequal
                    <u>then</u> Assignstat (n)
                  <u>else</u> Procstat (n)
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> last symbol = colon
                 <u>then</u>  Intlabelled statement
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = goto <u>then</u> Gotostat
              <u>else</u>
            <u>if</u> last symbol = begin
              <u>then</u> <u>begin</u> next symbol;
               <u>if</u> declarator last symbol <u>then</u> Block
               <u>else</u> Compound tail;
               next symbol
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = if <u>then</u> Ifclause (Statement)
              <u>else</u>
            <u>if</u> last symbol = for <u>then</u> Forstat
         <u>end</u>  Statement;


         <u>procedure</u>  Gotostat;
         <u>begin</u>   <u>integer</u> n;
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier;
               <u>if</u> ¬ local label (n)
                 <u>then</u> <u>begin</u> Designational (n);
                  Subscripted variable (n)
               <u>end</u>
            <u>end</u>
            <u>else</u> Desigexp
         <u>end</u> Gotostat;


         <u>procedure</u>  Compound tail;
         <u>begin</u>   Statement;
            <u>if</u> last symbol ≠ semicolon ∧ last symbol ≠ end
              <u>then</u> skip rest of statement (Statement);
            <u>if</u> last symbol = semicolon
              <u>then</u> <u>begin</u> next symbol; Compound tail <u>end</u>
         <u>end</u>  Compound tail;






         <u>procedure</u>  Ifclause (pr); <u>procedure</u>  pr;
         <u>begin</u>   next symbol; Boolexp;
            <u>if</u> last symbol = then <u>then</u> next symbol;
            pr;
            <u>if</u> last symbol = else <u>then</u> <u>begin</u> next symbol; pr <u>end</u>
         <u>end</u> Ifclause;


         <u>procedure</u>  Forstat;
         <u>begin</u>   <u>integer</u> n;
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u>  n ≔ Identifier; Arithmetic (n);
               Subscripted variable (n);
               <u>if</u> last symbol = colonequal
                 <u>then</u>
                 next0: next symbol; Arithexp;
               <u>if</u> last symbol = step
                 <u>then</u> <u>begin</u> next symbol; Arithexp;
                  <u>if</u> last symbol = until
                    <u>then</u> <u>begin</u> next symbol;
                     Arithexp
                  <u>end</u>
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = while
                 <u>then</u> <u>begin</u> next symbol; Boolexp <u>end</u>;
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next0;
               <u>if</u> last symbol = do    <u>then</u> next symbol;
               for count ≔ for count + 1;
               Statement;
               for count ≔ for count - 1
            <u>end</u>
         <u>end</u>  Forstat;


         <u>procedure</u>  Switch declaration;
         <u>begin</u>   <u>integer</u> n;
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier;
               <u>if</u> last symbol = colonequal
                 <u>then</u> <u>begin</u> dimension ≔ Switchlist;
                  Switch length (n)
               <u>end</u>
            <u>end</u>
         <u>end</u> Switch declaration;


         <u>integer</u> <u>procedure</u>  Switchlist;
         <u>begin</u>   next symbol; Desigexp;
            <u>if</u> last symbol = comma <u>then</u> Switchlist ≔ Switchlist + 1
            <u>else</u> Switchlist ≔ 1
         <u>end</u> Switchlist;






         <u>procedure</u>  Array declaration;
         <u>begin</u>   <u>integer</u>  i, n, count;
            next symbol; n ≔ Identifier; count ≔ 1;
            next0:  <u>if</u> last symbol = comma <u>then</u> <u>begin</u> next symbol;
               <u>if</u> letter last symbol
                 <u>then</u> skip identifier;
               count ≔ count + 1; <u>goto</u> next0
            <u>end</u>;
            <u>if</u> last symbol = sub   <u>then</u> <u>begin</u> in array declaration ≔ true;
               dimension ≔ Bound pair list;
               in array declaration ≔ false
            <u>end</u>
            <u>else</u> dimension ≔ 0;
            Check dimension (n);
            <u>if</u> own type <u>then</u> <u>for</u> i ≔ 1 <u>step</u> 1 <u>until</u> count <u>do</u>
               <u>begin</u> Address (n, instruct counter);
                  instruct counter ≔ instruct counter +
                    3 × dimension + 6;
                  n ≔ next identifier (n)
               <u>end</u>;
            <u>if</u> last symbol = comma <u>then</u> Array declaration
         <u>end</u>  Array declaration;


         <u>integer</u> <u>procedure</u>  Bound pair list;
         <u>begin</u>   next symbol; Arithexp;
            <u>if</u> last symbol = colon <u>then</u> <u>begin</u> next symbol; Arithexp <u>end</u>;
            <u>if</u> last symbol = comma
              <u>then</u> Bound pair list ≔ Bound pair list + 1
            <u>else</u> <u>begin</u> <u>if</u> last symbol = bus <u>then</u> next symbol;
               Bound pair list ≔ 1
            <u>end</u>
         <u>end</u> Bound pair list;






         <u>procedure</u>  Procedure declaration;
         <u>begin</u>   <u>integer</u>  n, m;
            next symbol; n ≔ Identifier; entrance block;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u>  in formal list ≔ true ;
               next0: next symbol; m ≔ Identifier;
               <u>if</u> space[nl base - m] = 95 × d19
                 <u>then</u> <u>begin</u> ERRORMESSAGE (201);
                  space[nl base - m] ≔ 127 × d19
               <u>end</u>;
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next0;
               <u>if</u> last symbol = close <u>then</u> next symbol;
               in formal list ≔ false
            <u>end</u>;
            <u>if</u> last symbol = semicolon <u>then</u> next symbol;
            skip value list; skip specification list;
            <u>if</u> in code (n)
              <u>then</u> Scan code (n)
            <u>else</u> <u>begin</u> <u>if</u> space[nl base - n] ÷ d19 = 19 ∧¬ use of counter stack
                 <u>then</u> space[nl base - block cell pointer - 2] ≔                  space[nl base - block cell pointer - 2] + 64;
               <u>if</u> last symbol = begin
                 <u>then</u> <u>begin</u> next symbol;
                  <u>if</u> declarator last symbol
                    <u>then</u> Declaration list;
                  Compound tail; next symbol
               <u>end</u>
               <u>else</u> Statement;
               Addressing of block identifiers (n)
            <u>end</u>
         <u>end</u> Procedure declaration;


         <u>procedure</u>  Block;
         <u>begin</u>   entrance block; Declaration list; Compound tail;
            Addressing of block identifiers (0)
         <u>end</u> Block;


         <u>procedure</u>  Declaration list;
         <u>begin</u>   <u>if</u> typedeclarator last symbol <u>then</u> skip type declaration
              <u>else</u>
            <u>if</u> arr declarator last symbol <u>then</u> Array declaration
              <u>else</u>
            <u>if</u> last symbol = switch       <u>then</u> Switch declaration
            <u>else</u> Procedure declaration;
            <u>if</u> last symbol = semicolon    <u>then</u> next symbol;
            <u>if</u> declarator last symbol     <u>then</u> Declaration list
         <u>end</u>  Declaration list;






         <u>procedure</u>  Program;
         <u>begin</u>   <u>integer</u>  n;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier;
               <u>if</u> last symbol = colon
                 <u>then</u> Label declaration (n);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> unsigned number;
               <u>if</u> in name list
                 <u>then</u> Label declaration (integer label);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = begin
              <u>then</u> <u>begin</u> next symbol;
               <u>if</u> declarator last symbol
                 <u>then</u> Block
               <u>else</u> Compound tail
            <u>end</u>
            <u>else</u> <u>begin</u> next symbol; Program <u>end</u>
         <u>end</u>  Program;


         <u>procedure</u>  Labelled statement (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> nonformal label (n) <u>then</u> Label declaration (n);
            Statement
         <u>end</u>  Labelled statement;


         <u>procedure</u>  Intlabelled statement;
         <u>begin</u>   <u>if</u> in name list <u>then</u> Label declaration (integer label);
            Statement
         <u>end</u>  Intlabelled statement;


         <u>procedure</u>  Label declaration (n); <u>integer</u> n;
         <u>begin</u>   <u>if</u> proc level = 0
              <u>then</u> <u>begin</u> Designational (n); Address (n, instruct counter);
               space[nl base - n - 1] ≔                  space[nl base - n - 1] + instruct counter +
                 d20 × for count;
               space[prog base + instruct counter] ≔ 0;
               space[prog base + instruct counter + 1] ≔                  d18 × display level + dp0;
               instruct counter ≔ instruct counter + 2
            <u>end</u>
            <u>else</u> space[nl base - n - 1] ≔ space[nl base - n - 1] +
              d20 × for count;
            next symbol
         <u>end</u>  Label declaration;






         <u>procedure</u>  Addressing of block identifiers (n); <u>integer</u> n;
         <u>begin</u>   <u>integer</u>  counter, f, code, code1;
            <u>if</u> n = 0 <u>then</u> space[nl base - block cell pointer - 1] ≔               space[nl base - block cell pointer - 1] + d13;
            <u>if</u> proc level &gt; 0
              <u>then</u>
            <u>begin</u> counter ≔ d9 × display level + d8;
               <u>if</u> n = 0
                 <u>then</u> counter ≔ counter + 1 + d18
               <u>else</u>
               <u>begin</u> counter ≔ counter + display level + top of display;
                  f ≔ block cell pointer + 5;
                  next0: f ≔ next identifier (f);
                  <u>if</u> f &gt; block cell pointer
                    <u>then</u>
                  <u>begin</u> Address (f, counter);
                     code1 ≔ space[nl base - f] ÷ d18;
                     code ≔ code1 ÷ 2;
                     counter ≔ counter +
                       (<u>if</u> code = 64 ∨ code = 67 ∨ code = 70
                       <u>then</u> 2
                     <u>else</u> <u>if</u> code &lt; 96
                       <u>then</u> 1
                     <u>else</u> <u>if</u> code1 = 2 × code
                       <u>then</u> 2 <u>else</u> 4);
                     <u>goto</u> next0
                  <u>end</u>;
                  counter ≔ counter + d18;
                  code ≔ space[nl base - n] ÷ d19;
                  <u>if</u> code ≠ 24
                    <u>then</u>
                  <u>begin</u> f ≔ <u>if</u> wanted <u>then</u> 3 <u>else</u>
                       <u>if</u> code = 16 ∨ code = 19 <u>then</u> 2 <u>else</u> 1;
                     Address (n + 2, counter);
                     counter ≔ counter + f;
                     space[nl base - block cell pointer - 1] ≔                        space[nl base - block cell pointer - 1] +
                       d13 × f
                  <u>end</u>
               <u>end</u>;




               f ≔ status;
               next1: <u>if</u> space[nl base - f] &gt; 0
                 <u>then</u> <u>begin</u> Address (f, counter); counter ≔ counter + 1;
                  f ≔ f + 1;
                  <u>goto</u> next1
               <u>end</u>;
               f ≔ block cell pointer + 4;
               next2: f ≔ next identifier (f); code ≔ space[nl base - f] ÷ d19;
               <u>if</u> f &gt; block cell pointer ∧ f &lt; status ∧ code &lt; 64
                 <u>then</u> <u>begin</u> <u>if</u> code &gt; 24
                    <u>then</u>
                  <u>begin</u> <u>if</u> code &lt; 36
                       <u>then</u>
                     <u>begin</u> Address (f, instruct counter);
                        instruct counter ≔                           instruct counter +
                          (<u>if</u> code= 32 ∨ code = 35
                          <u>then</u> 2 <u>else</u> 1)
                     <u>end</u>
                  <u>end</u>
                    <u>else</u>
                  <u>if</u> code &lt; 14
                    <u>then</u>
                  <u>begin</u> <u>if</u> code ≠ 6 ∨
                       (code = 6 ∧
                       bit string (d19, d18,
                       space[nl base - f - 1]) = 0)
                       <u>then</u>
                     <u>begin</u> Address (f, counter);
                        counter ≔                           counter +
                          (<u>if</u> code = 0 ∨ code = 3 ∨ code = 6
                          <u>then</u> 2 <u>else</u> 1)
                     <u>end</u>
                  <u>end</u>;
                  <u>goto</u> next2
               <u>end</u>;
               <u>if</u> counter &gt; d18 + d9 × (display level + 1)
                 <u>then</u> ERRORMESSAGE (202);
               exit block
            <u>end</u>
            <u>else</u> Static addressing
         <u>end</u>  Addressing of block identifiers;






         <u>procedure</u>  Static addressing;
         <u>begin</u>   <u>integer</u>  f, code;
            f ≔ status;
            next0:  <u>if</u> space[nl base - f] &gt; 0
              <u>then</u> <u>begin</u> Address (f, instruct counter);
               instruct counter ≔ instruct counter + 1; f ≔ f + 1;
               <u>goto</u> next0
            <u>end</u>;
            f ≔ block cell pointer + 4;
            next1:  f ≔ next identifier (f); code ≔ space[nl base - f] ÷ d19;
            <u>if</u> f &gt; block cell pointer ∧ f &lt; status
              <u>then</u> <u>begin</u> <u>if</u> code &gt; 24 ∧ code &lt; 36 ∨ code &lt; 14 ∧ code ≠ 6
                 <u>then</u> <u>begin</u> Address (f, instruct counter);
                  instruct counter ≔                     instruct counter +
                    (<u>if</u> code = 0 ∨ code = 3 ∨
                    code = 32 ∨ code = 35 <u>then</u> 2
                  <u>else</u> 1)
               <u>end</u>;
               <u>goto</u> next1
            <u>end</u>;
            exit block
         <u>end</u> Static addressing;






         <u>procedure</u>  Add type (n, t); <u>integer</u>  n, t;
         <u>begin</u>   <u>integer</u> code, new code, type;
            new code ≔ code ≔ space[nl base - n] ÷ d19;
            <u>if</u> code &gt; 95
              <u>then</u> <u>begin</u> <u>if</u> code = 127
                 <u>then</u> new code ≔ 96 + t
                 <u>else</u> <u>if</u> code = 120 ∧ t &lt; 6
                 <u>then</u> new code ≔ 112 + t
               <u>else</u>
               <u>begin</u> type ≔ code - code ÷ 8 × 8;
                  <u>if</u> type = un ∨ (type = nondes ∧ t &lt; 5) ∨
                    (type = ar ∧ t &lt; 2)
                    <u>then</u> new code ≔ code - type + t
               <u>end</u>;
               space[nl base - n] ≔                  space[nl base - n] - (code - new code) × d19
            <u>end</u>
         <u>end</u>  Add type;


         <u>procedure</u>  Real (n); <u>integer</u> n; <u>begin</u> Add type (n, re) <u>end</u> Real;


         <u>procedure</u>  Integer (n); <u>integer</u> n; <u>begin</u> Add type (n, in) <u>end</u> Integer;


         <u>procedure</u>  Boolean (n); <u>integer</u> n; <u>begin</u> Add type (n, bo) <u>end</u> Boolean;


         <u>procedure</u>  String (n); <u>integer</u> n; <u>begin</u> Add type (n, st) <u>end</u> String;


         <u>procedure</u>  Arithmetic (n); <u>integer</u>  n;
         <u>begin</u>  Add type (n, ar) <u>end</u>  Arithmetic;


         <u>procedure</u>  Arbost (n); <u>integer</u> n;
         <u>begin</u>   Add type (n, nondes) <u>end</u>  Arbost;






         <u>procedure</u>  Designational (n); <u>integer</u> n;
         <u>begin</u>   <u>integer</u>  p;
            <u>if</u> nonformal label (n)
              <u>then</u>
            <u>begin</u> <u>if</u> bit string (d19, d18, space[nl base - n - 1]) = 1
                 <u>then</u>
               <u>begin</u> space[nl base - n - 1] ≔                     abs (space[nl base - n - 1] - d18);
                  p ≔ corresponding block cell pointer (n);
                  <u>if</u> bit string (d6, d0, space[nl base - p - 2]) &gt; 0
                    <u>then</u> <u>begin</u> space[nl base - p - 3] ≔                        space[nl base - p - 3] + 1;
                     space[nl base - p - 1] ≔                        space[nl base - p - 1] + d14
                  <u>end</u>
               <u>end</u>
            <u>end</u>
            <u>else</u> Add type (n, des)
         <u>end</u>  Designational;


         <u>procedure</u>  Assigned to (n); <u>integer</u> n;
         <u>begin</u>   <u>integer</u>  code;
            code ≔ space[nl base - n] ÷ d19;
            <u>if</u> code &gt; 95
              <u>then</u>
            <u>begin</u> <u>if</u> code = 127 <u>then</u> code ≔ 101;
               <u>if</u> code &lt; 102 <u>then</u> space[nl base - n] ≔ code × d19 + d18
               <u>else</u> Add type (n, nondes)
            <u>end</u>
         <u>end</u> Assigned to;


         <u>procedure</u>  Subscrvar (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> code, new code;
            code ≔ space[nl base - n] ÷ d19;
            <u>if</u> code &gt; 95
              <u>then</u> <u>begin</u> new code ≔ <u>if</u> code = 127
                 <u>then</u> 111
               <u>else</u> <u>if</u> code &lt; 104
                 <u>then</u> code + 8
               <u>else</u> code;
               space[nl base - n] ≔ space[nl base - n] +
                 (new code - code) × d19
            <u>end</u>
         <u>end</u>  Subscrvar;






         <u>procedure</u>  Proc (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  code, new code;
            code ≔ space[nl base - n] ÷ d19;
            <u>if</u> code &gt; 95
              <u>then</u> <u>begin</u> new code ≔ <u>if</u> code = 127
                 <u>then</u> 120
               <u>else</u> <u>if</u> code &lt; 102
                 <u>then</u> code + 16
               <u>else</u> code;
               space[nl base - n] ≔ space[nl base - n] +
                 (new code- code) × d19
            <u>end</u>
         <u>end</u>  Proc;


         <u>procedure</u>  Function (n); <u>integer</u>  n;
         <u>begin</u>   Arbost (n); Proc (n) <u>end</u> Function;


         <u>procedure</u>  List length (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  word;
            <u>if</u> space[nl base - n] ÷ d19 &gt; 95
              <u>then</u> <u>begin</u> word ≔ space[nl base - n - 1 ];
               <u>if</u> bit string (d18, d0, word) = 0
                 <u>then</u> space[nl base - n - 1] ≔ word + dimension + 1
            <u>end</u>
         <u>end</u>  List length;


         <u>procedure</u>  Switch length (n);  <u>integer</u>  n;
         <u>begin</u>   space[nl base - n - 1] ≔ dimension + 1 <u>end</u>  Switch length;


         <u>procedure</u>  Address (n, m); <u>integer</u>  n, m;
         <u>begin</u>   <u>integer</u>  word;
            word ≔ space[nl base - n] ÷ d18;
            space[nl base - n] ≔ word × d18 + m
         <u>end</u>  Address;


         <u>procedure</u>  Check dimension (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> space[nl base - n - 1] ≠ dimension + 1
              <u>then</u> <u>begin</u> ERRORMESSAGE (203);
               space[nl base - n - 1] ≔ dimension + 1
            <u>end</u>
         <u>end</u>  Check dimension;






         <u>integer</u> <u>procedure</u>  Identifier;
         <u>begin</u>   <u>integer</u>  n;
            last nlp ≔ nlp; read identifier; Identifier ≔ n ≔ look up;
            <u>if</u> n &gt; nlp <u>then</u> Ask librarian;
            <u>if</u> n &gt; nlp <u>then</u> <u>begin</u> ERRORMESSAGE (204);
               nlp ≔ nlp + word count + 3;
               space[nl base - nlp + 1] ≔ 0
            <u>end</u>
         <u>end</u>  Identifier;


         <u>procedure</u>  Scan code (n); <u>integer</u>  n;
         <u>begin</u>   block cell pointer ≔ space[nl base - block cell pointer] ÷ d13;
            next0:  next symbol; <u>if</u>  last symbol = minus <u>then</u> next symbol;
            <u>if</u> letter last symbol <u>then</u> Identifier <u>else</u> unsigned integer (0);
            <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next0;
            <u>if</u> last symbol = unquote <u>then</u> next symbol
         <u>end</u>  Scan code;


         <u>procedure</u>  Ask librarian;
         <u>begin</u>   <u>comment</u> if the current identifier occurs in the library
              then this procedure will add a new namecell to
              the name list and increase nlp;
         <u>end</u>  Ask librarian;






         main program of prescan 1:
         <u>if</u> ¬ text in memory
           <u>then</u> <u>begin</u> NEWPAGE;
            PRINTTEXT (“input tape for prescan1”)
         <u>end</u>;
         runnumber ≔ 200; init;
         block cell pointer ≔ next block cell pointer ≔ 0;
         dp0 ≔ instruct counter;
         instruct counter ≔ instruct counter + top of display;
         space[nl base - nlp] ≔ -1;
         next symbol; entrance block;
         Program; Static addressing;
         output
      <u>end</u> prescan1;












      <u>procedure</u> translate;
      <u>begin</u>

         <u>integer</u> last lnc, lnc, last lncr, macro, parameter, state,
           stack0, stack1, b, ret level, max depth,
           ret max depth, max depth isr, max display length,
           max proc level, ecount, controlled variable, increment,
           l0, l1, l2, l3, l4, l5, number of switch elements,
           switch identifier, switch list count, sword,
           address of constant, sum of maxima;

         <u>Boolean</u> in switch declaration, in code body, if statement forbidden,
           complicated, complex step element;


         <u>procedure</u>  Arithexp;
         <u>begin</u>   <u>integer</u>  future1, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  future1 ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 (COJU, future1);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (300)
               <u>else</u> next symbol;
               Simple arithexp;
               <u>if</u> last symbol = else
                 <u>then</u> <u>begin</u>  Macro2 (JU, future2);
                  Substitute (future1);
                  next symbol; Arithexp;
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (301)
            <u>end</u>
            <u>else</u> Simple arithexp
         <u>end</u>  Arithexp;


         <u>procedure</u>  Simple arithexp;
         <u>begin</u>   <u>if</u> last symbol = minus <u>then</u> <u>begin</u>  next symbol; Term;
               Macro (NEG)
            <u>end</u>
            <u>else</u> <u>begin</u> <u>if</u> last symbol = plus
                 <u>then</u> next symbol;
               Term
            <u>end</u>;
            Next term
         <u>end</u>  Simple arithexp;






         <u>procedure</u>  Next term;
         <u>begin</u>   <u>if</u> last symbol = plus  <u>then</u> <u>begin</u>  Macro (STACK);
               next symbol; Term;
               Macro (ADD); Next term
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = minus <u>then</u> <u>begin</u> Macro (STACK);
               next symbol; Term;
               Macro (SUB); Next term
            <u>end</u>
         <u>end</u>  Next term;


         <u>procedure</u>  Term;  <u>begin</u>  Factor; Next factor <u>end</u>  Term;


         <u>procedure</u>  Next factor;
         <u>begin</u>   <u>if</u> last symbol = mul <u>then</u> <u>begin</u>  Macro (STACK);
               next symbol; Factor;
               Macro (MUL); Next factor
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = div <u>then</u> <u>begin</u>  Macro (STACK);
               next symbol; Factor;
               Macro (DIV); Next factor
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = idi <u>then</u> <u>begin</u>  Macro (STACK);
               next symbol; Factor;
               Macro (IDI); Next factor
            <u>end</u>
         <u>end</u>  Next factor;


         <u>procedure</u>  Factor;  <u>begin</u>  Primary; Next primary <u>end</u>  Factor;


         <u>procedure</u>  Next primary;
         <u>begin</u>   <u>if</u> last symbol = ttp <u>then</u> <u>begin</u>  Macro (STACK);
               next symbol; Primary;
               Macro (TTP); Next primary
            <u>end</u>
         <u>end</u>  Next primary;






         <u>procedure</u>  Primary;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = open <u>then</u> <u>begin</u>  next symbol; Arithexp;
               <u>if</u> last symbol = close
                 <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (302)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol  <u>then</u> <u>begin</u>  Unsigned number;
               Arithconstant
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol <u>then</u> <u>begin</u>  n ≔ Identifier;
               Subscripted variable (n);
               Function designator (n);
               Arithname (n)
            <u>end</u>
            <u>else</u>
            <u>begin</u>  ERRORMESSAGE (303);
               <u>if</u> last symbol = if ∨ last symbol = plus ∨
                 last symbol = minus
                 <u>then</u> Arithexp
            <u>end</u>
         <u>end</u>  Primary;


         <u>procedure</u>  Arithname (n); <u>integer</u> n;
         <u>begin</u>   <u>if</u> Nonarithmetic (n) <u>then</u>  ERRORMESSAGE (304);
            complicated ≔ Formal (n) ∨ Function (n);
            <u>if</u> Simple (n)
              <u>then</u> <u>begin</u> <u>if</u> Formal (n)  <u>then</u> Macro2 (DOS, n) <u>else</u>
               <u>if</u> Integer (n) <u>then</u> Macro2 (TIV, n)
               <u>else</u> Macro2 (TRV, n)
            <u>end</u>
         <u>end</u>  Arithname;


         <u>procedure</u>  Subscripted variable (n); <u>integer</u> n;
         <u>begin</u>   <u>if</u> Subscrvar (n) <u>then</u> <u>begin</u>  Address description (n);
               <u>if</u> last symbol = colonequal
                 <u>then</u> <u>begin</u> Macro (STACK);
                  Macro (STAA)
               <u>end</u>
               <u>else</u> Evaluation of (n)
            <u>end</u>
         <u>end</u>  Subscripted variable;






         <u>procedure</u>  Address description (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> last symbol = sub
              <u>then</u> <u>begin</u>  next symbol; dimension ≔ Subscript list;
               Check dimension (n);
               <u>if</u> Formal (n)        <u>then</u> Macro2 (DOS, n) <u>else</u>
               <u>if</u> Designational (n) <u>then</u> Macro2 (TSWE, n)
               <u>else</u> Macro2 (TAK, n)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (305)
         <u>end</u>  Address description;


         <u>procedure</u>  Evaluation of (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u>  Designational(n)
              <u>then</u> <u>begin</u>  <u>if</u> Formal (n) <u>then</u>  Macro (TFSL)
               <u>else</u>  Macro (TSL)
            <u>end</u>
              <u>else</u>
            <u>if</u> Boolean (n) <u>then</u> Macro (TSB)  <u>else</u>
            <u>if</u> String (n)  <u>then</u> Macro (TSST) <u>else</u>
            <u>if</u> Formal (n)  <u>then</u> Macro (TFSU) <u>else</u>
            <u>if</u> Integer (n) <u>then</u> Macro (TSI)  <u>else</u> Macro (TSR)
         <u>end</u>  Evaluation of;


         <u>integer</u> <u>procedure</u>  Subscript list;
         <u>begin</u>   Arithexp;
            <u>if</u> last symbol = comma
              <u>then</u> <u>begin</u>  Macro (STACK); next symbol;
               Subscript list ≔ Subscript list + 1
            <u>end</u>
            <u>else</u> <u>begin</u>  <u>if</u> last symbol = bus
                 <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (306);
               Subscript list ≔ 1
            <u>end</u>
         <u>end</u>  Subscript list;






         <u>procedure</u>  Boolexp;
         <u>begin</u>   <u>integer</u> future1, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  future1 ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 (COJU, future1);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (307)
               <u>else</u> next symbol;
               Simple boolean;
               <u>if</u> last symbol = else
                 <u>then</u> <u>begin</u> Macro2 (JU, future2);
                  Substitute (future1);
                  next symbol; Boolexp;
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (308)
            <u>end</u>
            <u>else</u> Simple boolean
         <u>end</u>  Boolexp;


         <u>procedure</u>  Simple boolean;
         <u>begin</u>   Implication; Next implication <u>end</u>  Simple boolean;


         <u>procedure</u>  Next implication;
         <u>begin</u>   <u>if</u> last symbol = qvl <u>then</u> <u>begin</u> Macro (STAB);
               next symbol; Implication;
               Macro (QVL); Next implication
            <u>end</u>
         <u>end</u>  Next implication;


         <u>procedure</u>  Implication;  <u>begin</u>  Boolterm; Next boolterm <u>end</u>  Implication;


         <u>procedure</u>  Next boolterm;
         <u>begin</u>   <u>if</u> last symbol = imp <u>then</u> <u>begin</u>  Macro (STAB);
               next symbol; Boolterm;
               Macro (IMP); Next boolterm
            <u>end</u>
         <u>end</u>  Next boolterm;


         <u>procedure</u>  Boolterm;  <u>begin</u>  Boolfac; Next boolfac <u>end</u>  Boolterm;


         <u>procedure</u>  Next boolfac;
         <u>begin</u>   <u>if</u> last symbol = or  <u>then</u> <u>begin</u>  Macro (STAB);
               next symbol; Boolfac;
               Macro (OR); Next boolfac
            <u>end</u>
         <u>end</u>  Next boolfac;


         <u>procedure</u>  Boolfac;  <u>begin</u>  Boolsec; Next boolsec <u>end</u>  Boolfac;






         <u>procedure</u>  Next boolsec;
         <u>begin</u>   <u>if</u> last symbol = and <u>then</u> <u>begin</u>  Macro (STAB);
               next symbol; Boolsec;
               Macro (AND); Next boolsec
            <u>end</u>
         <u>end</u>  Next boolsec;


         <u>procedure</u>  Boolsec;
         <u>begin</u>   <u>if</u> last symbol = non <u>then</u> <u>begin</u>  next symbol; Boolprim;
               Macro (NON)
            <u>end</u>
            <u>else</u> Boolprim
         <u>end</u>  Boolsec;


         <u>procedure</u>  Boolprim;
         <u>begin</u>   <u>integer</u> type, n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; Arboolexp (type);
               <u>if</u> last symbol = close <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (309);
               <u>if</u> type = ar   <u>then</u> Rest of relation <u>else</u>
               <u>if</u> type = arbo <u>then</u> <u>begin</u> <u>if</u> arithoperator last symbol
                    <u>then</u> Rest of relation
                  <u>else</u> Relation
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol <u>then</u> <u>begin</u> n ≔ Identifier;
               Subscripted variable (n);
               Boolprimrest (n)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol ∨ last symbol = plus ∨ last symbol = minus
              <u>then</u> <u>begin</u> Simple arithexp; Rest of relation <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = true ∨ last symbol = false
              <u>then</u> <u>begin</u> Macro2 (TBC, last symbol); next symbol <u>end</u>
            <u>else</u> ERRORMESSAGE (310)
         <u>end</u>  Boolprim;






         <u>Boolean</u> <u>procedure</u>  Relation;
         <u>begin</u>   <u>integer</u> relmacro;
            <u>if</u> relatoperator last symbol
              <u>then</u> <u>begin</u> relmacro ≔ Relatmacro; Macro (STACK);
               next symbol; Simple arithexp;
               Macro (relmacro); Relation ≔ true
            <u>end</u>
            <u>else</u> Relation ≔ false
         <u>end</u>  Relation;


         <u>procedure</u>  Rest of relation;
         <u>begin</u>   Rest of arithexp;
            <u>if</u> ¬ Relation <u>then</u>  ERRORMESSAGE (311)
         <u>end</u>  Rest of relation;


         <u>procedure</u>  Boolprimrest (n); <u>integer</u>  n;
         <u>begin</u>   Function designator (n);
            <u>if</u> Arithmetic (n) ∨ arithoperator last symbol∨ relatoperator last symbol
              <u>then</u> <u>begin</u>  Arithname (n); Rest of relation <u>end</u>
            <u>else</u> Boolname (n)
         <u>end</u>  Boolprimrest;


         <u>procedure</u>  Boolname (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Nonboolean (n) <u>then</u> ERRORMESSAGE (312);
            <u>if</u> Simple (n)     <u>then</u> <u>begin</u> <u>if</u> Formal (n) <u>then</u> Macro2 (DOS, n)
               <u>else</u> Macro2 (TBV, n)
            <u>end</u>
         <u>end</u>  Boolname;


         <u>procedure</u>  Arboolexp (type); <u>integer</u>  type;
         <u>begin</u>   <u>integer</u> future1, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  future1 ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 (COJU, future1);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (313)
               <u>else</u> next symbol;
               Simple arboolexp (type);
               <u>if</u> last symbol = else
                 <u>then</u>
               <u>begin</u>  Macro2 (JU, future2); Substitute (future1);
                  next symbol;
                  <u>if</u> type = bo <u>then</u> Boolexp <u>else</u>
                  <u>if</u> type = ar <u>then</u> Arithexp
                  <u>else</u> Arboolexp (type);
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (314)
            <u>end</u>
            <u>else</u> Simple arboolexp (type)
         <u>end</u> Arboolexp;






         <u>procedure</u>  Simple arboolexp (type); <u>integer</u>  type;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u>  next symbol; Arboolexp (type);
               <u>if</u> last symbol = close <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (315);
               <u>if</u> type = bo ∨
                 type = arbo ∧ booloperator last symbol
                 <u>then</u> <u>begin</u> Rest of boolexp; type ≔ bo <u>end</u>
                 <u>else</u> <u>if</u> type = ar ∨
                 arithoperator last symbol ∨
                 relatoperator last symbol
                 <u>then</u> Rest of arboolexp (type)
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u>  n ≔ Identifier; Subscripted variable (n);
               Arboolrest (type, n)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol ∨ last symbol = plus ∨ last symbol = minus
              <u>then</u> <u>begin</u> Simple arithexp; Rest of arboolexp (type) <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = non ∨ last symbol = true ∨ last symbol = false
              <u>then</u> <u>begin</u> Simple boolean; type ≔ bo <u>end</u>
            <u>else</u>
            <u>begin</u> ERRORMESSAGE (316); type ≔ arbo <u>end</u>
         <u>end</u>  Simple arboolexp;


         <u>procedure</u>  Rest of arithexp;
         <u>begin</u>   Next primary; Next factor; Next term <u>end</u> Rest of arithexp;


         <u>procedure</u>  Rest of boolexp;
         <u>begin</u>   Next boolsec; Next boolfac; Next boolterm; Next implication
         <u>end</u> Rest of boolexp;


         <u>procedure</u>  Rest of arboolexp (type); <u>integer</u>  type;
         <u>begin</u>   Rest of arithexp;
            <u>if</u> Relation
              <u>then</u> <u>begin</u>  Rest of boolexp; type ≔ bo <u>end</u> <u>else</u> type ≔ ar
         <u>end</u>  Rest of arboolexp;






         <u>procedure</u>  Arboolrest (type, n); <u>integer</u>  type, n;
         <u>begin</u>   Function designator (n);
            <u>if</u> Boolean (n) ∨ booloperator last symbol
              <u>then</u> <u>begin</u>  Boolname (n); Rest of boolexp; type ≔ bo <u>end</u>
              <u>else</u>
            <u>if</u>  Arithmetic (n) ∨ arithoperator last symbol ∨
              relatoperator last symbol
              <u>then</u> <u>begin</u>  Arithname (n); Rest of arboolexp (type) <u>end</u>
            <u>else</u> <u>begin</u>  <u>if</u> String (n) ∨ Designational (n)
                 <u>then</u> ERRORMESSAGE (317);
               Macro2 (DOS, n); type ≔ arbo
            <u>end</u>
         <u>end</u>  Arboolrest;


         <u>procedure</u>  Stringexp;
         <u>begin</u>   <u>integer</u>  futurel, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  futurel ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 ( COJU, futurel);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (318)
               <u>else</u> next symbol;
               Simple stringexp;
               <u>if</u> last symbol = else
                 <u>then</u> <u>begin</u>  Macro2 (JU, future2);
                  Substitute (futurel);
                  next symbol; Stringexp;
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (319)
            <u>end</u>
            <u>else</u> Simple stringexp
         <u>end</u>  Stringexp;


         <u>procedure</u>  Simple stringexp;
         <u>begin</u>   <u>integer</u>  future, n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u>  next symbol; Stringexp;
               <u>if</u> last symbol = close <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (320)
            <u>end</u>
              <u>else</u>
            <u>if</u>  letter last symbol
              <u>then</u> <u>begin</u>  n ≔ Identifier; Subscripted variable (n);
               Stringname (n)
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = quote
              <u>then</u> <u>begin</u>  Macro (TCST); future ≔ 0; Macro2 (JU, future);
               Constant string; Substitute (future)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (321)
         <u>end</u>  Simple stringexp;






         <u>procedure</u>  Stringname (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Nonstring (n) <u>then</u> ERRORMESSAGE (322);
            Function designator (n);
            <u>if</u> Simple (n) <u>then</u> <u>begin</u>  <u>if</u> Formal (n) <u>then</u> Macro2 (DOS, n)
               <u>else</u> Macro2 (TSTV, n)
            <u>end</u>
         <u>end</u>  Stringname;


         <u>procedure</u>  Desigexp;
         <u>begin</u>   <u>integer</u>  futurel, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  futurel ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 (COJU, futurel);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (323)
               <u>else</u> next symbol;
               Simple desigexp;
               <u>if</u> last symbol = else
                 <u>then</u> <u>begin</u> Macro2 (JU, future2);
                  Substitute (futurel);
                  next symbol; Desigexp;
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (324)
            <u>end</u>
            <u>else</u> Simple desigexp
         <u>end</u>  Desigexp;


         <u>procedure</u>  Simple desigexp;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u>  last symbol = open
              <u>then</u> <u>begin</u>  next symbol; Desigexp;
               <u>if</u> last symbol = close <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (325)
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol <u>then</u> <u>begin</u> n ≔ Identifier;
               Subscripted variable (n);
               Designame (n)
            <u>end</u>
              <u>else</u>
            <u>if</u>  digit last symbol <u>then</u> <u>begin</u> Unsigned number;
               <u>if</u> in name list
                 <u>then</u> Macro2 (TLV, integer label)
               <u>else</u> ERRORMESSAGE (326)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (327)
         <u>end</u>  Simple desigexp;






         <u>procedure</u>  Designame (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Nondesignational (n) <u>then</u> ERRORMESSAGE (328);
            <u>if</u> Simple (n)
              <u>then</u> <u>begin</u>  <u>if</u> Formal (n) <u>then</u> Macro2 (DOS, n)
               <u>else</u> Macro2 (TLV, n)
            <u>end</u>
         <u>end</u>  Designame;


         <u>procedure</u>  Ardesexp (type); <u>integer</u>  type;
         <u>begin</u>   Exp (type);
            <u>if</u> type = bo ∨ type = st <u>then</u> ERRORMESSAGE (329);
            <u>if</u> type = un             <u>then</u> type ≔ intlab <u>else</u>
            <u>if</u> type = nondes         <u>then</u> type ≔ ar
         <u>end</u>  Ardesexp;


         <u>procedure</u>  Nondesexp (type); <u>integer</u>  type;
         <u>begin</u>   Exp (type);
            <u>if</u> type = des    <u>then</u> ERRORMESSAGE (330);
            <u>if</u> type = un     <u>then</u> type ≔ nondes <u>else</u>
            <u>if</u> type = intlab <u>then</u> type ≔ ar
         <u>end</u>  Nondesexp;


         <u>procedure</u>  Exp (type); <u>integer</u>  type;
         <u>begin</u>   <u>integer</u>  future1, future2;
            <u>if</u> last symbol = if
              <u>then</u> <u>begin</u>  future1 ≔ future2 ≔ 0;
               next symbol; Boolexp; Macro2 (COJU, future1);
               <u>if</u> last symbol ≠ then <u>then</u> ERRORMESSAGE (331)
               <u>else</u> next symbol;
               Simplexp (type);
               <u>if</u> last symbol = else
                 <u>then</u>
               <u>begin</u>  Macro2 (JU, future2);
                  Substitute (future1); next symbol;
                  <u>if</u> type = ar     <u>then</u> Arithexp        <u>else</u>
                  <u>if</u> type = bo     <u>then</u> Boolexp         <u>else</u>
                  <u>if</u> type = st     <u>then</u> Stringexp       <u>else</u>
                  <u>if</u> type = des    <u>then</u> Desigexp        <u>else</u>
                  <u>if</u> type = intlab <u>then</u> Ardesexp (type) <u>else</u>
                  <u>if</u> type = nondes <u>then</u> Nondesexp (type)
                  <u>else</u> Exp (type);
                  Substitute (future2)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (332)
            <u>end</u>
            <u>else</u>  Simplexp (type)
         <u>end</u> Exp;






         <u>procedure</u>  Simplexp (type); <u>integer</u>  type;
         <u>begin</u>   <u>integer</u> n;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u>  next symbol; Exp (type);
               <u>if</u> last symbol = close <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (333);
               <u>if</u> type = bo ∨ (type = nondes ∨ type = un) ∧
                 booloperator last symbol
                 <u>then</u> <u>begin</u> Rest of boolexp; type ≔ bo <u>end</u>
                 <u>else</u>
               <u>if</u> type ≠ st ∧ type ≠ des ∧ operator last symbol
                 <u>then</u>  Rest of arboolexp (type)
            <u>end</u>
              <u>else</u>
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u>  n ≔ Identifier; Subscripted variable (n);
               Exprest (type, n)
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u>  Unsigned number; Arithconstant;
               <u>if</u> in name list ∧ ( ¬ operator last symbol)
                 <u>then</u> <u>begin</u>  Macro2 (TLV, integer label);
                  type ≔ intlab
               <u>end</u>
               <u>else</u> Rest of arboolexp (type)
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = plus ∨ last symbol = minus
              <u>then</u> Simple arboolexp (type)
              <u>else</u>
            <u>if</u> last symbol = non ∨ last symbol = true ∨ last symbol = false
              <u>then</u> <u>begin</u> Simple boolean; type ≔ bo <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = quote <u>then</u> <u>begin</u> Simple stringexp; type ≔ st <u>end</u>
            <u>else</u>
            <u>begin</u>  ERRORMESSAGE (334); type ≔ un <u>end</u>
         <u>end</u>  Simplexp;






         <u>procedure</u>  Exprest (type, n); <u>integer</u> type, n;
         <u>begin</u>   <u>if</u> Designational (n) <u>then</u> <u>begin</u> Designame (n); type ≔ des <u>end</u>
              <u>else</u>
            <u>if</u> String (n)        <u>then</u> <u>begin</u> Stringname (n); type ≔ st <u>end</u>
            <u>else</u>
            <u>begin</u>  Function designator (n);
               <u>if</u> Boolean (n) ∨ booloperator last symbol
                 <u>then</u> <u>begin</u> Boolname (n); Rest of boolexp; type ≔ bo <u>end</u>
                 <u>else</u>
               <u>if</u> Arithmetic (n) ∨ arithoperator last symbol ∨
                 relatoperator last symbol
                 <u>then</u> <u>begin</u> Arithname (n); Rest of arboolexp (type) <u>end</u>
               <u>else</u> <u>begin</u> <u>if</u> Simple (n) <u>then</u>  Macro2 (DOS, n);
                  type ≔ <u>if</u> Unknown (n) <u>then</u> un <u>else</u> nondes
               <u>end</u>
            <u>end</u>
         <u>end</u>  Exprest;


         <u>procedure</u>  Assignstat (n); <u>integer</u>  n;
         <u>begin</u>   Subscripted variable (n);
            <u>if</u> last symbol = colonequal <u>then</u> Distribute on type (n)
            <u>else</u> ERRORMESSAGE (335)
         <u>end</u>  Assignstat;


         <u>integer</u> <u>procedure</u>  Distribute on type (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Integer (n)
              <u>then</u> <u>begin</u>  Intassign (n); Distribute on type ≔ in <u>end</u>
              <u>else</u>
            <u>if</u>  Real (n)
              <u>then</u> <u>begin</u>  Realassign (n); Distribute on type ≔ re <u>end</u>
              <u>else</u>
            <u>if</u> Boolean (n)
              <u>then</u> <u>begin</u>  Boolassign (n); Distribute on type ≔ bo <u>end</u>
              <u>else</u>
            <u>if</u> String (n)
              <u>then</u> <u>begin</u>  Stringassign (n); Distribute on type ≔ st <u>end</u>
            <u>else</u> Distribute on type ≔ <u>if</u> Arithmetic (n) <u>then</u> Arassign (n)
            <u>else</u> Unassign (n)
         <u>end</u>  Distribute on type;


         <u>procedure</u>  Prepare (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Function (n)
              <u>then</u> <u>begin</u>  <u>if</u> Formal (n) <u>then</u> ERRORMESSAGE (336)
                 <u>else</u>
               <u>if</u>  Outside declaration (n) <u>then</u> ERRORMESSAGE (337)
               <u>else</u> n ≔ Local position (n)
            <u>end</u>
              <u>else</u> <u>if</u> Simple (n) ∧ Formal (n) <u>then</u> Macro2 (DOS2, n);
            next symbol
         <u>end</u>  Prepare;






         <u>Boolean</u> <u>procedure</u>  Intassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> m;  <u>Boolean</u>  rounded;
            <u>if</u>  Noninteger (n) <u>then</u>  ERRORMESSAGE (338);
            Prepare (n); rounded ≔ false;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u>  m ≔ Identifier; Subscripted variable (m);
               <u>if</u> last symbol = colonequal
                 <u>then</u> rounded ≔ Intassign (m)
               <u>else</u> <u>begin</u>  Function designator (m);
                  Arithname (m); Rest of arithexp
               <u>end</u>
            <u>end</u>
            <u>else</u> Arithexp;
            <u>if</u> Subscrvar (n)
              <u>then</u> <u>begin</u>   <u>if</u> Formal (n) <u>then</u> Macro (STFSU)
                 <u>else</u>
               <u>if</u> rounded    <u>then</u> Macro (SSTSI)
               <u>else</u> Macro (STSI)
            <u>end</u>
              <u>else</u> <u>if</u> Formal (n) <u>then</u> Macro2 (DOS3, n)
              <u>else</u> <u>if</u> rounded    <u>then</u> Macro2 (SSTI, n)
            <u>else</u> Macro2 (STI, n);
            Intassign ≔ Formal (n) <u>impl</u>  rounded
         <u>end</u> Intassign;


         <u>procedure</u>  Realassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  m;
            <u>if</u> Nonreal (n) <u>then</u> ERRORMESSAGE (339);
            Prepare (n);
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u> last symbol = colonequal
                 <u>then</u> Realassign (m)
               <u>else</u> <u>begin</u> Function designator (m);
                  Arithname (m); Rest of arithexp
               <u>end</u>
            <u>end</u>
            <u>else</u> Arithexp;
            <u>if</u>  Subscrvar (n)
              <u>then</u> <u>begin</u> <u>if</u> Formal (n) <u>then</u> Macro (STFSU)
               <u>else</u> Macro (STSR)
            <u>end</u>
              <u>else</u> <u>if</u> Formal (n) <u>then</u> Macro2 (DOS3, n)
            <u>else</u> Macro2 (STR, n)
         <u>end</u>  Realassign;






         <u>procedure</u>  Boolassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> m;
            <u>if</u> Nonboolean (n) <u>then</u>  ERRORMESSAGE (340);
            Prepare (n);
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u> last symbol = colonequal
                 <u>then</u> Boolassign (m)
               <u>else</u> <u>begin</u> Boolprimrest (m); Rest of boolexp <u>end</u>
            <u>end</u>
            <u>else</u> Boolexp;
            <u>if</u>  Subscrvar (n) <u>then</u> Macro (STSB)
              <u>else</u> <u>if</u> Formal (n) <u>then</u> Macro2 (DOS3, n)
            <u>else</u> Macro2 (STB, n)
         <u>end</u>  Boolassign;


         <u>procedure</u>  Stringassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> m;
            <u>if</u>  Nonstring (n) <u>then</u>  ERRORMESSAGE (341);
            Prepare (n);
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u> last symbol = colonequal
                 <u>then</u> Stringassign (m)
               <u>else</u> Stringname (m)
            <u>end</u>
            <u>else</u> Stringexp;
            <u>if</u> Subscrvar (n) <u>then</u> Macro (STSST)
              <u>else</u> <u>if</u> Formal (n) <u>then</u> Macro2 (DOS3, n)
            <u>else</u> Macro2 (STST, n)
         <u>end</u>  Stringassign;


         <u>integer</u> <u>procedure</u>  Arassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> type, m;
            <u>if</u>  Nonarithmetic (n) <u>then</u>  ERRORMESSAGE (342);
            Prepare (n); type ≔ ar;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u> last symbol = colonequal
                 <u>then</u> <u>begin</u> <u>if</u> Nonarithmetic (m)
                    <u>then</u> ERRORMESSAGE (343);
                  type ≔ Distribute on type (m)
               <u>end</u>
               <u>else</u> <u>begin</u> Function designator (m);
                  Arithname (m); Rest of arithexp
               <u>end</u>
            <u>end</u>
            <u>else</u> Arithexp;
            <u>if</u> Subscrvar (n) <u>then</u> Macro (STFSU) <u>else</u> Macro2 (DOS3, n);
            Arassign ≔ type
         <u>end</u>  Arassign;






         <u>integer</u> <u>procedure</u>  Unassign (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  type, m;
            <u>if</u>  Nontype (n) <u>then</u>  ERRORMESSAGE (344);
            Prepare (n);
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> m ≔ Identifier; Subscripted variable (m);
               <u>if</u> Nontype (m) <u>then</u> ERRORMESSAGE (345);
               <u>if</u> last symbol = colonequal
                 <u>then</u> type ≔ Distribute on type (m)
               <u>else</u> Exprest (type, m)
            <u>end</u>
            <u>else</u> Nondesexp (type);
            <u>if</u> Subscrvar (n)
              <u>then</u> <u>begin</u> <u>if</u> type = bo <u>then</u> Macro (STSB)
                 <u>else</u>
               <u>if</u> type = st <u>then</u> Macro (STSST)
               <u>else</u> Macro (STFSU)
            <u>end</u>
            <u>else</u> Macro2 (DOS3, n);
            Unassign ≔ type
         <u>end</u>  Unassign;


         <u>procedure</u>  Function designator (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> Proc (n)
              <u>then</u> <u>begin</u> <u>if</u> Nonfunction (n) <u>then</u> ERRORMESSAGE (346);
               Procedure call (n)
            <u>end</u>
         <u>end</u>  Function designator;


         <u>procedure</u>  Procstat (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u>  Proc (n)
              <u>then</u> <u>begin</u> Procedure call (n);
               <u>if</u>  ¬ (In library (n) ∨ Function (n))
                 <u>then</u> last lnc ≔ - n;
               <u>if</u>  Formal (n) ∨ (Function (n) ∧ String (n))
                 <u>then</u>  Macro (REJST)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (347)
         <u>end</u>  Procstat;






         <u>procedure</u>  Procedure call (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  number of parameters;
            <u>if</u> Operator like (n)
              <u>then</u> Process operator (n)
            <u>else</u> <u>begin</u> number of parameters ≔ List length (n);
               <u>if</u> number of parameters ≠ 0
                 <u>then</u> Parameter list (n, number of parameters)
                 <u>else</u> <u>if</u> Formal (n)
                 <u>then</u> Macro2 (DOS, n)
                 <u>else</u> <u>if</u> In library(n) <u>then</u> Macro2 (ISUBJ, n)
               <u>else</u> Macro2 (SUBJ, n)
            <u>end</u>
         <u>end</u> Procedurecall;


         <u>integer</u> <u>procedure</u>  Ordinal number (n); <u>integer</u>  n;
         <u>begin</u>   Ordinal number ≔ <u>if</u> Formal (n) <u>then</u> 15
            <u>else</u>
              <u>if</u> Subscrvar (n)
              <u>then</u> (<u>if</u> Arithmetic (n)
              <u>then</u> (<u>if</u> Real (n) <u>then</u> 8 <u>else</u> 9)
            <u>else</u> <u>if</u> Boolean (n)
              <u>then</u> 10 <u>else</u> 11)
            <u>else</u>
              <u>if</u> Function (n)
              <u>then</u> (<u>if</u> Arithmetic (n)
              <u>then</u> (<u>if</u> Real (n) <u>then</u> 24 <u>else</u> 25)
            <u>else</u> <u>if</u> Boolean (n) <u>then</u> 26 <u>else</u> 27)
            <u>else</u>
              <u>if</u> Proc (n) <u>then</u> 30
            <u>else</u>
              <u>if</u> Arithmetic(n)
              <u>then</u> (<u>if</u> Real (n) <u>then</u> 0 <u>else</u> 1)
            <u>else</u> <u>if</u> Boolean (n)
              <u>then</u> 2
            <u>else</u> <u>if</u> String (n) <u>then</u> 3 <u>else</u> 14
         <u>end</u>  Ordinal number;






         <u>procedure</u>  Parameter list (n, number of parameters);
            <u>integer</u>  n, number of parameters;
         <u>begin</u> <u>integer</u>  count, m, f, apd, type, future;
            <u>Boolean</u>  simple identifier;
            <u>integer</u>  <u>array</u>  descriptor list[1 : number of parameters];
            count ≔ future ≔ 0; f ≔ n;
            <u>if</u> last symbol = open
              <u>then</u>
            <u>begin</u>
               next: count ≔ count + 1; next symbol;
               Actual parameter (apd, simple identifier, type, future);
               <u>if</u> count &LessSlantEqual; number of parameters
                 <u>then</u>
               <u>begin</u> descriptor list[count] ≔ apd;
                  <u>if</u>  ¬ Formal (n)
                    <u>then</u>
                  <u>begin</u> f ≔ Next formal identifier (f);
                     <u>if</u> simple identifier
                       <u>then</u>
                     <u>begin</u> <u>if</u> Subscrvar (f)
                          <u>then</u>
                        <u>begin</u> <u>if</u> Nonsubscrvar (type)
                             <u>then</u>  ERRORMESSAGE (348);
                           Check type (f, type);
                           Check list length (f, type)
                        <u>end</u>
                          <u>else</u>
                        <u>if</u> Proc (f)
                          <u>then</u>
                        <u>begin</u> <u>if</u> Nonproc (type)
                             <u>then</u> ERRORMESSAGE (349);
                           Check list length (f, type);
                           <u>if</u> Function (f)
                             <u>then</u> <u>begin</u> <u>if</u> Nonfunction (type)
                                <u>then</u> ERRORMESSAGE (350);
                              Check type (f, type)
                           <u>end</u>
                        <u>end</u>
                          <u>else</u>
                        <u>if</u> Simple (f)
                          <u>then</u>
                        <u>begin</u> <u>if</u> Nonsimple (type)
                             <u>then</u> ERRORMESSAGE (351);
                           Check type (f, type)
                        <u>end</u>
                     <u>end</u>
                     <u>else</u>
                     <u>begin</u> <u>if</u> Subscrvar (f) ∨ Proc (f)
                          <u>then</u> ERRORMESSAGE (352);
                        <u>if</u> Assigned to (f) ∧ Nonassignable (apd)
                          <u>then</u> ERRORMESSAGE (353);
                        <u>if</u> Arithmetic(f) ∧
                          (type = bo ∨ type = st ∨ type = des)
                          <u>then</u> ERRORMESSAGE (354) <u>else</u>
                        <u>if</u> Boolean (f) ∧
                          type ≠ bo ∧ type ≠ nondes ∧ type ≠ un
                          <u>then</u> ERRORMESSAGE (355) <u>else</u>
                        <u>if</u> String (f) ∧
                          type ≠ st ∧ type ≠ nondes ∧ type ≠ un
                          <u>then</u> ERRORMESSAGE (356) <u>else</u>
                        <u>if</u> Designational (f) ∧
                          type ≠ des ∧ type ≠ un
                          <u>then</u> ERRORMESSAGE (357) <u>else</u>
                        <u>if</u> Arbost (f) ∧ type = des
                          <u>then</u> ERRORMESSAGE (358)
                     <u>end</u>
                  <u>end</u>
               <u>end</u>
               <u>else</u> ERRORMESSAGE (359);
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next;
               <u>if</u> last symbol = close
                 <u>then</u> <u>begin</u> next symbol;
                  <u>if</u> count &lt; number of parameters
                    <u>then</u> ERRORMESSAGE (360)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (361)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (362);
            <u>if</u> future ≠ 0 <u>then</u>  Substitute (future);
            <u>if</u> Formal (n) <u>then</u>  Macro2 (DOS, n) <u>else</u>  <u>if</u> In library (n)
              <u>then</u> Macro2 (ISUBJ, n)
            <u>else</u> Macro2 (SUBJ, n);
            m ≔ 0;
            next apd: <u>if</u> m &lt; count ∧ m &lt; number of parameters
              <u>then</u> <u>begin</u> m ≔ m + 1; apd ≔ descriptor list[m];
               Macro2 (CODE, apd); <u>goto</u> next apd
            <u>end</u>
         <u>end</u>  Parameter list;






         <u>procedure</u>  Actual parameter (apd, simple identifier, type, future);
            <u>integer</u>  apd, type, future; <u>Boolean</u>  simple identifier;
         <u>begin</u> <u>integer</u>  n, begin address;
            begin address ≔ Order counter + (<u>if</u> future = 0 <u>then</u> 1 <u>else</u> 0);
            simple identifier ≔ false;
            <u>if</u> letter last symbol
              <u>then</u>
            <u>begin</u> n ≔ Identifier;
               <u>if</u> last symbol = comma ∨ last symbol = close
                 <u>then</u>
               <u>begin</u> type ≔ n; simple identifier ≔ true;
                  <u>if</u> Proc (n) ∧ ¬ Formal (n)
                    <u>then</u>
                  <u>begin</u> <u>if</u> future = 0 <u>then</u> Macro2 (JU, future);
                     Macro (TFD);
                     <u>if</u> In library (n) <u>then</u> Macro2 (LJU1, n)
                     <u>else</u> Macro2 (JU1, n);
                     apd ≔ d20 × Ordinal number (n) + begin address
                  <u>end</u>
                    <u>else</u> <u>if</u> Subscrvar (n) ∧ Designational (n) ∧¬ Formal (n)
                    <u>then</u> <u>begin</u> <u>if</u> future = 0
                       <u>then</u> Macro2 (JU, future);
                     Macro2 (TSWE, n);
                     apd ≔ 12 × d20 + begin address
                  <u>end</u>
                  <u>else</u> apd ≔ d20 × Ordinal number (n) +
                    Address (n) +
                    (<u>if</u> Dynamic (n) <u>then</u> d18 <u>else</u> 0)
               <u>end</u>
               <u>else</u>
               <u>begin</u> Start implicit subroutine (future);
                  <u>if</u> Subscrvar (n) <u>then</u> Address description (n);
                  <u>if</u> (last symbol = comma ∨ last symbol = close) ∧
                    ( ¬ Designational (n))
                    <u>then</u>
                  <u>begin</u> <u>if</u> Unknown (n) <u>then</u> Macro (SAS);
                     Macro2 (EXITSV, -2 × dimension);
                     apd ≔ d20 × (<u>if</u> Boolean (n) <u>then</u> 18 <u>else</u>
                       <u>if</u> String (n)  <u>then</u> 19 <u>else</u>
                       <u>if</u> Formal (n)  <u>then</u> 32 <u>else</u>
                       <u>if</u> Real (n)    <u>then</u> 16 <u>else</u> 17)
                       + Ordercounter;
                     type ≔ <u>if</u> Arithmetic (n) <u>then</u> ar <u>else</u>
                       <u>if</u> Boolean (n)    <u>then</u> bo <u>else</u>
                       <u>if</u> String (n)     <u>then</u> st <u>else</u>
                       <u>if</u> Arbost (n)     <u>then</u> nondes <u>else</u> un;
                     Macro2 (SUBJ, -begin address);
                     <u>if</u> Boolean (n) <u>then</u> Macro (TASB)  <u>else</u>
                     <u>if</u> String (n)  <u>then</u> Macro (TASST) <u>else</u>
                     <u>if</u> Formal (n)  <u>then</u> Macro (TASU)  <u>else</u>
                     <u>if</u> Integer (n) <u>then</u> Macro (TASI)
                     <u>else</u> Macro (TASR);
                     Macro (DECS); Macro2 (SUBJ, -begin address);
                     Macro (FAD)
                  <u>end</u>

                  <u>else</u>
                  <u>begin</u> <u>if</u> Subscrvar (n) <u>then</u> Evaluation of (n);
                     Exprest (type, n); Macro (EXITIS);
                     apd ≔ mask[type] + begin address
                  <u>end</u>
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> Unsigned number;
               <u>if</u> (last symbol = comma ∨ last symbol = close) ∧
                 ( ¬ in name list)
                 <u>then</u> <u>begin</u> type ≔ ar; apd ≔ Number descriptor <u>end</u>
               <u>else</u> <u>begin</u> Start implicit subroutine (future);
                  Arithconstant;
                  <u>if</u> in name list ∧ ( ¬ operator last symbol)
                    <u>then</u> <u>begin</u> Macro2 (TLV, integer label);
                     type ≔ intlab
                  <u>end</u>
                  <u>else</u> Rest of arboolexp (type);
                  Macro (EXITIS);
                  apd ≔ mask[type] + begin address
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = plus
              <u>then</u>
            <u>begin</u> next symbol;
               <u>if</u> digit last symbol
                 <u>then</u> <u>begin</u> Unsigned number;
                  <u>if</u> last symbol = comma ∨ last symbol = close
                    <u>then</u> <u>begin</u> type ≔ ar; apd ≔ Number descriptor <u>end</u>
                  <u>else</u> <u>begin</u> Start implicit subroutine (future);
                     Arithconstant;
                     Rest of arboolexp (type);
                     Macro (EXITIS);
                     apd ≔ mask[type] + begin address
                  <u>end</u>
               <u>end</u>
               <u>else</u> <u>begin</u> Start implicit subroutine (future);
                  Arboolexp (type);
                  Macro (EXITIS); apd ≔ mask[type] + begin address
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = minus
              <u>then</u>
            <u>begin</u> next symbol;
               <u>if</u> digit last symbol
                 <u>then</u> <u>begin</u> Unsigned number;
                  <u>if</u> (last symbol = comma ∨ last symbol = close) ∧
                    small
                    <u>then</u>
                  <u>begin</u> type ≔ ar;
                     apd ≔ d20 × 13 + value of constant
                  <u>end</u>
                  <u>else</u>
                  <u>begin</u> Start implicit subroutine (future);
                     Arithconstant; Next primary; Next factor;
                     Macro (NEG); Rest of arboolexp (type);
                     Macro (EXITIS);
                     apd ≔ mask[type] + begin address
                  <u>end</u>
               <u>end</u>
               <u>else</u> <u>begin</u> Start implicit subroutine (future);
                  Term; Macro (NEG);
                  Rest of arboolexp (type);
                  Macro (EXITIS); apd ≔ mask[type] + begin address
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = true ∨ last symbol = false
              <u>then</u>
            <u>begin</u> type ≔ bo; n ≔ last symbol; next symbol;
               <u>if</u> last symbol = comma ∨ last symbol = close
                 <u>then</u> apd ≔ d20 × 6 + (<u>if</u> n = true <u>then</u> 0 <u>else</u> 1)
               <u>else</u> <u>begin</u> Start implicit subroutine (future);
                  Macro2 (TBC, n);
                  Rest of boolexp;
                  Macro (EXITIS);
                  apd ≔ mask[type] + begin address
               <u>end</u>
            <u>end</u>
            <u>else</u> <u>begin</u> Start implicit subroutine (future); Exp (type);
               Macro (EXITIS); apd ≔ mask[type] + begin address
            <u>end</u>
         <u>end</u>  Actual parameter;






         <u>procedure</u>  Start implicit subroutine (future); <u>integer</u>  future;
         <u>begin</u>   <u>if</u> future = 0 <u>then</u>  Macro2 (JU, future);
            Macro (ENTRIS)
         <u>end</u>  Start implicit subroutine;


         <u>integer</u> <u>procedure</u> Number descriptor;
         <u>begin</u>   Number descriptor ≔               <u>if</u> small <u>then</u> d20 × 7 + value of constant
            <u>else</u> d20 × (<u>if</u>  real number <u>then</u> 4 <u>else</u> 5)
              + address of constant
         <u>end</u>  Number descriptor;


         <u>procedure</u>  Process operator (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  count;
            count ≔ 0;
            <u>if</u> last symbol = open
              <u>then</u> <u>begin</u>
               next: next symbol; Arithexp; count ≔ count + 1;
               <u>if</u> last symbol = comma
                 <u>then</u> <u>begin</u> Macro (STACK); <u>goto</u> next <u>end</u>;
               <u>if</u> last symbol = close
                 <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (361)
            <u>end</u>;
            <u>if</u> count ≠ List length (n) <u>then</u> ERRORMESSAGE (363);
            Macro (Operator macro (n))
         <u>end</u>  Process operator;


         <u>Boolean</u> <u>procedure</u>  Nonassignable (apd); <u>integer</u>  apd;
         <u>begin</u>   <u>integer</u>  rank;
            rank ≔ apd ÷ d20;
            Nonassignable ≔ (rank ≠ 15) ∧ (rank - rank ÷ 16 × 16) &gt; 3
         <u>end</u>  Nonassignable;


         <u>procedure</u>  Line;
         <u>begin</u>   <u>if</u> lnc ≠ last lnc <u>then</u> Line1 <u>end</u>  Line;


         <u>procedure</u>  Line1;
         <u>begin</u>   <u>if</u> wanted <u>then</u> <u>begin</u> last lnc ≔ lnc; Macro2 (LNC, lnc) <u>end</u>
         <u>end</u>  Line1;






         <u>procedure</u> Statement;
         <u>begin</u>   if statement forbidden ≔ false; Stat <u>end</u>  Statement;


         <u>procedure</u>  Unconditional statement;
         <u>begin</u>   if statement forbidden ≔ true; Stat <u>end</u>  Unconditional statement;


         <u>procedure</u>  Stat;
         <u>begin</u>   <u>integer</u> n, save lnc;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> save lnc ≔ line counter;
               n ≔ Identifier;
               <u>if</u> Designational (n)
                 <u>then</u> <u>begin</u> Label declaration (n); Stat <u>end</u>
               <u>else</u> <u>begin</u> lnc ≔ save lnc; Line;
                  <u>if</u> Subscrvar (n) ∨ last symbol = colonequal
                    <u>then</u> Assignstat (n)
                  <u>else</u> Procstat (n)
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> Unsigned number;
               <u>if</u> in name list
                 <u>then</u> <u>begin</u> Label declaration (integer label); Stat <u>end</u>
               <u>else</u> ERRORMESSAGE (364)
            <u>end</u>
            <u>else</u> <u>begin</u> <u>if</u> last symbol = goto
                 <u>then</u> <u>begin</u> lnc ≔ line counter; Line; Gotostat <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = begin
                 <u>then</u> <u>begin</u> save lnc ≔ line counter; next symbol;
                  <u>if</u> declarator last symbol
                    <u>then</u> <u>begin</u> lnc ≔ save lnc; Line; Block <u>end</u>
                  <u>else</u> Compound tail;
                  next symbol
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = if
                 <u>then</u> <u>begin</u> <u>if</u> if statement forbidden
                    <u>then</u> ERRORMESSAGE (365);
                  lnc ≔ line counter; Line; Ifstat
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = for
                 <u>then</u> <u>begin</u> lnc ≔ line counter; Line; Forstat;
                  <u>if</u> last symbol = else
                    <u>then</u> ERRORMESSAGE (366)
               <u>end</u>
            <u>end</u>
         <u>end</u> Stat;







         <u>procedure</u> Gotostat;
         <u>begin</u>   <u>integer</u> n;
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier; Subscripted variable (n);
               <u>if</u> local label (n)
                 <u>then</u> <u>begin</u> Test for count (n); Macro2 (JU, n) <u>end</u>
               <u>else</u> <u>begin</u> Designame (n); Macro (JUA) <u>end</u>
            <u>end</u>
            <u>else</u> <u>begin</u> Desigexp; Macro (JUA) <u>end</u>
         <u>end</u> Gotostat;


         <u>procedure</u> Compound tail;
         <u>begin</u>   Statement;
            <u>if</u> last symbol ≠ semicolon ∧ last symbol ≠ end
              <u>then</u> <u>begin</u> ERRORMESSAGE (367);
               skip rest of statement (Statement)
            <u>end</u>;
            <u>if</u> last symbol = semi colon
              <u>then</u> <u>begin</u> next symbol; Compound tail <u>end</u>
         <u>end</u> Compound tail;


         <u>procedure</u>  Ifstat;
         <u>begin</u>   <u>integer</u>  future1, future2, save lnc, last lnc1;
            future1 ≔ future2 ≔ 0; save lnc ≔ line counter;
            next symbol; Boolexp; Macro2 (COJU, future1);
            <u>if</u> last symbol = then <u>then</u> next symbol <u>else</u> ERRORMESSAGE (368);
            Unconditional statement;
            <u>if</u> last symbol = else
              <u>then</u> <u>begin</u> Macro2 (JU, future2); Substitute (future1);
               last lnc1 ≔ last lnc; last lnc ≔ save lnc;
               next symbol; Statement; Substitute (future2);
               <u>if</u> last lnc &gt; last lnc1 <u>then</u> last lnc ≔ last lnc1
            <u>end</u>
            <u>else</u> <u>begin</u> Substitute (future1);
               <u>if</u> last lnc &gt; save lnc <u>then</u> last lnc ≔ save lnc
            <u>end</u>
         <u>end</u>  Ifstat;


         <u>procedure</u> Forstat;
         <u>begin</u>   <u>integer</u>  future, save lnc;
            save lnc ≔ line counter;
            l0 ≔ 0; next symbol; For list;
            future ≔ 0; Macro2 (JU, future); <u>if</u> l0 ≠ 0 <u>then</u> Substitute(l0);
            <u>if</u> last symbol = do <u>then</u> next symbol <u>else</u> ERRORMESSAGE (369);
            Increase status (increment); for count ≔ for count + 1;
            Statement;
            Increase status (- increment); for count ≔ for count - 1;
            <u>if</u> last lnc &lt; 0 ∨ lnc ≠ save lnc
              <u>then</u> <u>begin</u> lnc ≔ save lnc; Line1 <u>end</u>;
            Macro2 (LJU,status); Substitute (future)
         <u>end</u>  Forstat;






         <u>procedure</u>  Store preparation;
         <u>begin</u>   <u>if</u> Subscrvar (controlled variable) <u>then</u> Macro2 (SUBJ, - 12)
              <u>else</u>
            <u>if</u>  Formal (controlled variable)
              <u>then</u> Macro2 (DOS2, controlled variable)
         <u>end</u>  Store preparation;


         <u>procedure</u>  Store macro;
         <u>begin</u>   <u>if</u>  Subscrvar (controlled variable)
              <u>then</u> <u>begin</u> <u>if</u> Formal (controlled variable)  <u>then</u> Macro (STFSU)
                 <u>else</u>
               <u>if</u> Integer (controlled variable) <u>then</u> Macro (STSI)
               <u>else</u> Macro (STSR);
               Macro2 (DECB, 2)
            <u>end</u>
              <u>else</u> <u>if</u> Formal (controlled variable)
              <u>then</u> Macro2 (DOS3, controlled variable)
              <u>else</u> <u>if</u> Integer (controlled variable)
              <u>then</u> Macro2 (STI, controlled variable)
            <u>else</u> Macro2 (STR, controlled variable)
         <u>end</u>  Store macro;


         <u>procedure</u> Take macro;
         <u>begin</u>   <u>if</u> Subscrvar (controlled variable)
              <u>then</u> Macro2 (SUBJ, - l1)
            <u>else</u> Arithname (controlled variable)
         <u>end</u>  Take macro;


         <u>procedure</u> For list;
         <u>begin</u> <u>if</u> letter last symbol
              <u>then</u>
            <u>begin</u> controlled variable ≔ Identifier;
               <u>if</u> Nonarithmetic (controlled variable)
                 <u>then</u> ERRORMESSAGE (370);
               <u>if</u> Subscrvar (controlled variable)
                 <u>then</u>
               <u>begin</u> l3 ≔ 0; Macro2 (JU, l3);
                  l4 ≔ Order counter;
                  Address description (controlled variable);
                  Macro2 (EXITSV, 1 - 2 × dimension);
                  l1 ≔ Order counter;
                  Macro2 (SUBJ, - l4);
                  <u>if</u> Formal (controlled variable)  <u>then</u> Macro (TSCVU)
                    <u>else</u>
                  <u>if</u> Integer (controlled variable) <u>then</u> Macro (TISCV)
                  <u>else</u> Macro (TRSCV);
                  l2 ≔ Order counter;
                  Macro2 (SUBJ, - l4); Macro (FADCV);
                  Substitute (l3)
               <u>end</u>
                 <u>else</u> <u>if</u> Function (controlled variable)
                 <u>then</u> ERRORMESSAGE (371);
               <u>if</u> last symbol ≠ colonequal <u>then</u> ERRORMESSAGE (372);




               list: l3 ≔ Order counter;
               Macro2 (TSIC, 0); Macro2 (SSTI, status);
               l4 ≔ Order counter;
               Store preparation;
               next symbol; Arithexp;
               <u>if</u> last symbol = comma ∨ last symbol = do
                 <u>then</u> <u>begin</u> Store macro; Macro2 (JU, l0);
                  Substitute (l3)
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = while
                 <u>then</u> <u>begin</u> Store macro;
                  next symbol; Boolexp;
                  Macro2 (YCOJU, l0); Subst2 (l4, l3)
               <u>end</u>
                 <u>else</u>
               <u>if</u> last symbol = step
                 <u>then</u> <u>begin</u> l5 ≔ 0; Macro2 (JU, l5); l4 ≔ Order counter;
                  next symbol; complicated ≔ false; Arithexp;
                  complex step element ≔                     complicated ∨ Order counter&gt; l4 + 1;
                  <u>if</u> complex step element <u>then</u>  Macro (EXIT);
                  Substitute (l3);
                  Store preparation; Take macro; Macro (STACK);
                  <u>if</u> complex step element <u>then</u>  Macro2 (SUBJ, - l4)
                  <u>else</u>  Macro2 (DO, l4);
                  Macro (ADD);
                  Substitute (15);
                  Store macro;
                  <u>if</u> Subscrvar (controlled variable) ∨
                    Formal (controlled variable)
                    <u>then</u> Take macro;
                  Macro (STACK);
                  <u>if</u> last symbol = until
                    <u>then</u> <u>begin</u> next symbol; Arithexp <u>end</u>
                  <u>else</u> ERRORMESSAGE (373);
                  Macro (TEST1);
                  <u>if</u> complex step element <u>then</u> Macro2 (SUBJ, - l4)
                  <u>else</u> Macro2 (DO, l4);
                  Macro (TEST2); Macro2 (YCOJU, l0)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (374);
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> list
            <u>end</u>
            <u>else</u> ERRORMESSAGE (375)
         <u>end</u>  For list;






         <u>procedure</u>  Switch declaration;
         <u>begin</u> <u>integer</u>  m;
            next symbol;
            <u>if</u> letter last symbol
              <u>then</u>
            <u>begin</u> switch identifier ≔ Identifier;
               number of switch elements ≔ List length (switch identifier);
               <u>if</u> last symbol = colonequal
                 <u>then</u>
               <u>begin</u> <u>integer</u> <u>array</u>
                    sword list[1 : number of switch elements];
                  switch list count ≔ 0; in switch declaration ≔ true;
                  next: switch list count ≔ switch list count + 1;
                  next symbol;
                  <u>if</u> letter last symbol
                    <u>then</u>
                  <u>begin</u> m ≔ Identifier;
                     <u>if</u> Nondesignational (m) <u>then</u> ERRORMESSAGE (376);
                     <u>if</u> Subscrvar (m)
                       <u>then</u>
                     <u>begin</u> sword ≔ -45613055 + Order counter;
                        Subscripted variable (m); Macro (EXIT)
                     <u>end</u>
                     <u>else</u>
                       sword ≔ (<u>if</u> Formal (m)
                       <u>then</u> -33685503
                     <u>else</u> 4718592 + (<u>if</u> Dynamic (m)
                       <u>then</u> function digit
                     <u>else</u> 0)) +
                       Address (m)
                  <u>end</u>
                    <u>else</u>
                  <u>if</u> digit last symbol
                    <u>then</u>
                  <u>begin</u> Unsigned number;
                     <u>if</u>  in name list
                       <u>then</u>  sword ≔ 4718592 +
                       (<u>if</u> Dynamic (integer label)
                       <u>then</u> function digit
                     <u>else</u> 0) +
                       Address (integer label)
                     <u>else</u> ERRORMESSAGE (377)
                  <u>end</u>
                  <u>else</u>
                  <u>begin</u> sword ≔ - 45613055 + Order counter;
                     Desigexp; Macro (EXIT)
                  <u>end</u>;




                  <u>if</u> switch list count &gt; number of switch elements
                    <u>then</u> ERRORMESSAGE (378);
                  sword list[switch list count] ≔ sword;
                  <u>if</u> last symbol= comma <u>then</u> <u>goto</u> next;
                  <u>if</u> switch list count &lt; number of switch elements
                    <u>then</u> ERRORMESSAGE (379);
                  Mark position in name list (switch identifier);
                  in switch declaration ≔ false;
                  Macro2 (CODE, number of switch elements);
                  m ≔ 0;
                  next sword: <u>if</u> m &lt; switch list count ∧
                    m &lt; number of switch elements
                    <u>then</u> <u>begin</u> m ≔ m + 1; sword ≔ sword list[m];
                     Macro2 (CODE, sword); <u>goto</u> next sword
                  <u>end</u>
               <u>end</u>
               <u>else</u> ERRORMESSAGE (380)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (381)
         <u>end</u>  Switch declaration;


         <u>procedure</u> Array declaration;
         <u>begin</u>   <u>integer</u>  n, count;
            next symbol; lnc ≔ line counter; Line;
            n ≔ Identifier; dimension ≔ List length (n); count ≔ 1;
            next:   <u>if</u> last symbol = comma <u>then</u> <u>begin</u> next symbol; Identifier;
               count ≔ count + 1; <u>goto</u> next
            <u>end</u>;
            <u>if</u> last symbol = sub   <u>then</u> <u>begin</u> in array declaration ≔ true;
               Bound pair list;
               in array declaration ≔ false
            <u>end</u>
            <u>else</u> ERRORMESSAGE (382);
            Macro2 (TNA, count); Macro2 (TDA, dimension);
            Macro2 (TAA, n); Macro (arr decla macro);
            <u>if</u> last symbol = comma <u>then</u> Array declaration
         <u>end</u>  Array declaration;


         <u>procedure</u>  Bound pair list;
         <u>begin</u>   next symbol; Arithexp; Macro (STACK);
            <u>if</u> last symbol = colon <u>then</u> <u>begin</u> next symbol; Arithexp;
               Macro (STACK)
            <u>end</u>
            <u>else</u> ERRORMESSAGE (383);
            <u>if</u> last symbol = comma <u>then</u> Bound pair list
              <u>else</u> <u>if</u> last symbol = bus
              <u>then</u> next symbol
            <u>else</u> ERRORMESSAGE (384)
         <u>end</u>  Bound pair list;






         <u>procedure</u>  Procedure declaration;
         <u>begin</u> <u>integer</u>  n, f, count, save lnc;
            next symbol; f ≔ n ≔ Identifier;
            Skip parameter list; skip value list; skip specification list;
            <u>if</u> ¬ In library (n) <u>then</u> Mark position in name list (n);
            <u>if</u> in code (n)
              <u>then</u> Translate code
            <u>else</u> <u>begin</u> <u>if</u> Function (n) <u>then</u> Set inside declaration (n, true);
               entrance block;
               Macro2 (DPTR, display level);
               Macro2 (INCRB, top of display);
               <u>for</u> count ≔ List length (n) <u>step</u> - 1 <u>until</u> 1 <u>do</u>
                  <u>begin</u> f ≔ Next formal identifier(f);
                     <u>if</u> In value list (f)
                       <u>then</u>
                     <u>begin</u> <u>if</u> Subscrvar (f)
                          <u>then</u> Macro (CEN)
                        <u>else</u>
                        <u>begin</u> <u>if</u> Arithmetic (f)
                             <u>then</u> <u>begin</u> <u>if</u> Integer (f)
                                <u>then</u> Macro (CIV)
                              <u>else</u> Macro (CRV)
                           <u>end</u>
                             <u>else</u> <u>if</u> Boolean (f) <u>then</u> Macro (CBV)
                             <u>else</u> <u>if</u> String (f)  <u>then</u> Macro (CSTV)
                           <u>else</u> Macro (CLV)
                        <u>end</u>
                     <u>end</u>
                       <u>else</u> <u>if</u> Assigned to (f) <u>then</u> Macro (CLPN)
                     <u>else</u> Macro (CEN)
                  <u>end</u>;
               Macro2 (TDL, display level);
               Macro2 (ENTRPB, local space);
               Label list; f ≔ n;
               <u>for</u>  count ≔ List length (n) <u>step</u> - 1 <u>until</u> 1 <u>do</u>
                  <u>begin</u> f ≔ Next formal identifier (f);
                     <u>if</u> In value list (f) ∧ Subscrvar (f)
                       <u>then</u> <u>begin</u> Macro2 (TAA, f);
                        <u>if</u> Integer (f) <u>then</u> Macro (TIAV)
                        <u>else</u> Macro (TAV)
                     <u>end</u>
                  <u>end</u>;




               save lnc ≔ last lnc; last lnc ≔ - line counter;
               Save and restore lnc (SLNC, n);
               <u>if</u> last symbol = begin
                 <u>then</u> <u>begin</u> next symbol; <u>if</u> declarator last symbol
                    <u>then</u> Declaration list;
                  Compound tail; next symbol
               <u>end</u>
               <u>else</u> Statement;
               lnc ≔ last lnc ≔ save lnc;
               <u>if</u> Function (n)
                 <u>then</u> <u>begin</u> Set inside declaration (n, false);
                  f ≔ Local position (n);
                  <u>if</u> Arithmetic (f) <u>then</u> Arithname (f) <u>else</u>
                  <u>if</u> Boolean (f) <u>then</u> Boolname (f)
                  <u>else</u> <u>begin</u> Stringname(f); Macro (LOS) <u>end</u>
               <u>end</u>;
               Save and restore lnc (RLNC, n);
               <u>if</u> use of counter stack <u>then</u> Macro (EXITPC)
               <u>else</u> Macro (EXITP);
               exit block
            <u>end</u>
         <u>end</u>  Procedure declaration;


         <u>procedure</u> Save and restore lnc (macro, n); <u>integer</u>  macro, n;
         <u>begin</u>  <u>if</u> wanted ∧ Function (n) <u>then</u> Macro2 (macro, Local position1 (n))
         <u>end</u>  Save and restore lnc;


         <u>procedure</u> Block;
         <u>begin</u>   entrance block;
            Macro2 (TBL, display level); Macro2 (ENTRB, local space);
            Label list; Declaration list; Compound tail;
            <u>if</u> use of counter stack <u>then</u> Macro2 (EXITC, display level)
            <u>else</u> Macro2 (EXITB, display level);
            exit block
         <u>end</u>  Block;






         <u>procedure</u>  Declaration list;
         <u>begin</u>   <u>integer</u> future, arr dec;
            future ≔ arr dec ≔ 0;
            next:   <u>if</u> type declarator last symbol <u>then</u> skip type declaration
              <u>else</u>
            <u>if</u> arr declarator last symbol
              <u>then</u> <u>begin</u>  <u>if</u> future ≠ 0
                 <u>then</u> <u>begin</u> Substitute (future);
                  future ≔ 0
               <u>end</u>;
               arr dec ≔ 1; Array declaration
            <u>end</u>
            <u>else</u>
            <u>begin</u> <u>if</u> future = 0 <u>then</u> Macro2 (JU, future);
               <u>if</u> last symbol = switch <u>then</u> Switch declaration
               <u>else</u> Procedure declaration
            <u>end</u>;
            <u>if</u> last symbol = semicolon <u>then</u> next symbol
            <u>else</u> ERRORMESSAGE (385);
            <u>if</u> declarator last symbol  <u>then</u> <u>goto</u> next;
            <u>if</u> future ≠ 0  <u>then</u> Substitute (future);
            <u>if</u> arr dec ≠ 0 <u>then</u> Macro2 (SWP, display level)
         <u>end</u>  Declaration list;


         <u>procedure</u> Label list;
         <u>begin</u>   <u>integer</u>  n, count;
            count ≔ Number of local labels;
            <u>if</u> count &gt; 0
              <u>then</u> <u>begin</u> Macro2 (DECB, 2 × count);
               Macro2 (LAD, display level);
               n ≔ 0; <u>for</u> count ≔ count <u>step</u> - 1 <u>until</u> 1 <u>do</u>
                  <u>begin</u> next: n ≔ Next local label (n);
                     <u>if</u> Super local (n) <u>then</u> <u>goto</u> next;
                     <u>if</u> count = 1 <u>then</u> Macro2 (LAST, n)
                     <u>else</u> Macro2 (NIL, n)
                  <u>end</u>
            <u>end</u>
         <u>end</u>  Label list;






         <u>procedure</u>  Program;
         <u>begin</u>   <u>integer</u>  n;
            <u>if</u> letter last symbol
              <u>then</u> <u>begin</u> n ≔ Identifier;
               <u>if</u> last symbol = colon
                 <u>then</u> Label declaration (n);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> digit last symbol
              <u>then</u> <u>begin</u> Unsigned number;
               <u>if</u> in name list ∧ last symbol = colon
                 <u>then</u> Label declaration (integer label);
               Program
            <u>end</u>
              <u>else</u>
            <u>if</u> last symbol = begin
              <u>then</u> <u>begin</u> next symbol;
               <u>if</u> declarator last symbol <u>then</u> Block
               <u>else</u> Compound tail;
               Macro (END)
            <u>end</u>
            <u>else</u> <u>begin</u> next symbol; Program <u>end</u>
         <u>end</u>  Program;


         <u>procedure</u>  Label declaration (n); <u>integer</u>  n;
         <u>begin</u>   last lnc ≔ - line counter;
            <u>if</u> Subscrvar (n)       <u>then</u> <u>begin</u> ERRORMESSAGE (388);
               Subscripted variable (n)
            <u>end</u>
            <u>else</u> Mark position in name list (n);
            <u>if</u> last symbol = colon <u>then</u> next symbol <u>else</u> ERRORMESSAGE (389)
         <u>end</u>  Label declaration;


         <u>procedure</u>  Substitute (address); <u>integer</u>  address;
         <u>begin</u>   Subst2 (Order counter, address) <u>end</u>  Substitute;


         <u>procedure</u> Subst2 (address1, address2);
            <u>value</u>  address1, address2; <u>integer</u>  address1, address2;
         <u>begin</u>   <u>integer</u>  instruction, instruct part, address part;
            address2 ≔ abs (address2);
            instruction ≔ space[prog base + address2];
            instruct part ≔ instruction ÷ d15 × d15 -
              (<u>if</u> instruction &lt; 0 <u>then</u> 32767 <u>else</u> 0);
            address part ≔ instruction - instruct part;
            space[prog base + address2] ≔ instruct part + address1;
            <u>if</u> address part = 0
              <u>then</u> <u>begin</u> <u>if</u> instruct part = end of list
                 <u>then</u> space[prog base + address2] ≔                  - space[prog base + address2]
            <u>end</u>
            <u>else</u> Subst2 (address1, address part)
         <u>end</u>  Subst2;






         <u>integer</u> <u>procedure</u>  Order counter;
         <u>begin</u>   Macro (EMPTY); Order counter ≔ instruct counter
         <u>end</u>  Order counter;


         <u>procedure</u>  Macro (macro number); <u>integer</u>  macro number;
         <u>begin</u>  Macro2 (macro number, parameter) <u>end</u>  Macro;


         <u>procedure</u>  Macro2 (macro number, metaparameter);
            <u>integer</u>  macro number, metaparameter;
         <u>begin</u>   macro ≔ <u>if</u> macro number &lt; 512 <u>then</u> macro list[macro number]
            <u>else</u> macro number;
            parameter ≔ metaparameter;
            <u>if</u> state = 0
              <u>then</u> <u>begin</u> <u>if</u> macro = STACK <u>then</u> state ≔ 1
                 <u>else</u>
               <u>if</u> Simple arithmetic take macro <u>then</u> Load (3)
               <u>else</u>
                 Produce (macro, parameter)
            <u>end</u>
              <u>else</u>
            <u>if</u> state = 1
              <u>then</u> <u>begin</u> Load (2);
               <u>if</u> ¬ Simple arithmetic take macro
                 <u>then</u> <u>begin</u> Produce (STACK, parameter); Unload <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> state = 2
              <u>then</u> <u>begin</u> <u>if</u> Optimizable operator <u>then</u> Optimize
               <u>else</u>
               <u>begin</u> Produce (STACK, parameter); state ≔ 3;
                  Macro2 (macro, parameter)
               <u>end</u>
            <u>end</u>
              <u>else</u>
            <u>if</u> state = 3
              <u>then</u> <u>begin</u> <u>if</u> macro = NEG <u>then</u> Optimize
               <u>else</u>
               <u>begin</u> Unload; Macro2 (macro, parameter) <u>end</u>
            <u>end</u>;
            <u>if</u> Forward jumping macro ∧ metaparameter &LessSlantEqual; 0
              <u>then</u> Assign (metaparameter)
         <u>end</u>  Macro2;






         <u>procedure</u>  Load (state i); <u>integer</u>  state i;
         <u>begin</u>  stack0 ≔ macro; stack1 ≔ parameter; state ≔ state i <u>end</u>  Load;


         <u>procedure</u>  Unload;
         <u>begin</u>   Produce (stack0, stack1); state ≔ 0 <u>end</u>  Unload;


         <u>procedure</u>  Optimize;
         <u>begin</u>  stack0 ≔ tabel[5 × Opt number (macro) + Opt number (stack0)];
            Unload
         <u>end</u>  Optimize;


         <u>procedure</u>  Assign (metaparameter); <u>integer</u>  metaparameter;
         <u>begin</u>  metaparameter ≔ - (instruct counter - 1) <u>end</u>  Assign;


         <u>procedure</u>  Produce (macro, parameter); <u>integer</u>  macro, parameter;
         <u>begin</u>   <u>integer</u>  number, par number, entry, count;
            <u>if</u> macro = EMPTY <u>then</u>
              <u>else</u>
            <u>if</u> macro = CODE
              <u>then</u> <u>begin</u> space[prog base + instruct counter] ≔ parameter;
               instruct counter ≔ instruct counter + 1;
               test pointers
            <u>end</u>
            <u>else</u> <u>begin</u> number ≔ Instruct number (macro);
               par number ≔ Par part (macro);
               entry ≔ Instruct part (macro) - 1;
               <u>if</u> par number &gt; 0
                 <u>then</u> Process parameter (macro, parameter);
               Process stack pointer (macro);
               <u>for</u> count ≔ 1 <u>step</u> 1 <u>until</u> number <u>do</u>
                    Produce (CODE, instruct list[entry + count] +
                    (<u>if</u> count = par number
                    <u>then</u> parameter <u>else</u> 0))
            <u>end</u>
         <u>end</u>  Produce;






         <u>procedure</u>  Process stack pointer (macro); <u>integer</u>  macro;
         <u>begin</u>   <u>if</u> ¬ in code body
              <u>then</u>
            <u>begin</u> <u>integer</u>  reaction;
               reaction ≔ B reaction (macro);
               <u>if</u> reaction &lt; 9
                 <u>then</u> <u>begin</u> b ≔ b + reaction - 4;
                  <u>if</u> b &gt; max depth <u>then</u> max depth ≔ b
               <u>end</u>
                 <u>else</u>
               <u>if</u> reaction = 10 <u>then</u> b ≔ 0
                 <u>else</u>
               <u>if</u> reaction = 11 <u>then</u> b ≔ b - 2 × (dimension - 1)
                 <u>else</u>
               <u>if</u> reaction = 12
                 <u>then</u> <u>begin</u> <u>if</u> ecount = 0
                    <u>then</u>
                  <u>begin</u> ret level ≔ b;
                     ret max depth ≔ max depth;
                     b ≔ 0; max depth ≔ max depth isr
                  <u>end</u>;
                  ecount ≔ ecount + 1
               <u>end</u>
                 <u>else</u>
               <u>if</u> reaction = 13
                 <u>then</u> <u>begin</u> <u>if</u> macro = EXITSV
                    <u>then</u>
                  <u>begin</u> <u>if</u> b &gt; max depth isr
                       <u>then</u> max depth isr ≔ b;
                     b ≔ b - 2 × (dimension - 1)
                  <u>end</u>;
                  <u>if</u> ecount = 1
                    <u>then</u>
                  <u>begin</u> <u>if</u> max depth &gt; max depth isr
                       <u>then</u> max depth isr ≔ max depth;
                     b ≔ ret level;
                     max depth ≔ ret max depth
                  <u>end</u>;
                  <u>if</u> ecount &gt; 0 <u>then</u> ecount ≔ ecount - 1
               <u>end</u>
                 <u>else</u>
               <u>if</u> reaction = 14
                 <u>then</u> <u>begin</u> b ≔ display level + top of display;
                  <u>if</u> b &gt; max display length
                    <u>then</u> max display length ≔ b;
                  ret max depth ≔ max depth
               <u>end</u>
                 <u>else</u>
               <u>if</u> reaction = 15
                 <u>then</u> <u>begin</u> <u>if</u> b &gt; max proc level
                    <u>then</u> max proc level ≔ b;
                  b ≔ 0; max depth ≔ ret max depth
               <u>end</u>
            <u>end</u>
         <u>end</u>  Process stack pointer;






         <u>procedure</u>  Process parameter (macro, parameter);
            <u>integer</u>  macro, parameter;
         <u>begin</u>    <u>if</u> Value like (macro)
              <u>then</u>
            <u>begin</u> <u>if</u> macro = TBC
                 <u>then</u> parameter ≔ <u>if</u> parameter = true <u>then</u> 0 <u>else</u> 1
                 <u>else</u>
               <u>if</u> macro = SWP <u>then</u> parameter ≔ d9 × parameter
                 <u>else</u>
               <u>if</u> macro ≠ EXITSV <u>then</u> parameter ≔ abs (parameter)
            <u>end</u>
            <u>else</u>
            <u>begin</u> <u>if</u> macro = JU ∨ macro = SUBJ ∨ macro = NIL ∨ macro = LAST
                 <u>then</u> <u>begin</u> <u>if</u> parameter &LessSlantEqual; 0
                    <u>then</u> parameter ≔ - parameter
                  <u>else</u> parameter ≔ Program address (parameter)
               <u>end</u>
               <u>else</u> parameter ≔ Address (parameter) +
                 (<u>if</u> Dynamic (parameter)
                 <u>then</u> (<u>if</u> macro = TLV ∨ macro = TAA
                 <u>then</u> function digit
               <u>else</u> <u>if</u> macro = STST
                 <u>then</u> function letter
               <u>else</u> c variant)
               <u>else</u> 0)
            <u>end</u>
         <u>end</u> Process parameter;


         <u>Boolean</u> <u>procedure</u>  Simple arithmetic take macro;
         <u>begin</u>   Simple arithmetic take macro ≔ bit string (d1, d0, macro) = 1
         <u>end</u>  Simple arithmetic take macro;


         <u>Boolean</u> <u>procedure</u>  Optimizable operator;
         <u>begin</u>   Optimizable operator ≔ bit string (d2, d1, macro) = 1
         <u>end</u>  Optimizable operator;


         <u>Boolean</u> <u>procedure</u>  Forward jumping macro;
         <u>begin</u>   Forward jumping macro ≔ bit string (d3, d2, macro) = 1
         <u>end</u>  Forward jumping macro;


         <u>Boolean</u> <u>procedure</u>  Value like (macro); <u>integer</u> macro;
         <u>begin</u>   Value like ≔ bit string (d4, d3, macro) = 1 <u>end</u>  Value like;


         <u>integer</u> <u>procedure</u>  Opt number (macro); <u>integer</u> macro;
         <u>begin</u>   Opt number ≔ bit string (d8, d4, macro) <u>end</u>  Opt number;


         <u>integer</u> <u>procedure</u>  Instruct number (macro); <u>integer</u> macro;
         <u>begin</u>   Instruct number ≔ bit string (d10, d8, macro)
         <u>end</u>  Instruct number;






         <u>integer</u> <u>procedure</u>  Par part (macro); <u>integer</u>  macro;
         <u>begin</u>   Par part ≔ bit string (d12, d10, macro) <u>end</u> Par part;


         <u>integer</u> <u>procedure</u>  Instruct part (macro); <u>integer</u>  macro;
         <u>begin</u>   Instruct part ≔ bit string (d21, d12, macro) <u>end</u>  Instruct part;


         <u>integer</u> <u>procedure</u>  B reaction (macro); <u>integer</u>  macro;
         <u>begin</u>   B reaction ≔ macro ÷ d21 <u>end</u>  B reaction;


         <u>integer</u> <u>procedure</u>  Code bits (n); <u>integer</u>  n;
         <u>begin</u>   Code bits ≔ space[nl base - n] ÷ d19 <u>end</u>  Code bits;


         <u>integer</u> <u>procedure</u>  Character (n); <u>integer</u>  n;
         <u>begin</u>   Character ≔ bit string (d24, d19, space[nl base - n])
         <u>end</u>  Character;


         <u>Boolean</u> <u>procedure</u>  Arithmetic (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> i;
            i ≔ type bits (n);
            Arithmetic ≔ Character (n) ≠ 24 ∧ (i &lt; 2 ∨ i = 4)
         <u>end</u>  Arithmetic;


         <u>Boolean</u> <u>procedure</u>  Real (n); <u>integer</u>  n;
         <u>begin</u>   Real ≔ Character (n) ≠ 24 ∧ type bits (n) = 0 <u>end</u>  Real;


         <u>Boolean</u> <u>procedure</u>  Integer (n); <u>integer</u>  n;
         <u>begin</u>   Integer ≔ type bits (n) = 1 <u>end</u>  Integer;


         <u>Boolean</u> <u>procedure</u>  Boolean (n); <u>integer</u>  n;
         <u>begin</u>   Boolean ≔ type bits (n) = 2 <u>end</u>  Boolean;


         <u>Boolean</u> <u>procedure</u>  String (n); <u>integer</u>  n;
         <u>begin</u>   String ≔ type bits (n) = 3 <u>end</u>  String;


         <u>Boolean</u> <u>procedure</u>  Designational (n); <u>integer</u>  n;
         <u>begin</u>   Designational ≔ type bits (n) = 6 <u>end</u>  Designational;


         <u>Boolean</u> <u>procedure</u>  Arbost (n); <u>integer</u>  n;
         <u>begin</u>   Arbost ≔ Character (n) ≠ 24 ∧ type bits (n) &lt; 6 <u>end</u>  Arbost;


         <u>Boolean</u> <u>procedure</u>  Unknown (n); <u>integer</u>  n;
         <u>begin</u>   Unknown ≔ type bits (n) = 7 <u>end</u>  Unknown;






         <u>Boolean</u> <u>procedure</u>  Nonarithmetic (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> i;
            i ≔ type bits (n);
            Nonarithmetic ≔ Character (n) = 24 ∨ i = 2 ∨ i = 3 ∨ i = 6
         <u>end</u>  Nonarithmetic;


         <u>Boolean</u> <u>procedure</u>  Nonreal (n); <u>integer</u>  n;
         <u>begin</u>   Nonreal ≔ Nonarithmetic (n) ∨ type bits (n) = 1 <u>end</u>  Nonreal;


         <u>Boolean</u> <u>procedure</u>  Noninteger (n); <u>integer</u>  n;
         <u>begin</u>   Noninteger ≔ Nonarithmetic (n) ∨ type bits (n) = 0
         <u>end</u>  Noninteger;


         <u>Boolean</u> <u>procedure</u>  Nonboolean (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> i;
            i ≔ type bits (n); Nonboolean ≔ i ≠ 2 ∧ i ≠ 5 ∧ i ≠ 7
         <u>end</u>  Nonboolean;


         <u>Boolean</u> <u>procedure</u>  Nonstring (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u> i;
            i ≔ type bits (n); Nonstring ≔ i ≠ 3 ∧ i ≠ 5 ∧ i ≠ 7
         <u>end</u>  Nonstring;


         <u>Boolean</u> <u>procedure</u>  Nondesignational (n); <u>integer</u>  n;
         <u>begin</u>   Nondesignational ≔ type bits (n) &lt; 6 <u>end</u>  Nondesignational;


         <u>Boolean</u> <u>procedure</u>  Nontype (n); <u>integer</u>  n;
         <u>begin</u>   Nontype ≔ type bits (n) = 6 ∨ (Proc (n) ∧ Nonfunction (n))
         <u>end</u>  Nontype;


         <u>Boolean</u> <u>procedure</u>  Simple (n); <u>integer</u>  n;
         <u>begin</u>   Simple ≔ Code bits (n) = 127 ∨ Simple1 (n) <u>end</u>  Simple;


         <u>Boolean</u> <u>procedure</u>  Simple1 (n); <u>integer</u>  n;
         <u>begin</u>   Simple1 ≔ Character (n) ÷ d3 = 0 <u>end</u>  Simple1;


         <u>Boolean</u> <u>procedure</u>  Subscrvar (n); <u>integer</u>  n;
         <u>begin</u>   Subscrvar ≔ Character (n) ÷ d3 = 1 <u>end</u>  Subscrvar;


         <u>Boolean</u> <u>procedure</u>  Proc (n); <u>integer</u>  n;
         <u>begin</u>   Proc ≔ Character (n) ÷ d3 &gt; 1 ∧ Code bits (n) ≠ 127 <u>end</u>  Proc;


         <u>Boolean</u> <u>procedure</u>  Function (n); <u>integer</u>  n;
         <u>begin</u>   Function ≔ Character (n) ÷ d3 = 2 <u>end</u>  Function;






         <u>Boolean</u> <u>procedure</u>  Nonsimple (n); <u>integer</u>  n;
         <u>begin</u>   Nonsimple ≔ ¬ (Simple (n) ∨ (<u>if</u> Proc (n)
              <u>then</u> (Formal (n) ∨ Function (n)) ∧
              List length (n) &lt; 1
            <u>else</u> false ))
         <u>end</u>  Nonsirnple;


         <u>Boolean</u> <u>procedure</u>  Nonsubscrvar (n); <u>integer</u>  n;
         <u>begin</u>   Nonsubscrvar ≔ Simple1 (n) ∨ Proc (n) <u>end</u>  Nonsubscrvar;


         <u>Boolean</u> <u>procedure</u>  Nonproc (n); <u>integer</u>  n;
         <u>begin</u>   Nonproc ≔ ¬ (Character (n) ÷ d3 &GreaterSlantEqual; 2 ∨
              (Formal (n) ∧ Simple1 (n) ∧ ¬ Assigned to (n)))
         <u>end</u>  Nonproc;


         <u>Boolean</u> <u>procedure</u>  Nonfunction (n); <u>integer</u>  n;
         <u>begin</u>   Nonfunction ≔ ¬ (Function (n) ∨ Formal (n)) <u>end</u>  Nonfunction;


         <u>Boolean</u> <u>procedure</u>  Formal (n); <u>integer</u>  n;
         <u>begin</u>   Formal ≔ Code bits (n) &gt; 95 <u>end</u>  Formal;


         <u>Boolean</u> <u>procedure</u>  In value list (n); <u>integer</u>  n;
         <u>begin</u>   In value list ≔ Code bits (n) &gt; 63 ∧ ¬ Formal (n)
         <u>end</u>  In value list;


         <u>Boolean</u> <u>procedure</u>  Assigned to (n); <u>integer</u>  n;
         <u>begin</u>   Assigned to ≔ bit string (d19, d18, space[nl base - n]) = 1
         <u>end</u>  Assigned to;


         <u>Boolean</u> <u>procedure</u>  Dynamic (n); <u>integer</u>  n;
         <u>begin</u>   Dynamic ≔ Code bits (n) &gt; 63 ∨ Assigned to (n) <u>end</u>  Dynamic;


         <u>Boolean</u> <u>procedure</u>  In library (n); <u>integer</u>  n;
         <u>begin</u>   In library ≔ space[nl base - n - 1] &gt; d25 <u>end</u>  In library;


         <u>Boolean</u> <u>procedure</u>  Id1 (k, n); <u>integer</u>  k, n;
         <u>begin</u>   Id1 ≔ bit string (2 × k, k, space[nl base - n - 1]) = 1 <u>end</u>  Id1;


         <u>Boolean</u> <u>procedure</u>  Operator like (n); <u>integer</u>  n;
         <u>begin</u>   Operator like ≔ Id1 (d23, n) <u>end</u>  Operator like;


         <u>Boolean</u> <u>procedure</u>  Outside declaration (n); <u>integer</u>  n;
         <u>begin</u>   Outside declaration ≔ Id1 (d22, n) <u>end</u>  Outside declaration;






         <u>Boolean</u> <u>procedure</u>  Ass to function designator (n); <u>integer</u>  n;
         <u>begin</u>   Ass to function designator ≔ Id1 (d21, n)
         <u>end</u>  Ass to function designator;


         <u>Boolean</u> <u>procedure</u>  Declared (n); <u>integer</u>  n;
         <u>begin</u>   Declared ≔ Id1 (d19, n) <u>end</u>  Declared;


         <u>Boolean</u> <u>procedure</u>  Super local (n); <u>integer</u>  n;
         <u>begin</u>   Super local ≔ Id1 (d18, n) <u>end</u>  Super local;


         <u>procedure</u>  Change (k, n); <u>integer</u>  k, n;
         <u>begin</u>   <u>integer</u>  i, j;
            i ≔ space[nl base - n - 1]; j ≔ i - i ÷ (2 × k) × (2 × k);
            space[nl base - n - 1] ≔ i + (<u>if</u> j &lt; k <u>then</u> k <u>else</u> -k)
         <u>end</u>  Change;


         <u>integer</u> <u>procedure</u>  Local position (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u>  ¬ Ass to function designator (n) <u>then</u>  Change (d21, n);
            Local position ≔ Local position1 (n)
         <u>end</u>  Local position;


         <u>integer</u> <u>procedure</u>  Local position1 (n); <u>integer</u>  n;
         <u>begin</u>   Local position1 ≔ n + 2 <u>end</u>  Local position1;


         <u>procedure</u>  Set inside declaration (n, bool); <u>integer</u>  n; <u>Boolean</u>  bool;
         <u>begin</u>  Change (d22, n);
            <u>if</u>  ¬ (bool ∨ Ass to function designator (n))
              <u>then</u>  ERRORMESSAGE (390)
         <u>end</u>  Set inside declaration;






         <u>procedure</u>  Mark position in name list (n); <u>integer</u> n;
         <u>begin</u>   <u>integer</u>  address;
            <u>if</u> Declared (n)
              <u>then</u> ERRORMESSAGE (391)
            <u>else</u> <u>begin</u> address ≔ Program address (n);
               <u>if</u> address ≠ 0 <u>then</u> Substitute (address);
               Change (d19, n)
            <u>end</u>
         <u>end</u>  Mark position in name list;


         <u>integer</u> <u>procedure</u>  Program address (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  word, head, m;
            m ≔ <u>if</u> Code bits (n) = 6 <u>then</u> n + 1 <u>else</u> n;
            word ≔ space[nl base - m]; head ≔ word ÷ d18 × d18;
            <u>if</u> ¬ Declared (n)
              <u>then</u> space[nl base - m] ≔ head + Order counter;
            Program address ≔ word - head
         <u>end</u>  Program address;

         <u>integer</u> <u>procedure</u>  Address (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  word, tail, level;
            word ≔ Code bits (n);
            <u>if</u> word &gt; 13 ∧ word &lt; 25
              <u>then</u> tail ≔ Program address (n)
            <u>else</u> <u>begin</u> word ≔ space[nl base - n];
               tail ≔ word - word ÷ d18 × d18;
               <u>if</u> Dynamic (n)
                 <u>then</u> <u>begin</u> level ≔ tail ÷ d9;
                  <u>if</u> level = proc level ∧¬ in switch declaration
                    <u>then</u> tail ≔ tail + d9 × (63 - level)
               <u>end</u>
            <u>end</u>;
            Address ≔ tail
         <u>end</u>  Address;


         <u>integer</u> <u>procedure</u>  List length (n); <u>integer</u>  n;
         <u>begin</u>   List length ≔ bit string (d18, d0, space[nl base - n - 1]) - 1
         <u>end</u>  List length;


         <u>procedure</u>  Test for count (n); <u>integer</u>  n;
         <u>begin</u>   <u>if</u> space[nl base - n - 1] ÷ d20 &gt; for count
              <u>then</u> ERRORMESSAGE (392)
         <u>end</u>  Test for count;






         <u>procedure</u>  Check dimension (n); <u>integer</u>  n;
         <u>begin</u>   <u>integer</u>  i;
            i ≔ <u>if</u> Code bits (n) = 14 <u>then</u> 1 <u>else</u> List length (n);
            <u>if</u> i &GreaterSlantEqual; 0 ∧ i ≠ dimension <u>then</u> ERRORMESSAGE (393)
         <u>end</u>  Check dimension;


         <u>procedure</u>  Check list length (f, n); <u>integer</u>  f, n;
         <u>begin</u>   <u>integer</u>  i, j;
            i ≔ List length (f);
            j ≔ <u>if</u> Code bits (n) = 14 <u>then</u> 1 <u>else</u> List length (n);
            <u>if</u> i &GreaterSlantEqual; 0 ∧ j &GreaterSlantEqual; 0 ∧ i ≠ j <u>then</u> ERRORMESSAGE (394)
         <u>end</u> Check list length;


         <u>procedure</u>  Check type (f, n); <u>integer</u>  f, n;
         <u>begin</u>   <u>if</u> (Designational (f) ∧ Nondesignational (n)) ∨
              (Arbost (f)        ∧ Nontype (n))          ∨
              (Arithmetic (f)    ∧ Nonarithmetic (n))    ∨
              (Boolean (f)       ∧ Nonboolean (n))       ∨
              (String (f)        ∧ Nonstring (n))
              <u>then</u> ERRORMESSAGE (395)
         <u>end</u> Check type;


         <u>integer</u> <u>procedure</u>  Number of local labels;
         <u>begin</u>   Number of local labels ≔               bit string (d13, d0, space[nl base - block cell pointer - 3])
         <u>end</u>  Number of local labels;


         <u>integer</u> <u>procedure</u>  Next local label (n); <u>integer</u>  n;
         <u>begin</u>   Next local label ≔               <u>if</u> n = 0 <u>then</u> space[nl base - block cell pointer - 3] ÷ d13
            <u>else</u> next identifier (n)
         <u>end</u>  Next local label;


         <u>integer</u> <u>procedure</u>  Next formal identifier (n); <u>integer</u>  n;
         <u>begin</u>   Next formal identifier ≔               next identifier (n + (<u>if</u> Formal (n) ∨ In library (n) ∨
              In value list (n)
              <u>then</u> 2
            <u>else</u> <u>if</u> Function (n) <u>then</u> 9 <u>else</u> 8))
         <u>end</u>  Next formal identifier;


         <u>procedure</u>  Increase status (increment); <u>integer</u>  increment;
         <u>begin</u>   space[nl base - block cell pointer - 2] ≔               space[nl base - block cell pointer - 2] + increment
         <u>end</u>  Increase status;


         <u>integer</u> <u>procedure</u>  Identifier;
         <u>begin</u>   read identifier; Identifier ≔ look up <u>end</u>  Identifier;






         <u>procedure</u>  Skip parameter list;
         <u>begin</u>   <u>if</u> last symbol = open
              <u>then</u> <u>begin</u> next symbol; skip type declaration;
               <u>if</u> last symbol = close <u>then</u> next symbol
            <u>end</u>;
            <u>if</u> lastsymbol = semicolon <u>then</u> next symbol
         <u>end</u>  Skip parameter list;


         <u>procedure</u>  Translate code;
         <u>begin</u>   <u>integer</u>  macro, parameter;
            <u>if</u> last symbol = quote
              <u>then</u> <u>begin</u> in code body ≔ true;
               next: next symbol;
               <u>if</u> digit last symbol
                 <u>then</u>
               <u>begin</u> macro ≔ unsigned integer (0);
                  <u>if</u> macro &lt; 512 <u>then</u> macro ≔ macro list[macro];
                  <u>if</u> Par part (macro) &gt; 0
                    <u>then</u>
                  <u>begin</u> <u>if</u> last symbol = comma
                       <u>then</u> next symbol
                     <u>else</u> ERRORMESSAGE (396);
                     <u>if</u> letter last symbol
                       <u>then</u> parameter ≔ Identifier
                       <u>else</u>
                     <u>if</u> digit last symbol
                       <u>then</u> parameter ≔ unsigned integer (0)
                       <u>else</u>
                     <u>if</u> last symbol = minus
                       <u>then</u>
                     <u>begin</u> next symbol;
                        <u>if</u> digit last symbol
                          <u>then</u> parameter ≔                           - unsigned integer (0)
                        <u>else</u> ERRORMESSAGE (397)
                     <u>end</u>
                     <u>else</u> ERRORMESSAGE (398);
                     Macro2 (macro, parameter)
                  <u>end</u>
                  <u>else</u> Macro (macro)
               <u>end</u>
               <u>else</u> ERRORMESSAGE (399);
               <u>if</u> last symbol = comma <u>then</u> <u>goto</u> next;
               <u>if</u> last symbol = unquote <u>then</u> next symbol
               <u>else</u> ERRORMESSAGE (400);
               in code body ≔ false
            <u>end</u>
            <u>else</u> ERRORMESSAGE (401);
            entrance block; exit block
         <u>end</u> Translate code;






         <u>procedure</u>  Unsigned number;
         <u>begin</u>   <u>integer</u>  p;
            unsigned number;
            <u>if</u> ¬ small
              <u>then</u> <u>begin</u> p ≔ 0;
               next: <u>if</u> p = dp0 <u>then</u> <u>goto</u> found;
               <u>if</u> space[prog base + p] ≠ value of constant ∨
                 space[prog base + p + 1] ≠ decimal exponent
                 <u>then</u> <u>begin</u> p ≔ p + 2; <u>goto</u> next <u>end</u>;
               found: address of constant ≔ p
            <u>end</u>
         <u>end</u>  Unsigned number;


         <u>procedure</u>  Arithconstant;
         <u>begin</u>   <u>if</u> small <u>then</u> Macro2 (TSIC, value of constant)
              <u>else</u>
            <u>if</u> real number <u>then</u> Macro2 (TRC, address of constant)
            <u>else</u> Macro2 (TIC, address of constant)
         <u>end</u>  Arithconstant;


         <u>integer</u> <u>procedure</u>  Operator macro (n); <u>integer</u>  n;
         <u>begin</u>   Operator macro ≔ space[nl base - n - 2] <u>end</u>  Operator macro;


         <u>procedure</u>  Constant string;
         <u>begin</u>   <u>integer</u> word, count;
            quote counter ≔ 1;
            next0:  word ≔ count ≔ 0;
            next1:  next symbol;
            <u>if</u> last symbol ≠ unquote
              <u>then</u> <u>begin</u> word ≔ d8 × word + last symbol;
               count ≔ count + 1;
               <u>if</u> count = 3
                 <u>then</u> <u>begin</u> Macro2(CODE, word); <u>goto</u> next0 <u>end</u>;
               <u>goto</u> next1
            <u>end</u>;
            next2:  word ≔ d8 × word + 255; count ≔ count + 1;
            <u>if</u> count &lt; 3 <u>then</u> <u>goto</u> next2;
            Macro2 (CODE, word); quote counter ≔ 0; next symbol
         <u>end</u>  Constant string;


         <u>integer</u> <u>procedure</u>  Relatmacro;
         <u>begin</u>   Relatmacro ≔  <u>if</u> last symbol = les <u>then</u> LES <u>else</u>
              <u>if</u> last symbol = mst <u>then</u> MST <u>else</u>
              <u>if</u> last symbol = mor <u>then</u> MOR <u>else</u>
              <u>if</u> last symbol = lst <u>then</u> LST <u>else</u>
              <u>if</u> last symbol = equ <u>then</u> EQU <u>else</u> UQU
         <u>end</u>  Relatmacro;






         main program of translate scan:
         <u>if</u> ¬ text in memory
           <u>then</u> <u>begin</u> NEWPAGE;
            PRINTTEXT (“input tape for translate scan”)
         <u>end</u>;
         start ≔ instruct counter; last nlp ≔ nlp;
         runnumber ≔ 300; init; increment ≔ d13;
         state ≔ b ≔ max depth ≔ max depth isr ≔            max display length ≔ max proc level ≔ ecount ≔ 0;
         in switch declaration ≔ in code body ≔ false;
         next block cell pointer ≔ 0;
         entrance block; next symbol;
         Program;
         sum of maxima ≔ max depth + max depth isr +
           max display length + max proc level;
         Macro2 (CODE, sum of maxima);
         output
      <u>end</u> translate;






      <u>procedure</u>  output;
      <u>begin</u>   <u>integer</u>  i, k, apostrophe, instruct number, par, address;

         <u>procedure</u>  pucar (n); <u>integer</u>  n;
         <u>begin</u>  <u>integer</u> i;
            <u>for</u> i ≔ 1 <u>step</u> 1 <u>until</u> n <u>do</u> PUNLCR
         <u>end</u>  pucar;

         <u>procedure</u>  tabspace (n); <u>integer</u>  n;
         <u>begin</u>  <u>integer</u> i, k;
            k ≔ n ÷ 8;
            <u>for</u> i ≔ 1 <u>step</u> 1 <u>until</u> k <u>do</u> PUSYM (118);
            PUSPACE (n - k × 8)
         <u>end</u>  tabspace;

         <u>procedure</u>  absfixp (k); <u>integer</u>  k;
         <u>begin</u>  ABSFIXP (4, 0, k); pucar (2) <u>end</u>  absfixp;

         <u>procedure</u>  punch (bool); <u>Boolean</u>  bool;
         <u>begin</u>  <u>if</u> bool <u>then</u> PUTEXT (“ true”)
            <u>else</u> PUTEXT (“false”);
            pucar (2)
         <u>end</u>  punch;

         <u>procedure</u>  punch octal (n);  <u>value</u> n;  <u>integer</u>  n;
         <u>begin</u>  <u>integer</u>  i, k;
            <u>Boolean</u>  minussign;
            minussign ≔ n &lt; 0; n ≔ abs (n);
            PUSYM (<u>if</u> minussign <u>then</u> minus <u>else</u> plus);
            PUSYM (apostrophe);
            <u>for</u> i ≔ d24, d21, d18, d15, d12, d9, d6, d3, d0 <u>do</u>
               <u>begin</u> k ≔ n ÷ i; n ≔ n - k × i; PUSYM (k) <u>end</u>;
            PUSYM (apostrophe)
         <u>end</u>  punch octal;

         apostrophe ≔ 120;
         PUNLCR;
         <u>if</u> runnumber = 100
           <u>then</u>
         <u>begin</u> tabspace (22); PUTEXT (“prescan0”); pucar (2);
            PUTEXT (“erroneous”); PUSPACE (14);
            punch (erroneous); PUTEXT (“text length”);
            PUSPACE (12);
            absfixp (<u>if</u> text in memory <u>then</u> text pointer + 1 <u>else</u> 0);
            PUTEXT (“namelist”); pucar(2);
            <u>for</u> i ≔ 0 <u>step</u> 1 <u>until</u> nlp - 1 <u>do</u>
               <u>begin</u> tabspace (7); ABSFIXP (4, 0, i); PUSPACE(5);
                  punch octal (space[nl base - i]); PUNLCR
               <u>end</u>;
            STOPCODE;
            PUNLCR; PUTEXT (“dp0”); pucar (2);
            PUTEXT (“start”); pucar (2);
            PUTEXT (“program”); pucar (2);




            <u>for</u> i ≔ prog base <u>step</u> 1 <u>until</u> instruct counter - 1 <u>do</u>
               <u>begin</u> tabspace (7); ABSFIXP (4, 0, i);
                  FIXP (16, 0, space[i]); PUNLCR
               <u>end</u>;
            RUNOUT; STOPCODE
         <u>end</u>
           <u>else</u> <u>if</u> runnumber = 200
           <u>then</u>
         <u>begin</u> tabspace (38); PUTEXT (“prescan1”); pucar (2);
            tabspace (39); punch (erroneous); tabspace (39);
            absfixp (<u>if</u> text in memory <u>then</u> text pointer + 1 <u>else</u> 0);
            pucar (2);
            <u>for</u> i ≔ 0 <u>step</u> 1 <u>until</u> nlp - 1 <u>do</u>
               <u>begin</u> tabspace (34); punch octal (space[nl base - i]);
                  PUNLCR
               <u>end</u>;
            STOPCODE; pucar (7);
            <u>for</u> i ≔ prog base <u>step</u> 1 <u>until</u> instruct counter - 1 <u>do</u>
               <u>begin</u> tabspace (32); FIXP (13, 0, space[i]); PUNLCR <u>end</u>;
            RUNOUT; STOPCODE
         <u>end</u>
         <u>else</u>
         <u>begin</u> tabspace (54); PUTEXT (“translate”); pucar (2);
            tabspace (55); punch (erroneous); tabspace (55);
            absfixp (<u>if</u> text in memory <u>then</u> text pointer + 1 <u>else</u> 0);
            pucar (2);
            <u>for</u> i ≔ 0 <u>step</u> 1 <u>until</u> nlp - 1 <u>do</u>
               <u>begin</u> tabspace (50); punch octal (space[nl base - i]);
                  PUSPACE (2); ABSFIXP (4, 0, i); PUNLCR
               <u>end</u>;
            STOPCODE; PUNLCR;
            tabspace (55); absfixp (dp0);
            tabspace (55); absfixp (start); pucar (2);
            <u>for</u> i ≔ prog base <u>step</u> 1 <u>until</u> start - 1 <u>do</u>
               <u>begin</u> tabspace (48); FIXP(13, 0, space[i]);
                  PUSPACE (2); ABSFIXP (4, 0, i); PUNLCR
               <u>end</u>;
            PUNLCR;
            <u>for</u> i ≔ start <u>step</u> 1 <u>until</u> instruct counter - 1 <u>do</u>
               <u>begin</u> k ≔ space[i]; par ≔ k ÷ 32768;
                  address ≔ k - par × 32768;
                  instruct number ≔ par ÷ 10;
                  par ≔ par - instruct number × 10;
                  tabspace (48); ABSFIXP (3, 0, instruct number);
                  ABSFIXP (1, 0, par); ABSFIXP (5, 0, address);
                  PUSPACE (2); ABSFIXP (4, 0, i) ; PUNLCR
               <u>end</u>
         <u>end</u>
      <u>end</u>  output;






      main program:
      <u>for</u> n ≔ 0 <u>step</u> 1 <u>until</u> end of memory <u>do</u> space[n] ≔ 0;
      instruct counter ≔ prog base ≔ nlp ≔ 0;
      text base ≔ end of memory ÷ 3;
      nl base ≔ end of memory;


      prescan0;
      <u>if</u> ¬ derroneous
        <u>then</u> <u>begin</u>  prescan1;
         translate
      <u>end</u>;

      endrun:
   <u>end</u>
<u>end</u>

</pre></body></html>
