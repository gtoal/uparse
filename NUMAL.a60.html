<html><head><meta charset="utf-8"></head><body><pre><u>comment</u> ================== 34010 ================= ;
<u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>value</u> L, U, SHIFT;
   <u>integer</u> L, U, SHIFT; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[K] × B[SHIFT + K] + S;
   VECVEC ≔ S
<u>end</u> VECVEC;
<u>comment</u> ================== 34011 ================= ;
<u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>value</u> L, U, I;
   <u>integer</u> L, U, I; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[I, K] × B[K] + S;
   MATVEC ≔ S
<u>end</u> MATVEC;
<u>comment</u> ================== 34012 ================= ;
<u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>value</u> L, U, I;
   <u>integer</u> L, U, I; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[K, I] × B[K] + S;
   TAMVEC ≔ S
<u>end</u> TAMVEC;
<u>comment</u> ================== 34013 ================= ;
<u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>value</u> L, U, I, J;
   <u>integer</u> L, U, I, J; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[I, K] × B[K, J] + S;
   MATMAT ≔ S
<u>end</u> MATMAT;
<u>comment</u> ================== 34014 ================= ;
<u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>value</u> L, U, I, J;
   <u>integer</u> L, U, I, J; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[K, I] × B[K, J] + S;
   TAMMAT ≔ S
<u>end</u> TAMMAT;
<u>comment</u> ================== 34015 ================= ;
<u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>value</u> L, U, I, J;
   <u>integer</u> L, U, I, J; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K; <u>real</u> S;
   S ≔ 0;
   <u>for</u> K ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ A[I, K] × B[J, K] + S;
   MATTAM ≔ S
<u>end</u> MATTAM;
<u>comment</u> ================== 34016 ================= ;
<u>real</u> <u>procedure</u> SEQVEC(L, U, IL, SHIFT, A, B);
   <u>value</u> L, U, IL, SHIFT; <u>integer</u> L, U, IL, SHIFT; <u>array</u> A, B;
<u>begin</u> <u>real</u> S;
   S ≔ 0;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> S ≔ A[IL] × B[L + SHIFT] + S; IL ≔ IL + L <u>end</u>;
   SEQVEC ≔ S
<u>end</u> SEQVEC;
<u>comment</u> ================== 34017 ================= ;
<u>real</u> <u>procedure</u> SCAPRD1(LA, SA, LB, SB, N, A, B);
   <u>value</u> LA, SA, LB, SB, N; <u>integer</u> LA, SA, LB, SB, N; <u>array</u> A, B;
<u>begin</u> <u>real</u> S; <u>integer</u> K;
   S ≔ 0;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> S ≔ A[LA] × B[LB] + S; LA ≔ LA + SA; LB ≔ LB + SB <u>end</u>;
   SCAPRD1 ≔ S
<u>end</u> SCAPRD1;
<u>comment</u> ================== 34018 ================= ;
<u>real</u> <u>procedure</u> SYMMATVEC(L, U, I, A, B); <u>value</u> L, U, I;
   <u>integer</u> L, U, I; <u>array</u> A, B;
<u>begin</u> <u>integer</u> K, M;
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> SEQVEC(L, U, IL, SHIFT, A, B); <u>code</u> 34016;
   M ≔ <u>if</u> L &gt; I <u>then</u> L <u>else</u> I; K ≔ M × (M - 1) ÷ 2;
   SYMMATVEC ≔ VECVEC(L, <u>if</u> I &LessSlantEqual; U <u>then</u> I-1 <u>else</u> U, K, B, A)
     + SEQVEC(M, U, K + I, 0, A, B)
<u>end</u> SYMMATVEC;
<u>comment</u> ================== 31500 ================= ;
<u>procedure</u> FULMATVEC(LR, UR, LC, UC, A, B, C);
   <u>value</u> LR, UR, LC, UC, B; <u>integer</u> LR, UR, LC, UC;
     <u>array</u> A, B, C;
<u>begin</u> <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        C[LR] ≔ MATVEC(LC, UC, LR, A, B);
<u>end</u> FULMATVEC;
<u>comment</u> ================== 31501 ================= ;
<u>procedure</u> FULTAMVEC(LR, UR, LC, UC, A, B, C);
   <u>value</u> LR, UR, LC, UC, B; <u>integer</u> LR, UR, LC, UC;
     <u>array</u> A, B, C;
<u>begin</u> <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
        C[LC] ≔ TAMVEC(LR, UR, LC, A, B);
<u>end</u> FULTAMVEC;
<u>comment</u> ================== 31502 ================= ;
<u>procedure</u> FULSYMMATVEC(LR, UR, LC, UC, A, B, C);
   <u>value</u> LR, UR, LC, UC, B; <u>integer</u> LR, UR, LC, UC;
     <u>array</u> A, B, C;
<u>begin</u> <u>real</u> <u>procedure</u> SYMMATVEC(L, U, I, A, B);
      <u>code</u> 34018;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        C[LR] ≔ SYMMATVEC(LC, UC, LR, A, B)
<u>end</u> FULSYMMATVEC;
<u>comment</u> ================== 31503 ================= ;
<u>procedure</u> RESVEC(LR, UR, LC, UC, A, B, C, X);
   <u>value</u> LR, UR, LC, UC, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> A, B, C;
<u>begin</u> <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        C[LR] ≔ MATVEC(LC, UC, LR, A, B) + C[LR] × X
<u>end</u> RESVEC;
<u>comment</u> ================== 31504 ================= ;
<u>procedure</u> SYMRESVEC(LR, UR, LC, UC, A, B, C, X);
   <u>value</u> LR, UR, LC, UC, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> A, B, C;
<u>begin</u> <u>real</u> <u>procedure</u> SYMMATVEC(L, U, I, A, B);
      <u>code</u> 34018;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        C[LR] ≔ SYMMATVEC(LC, UC, LR, A, B) + C[LR] × X
<u>end</u> SYMRESVEC;
<u>comment</u> ================== 34214 ================= ;
<u>real</u> <u>procedure</u> RNK1MIN(N, X, G, H, FUNCT, IN, OUT);
   <u>value</u> N;
   <u>integer</u> N; <u>array</u> X, G, H, IN, OUT;
     <u>real</u> <u>procedure</u> FUNCT;
<u>begin</u> <u>integer</u> I, IT, N2, CNTL, CNTE, EVL, EVLMAX;
   <u>Boolean</u> OK;
   <u>real</u> F, F0, FMIN, MU, DG, DG0, GHG, GS, NRMDELTA, ALFA,
     MACHEPS, RELTOL, ABSTOL, EPS, TOLG, ORTH, AID;
   <u>array</u> V, DELTA, GAMMA, S, P[1:N];
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   <u>real</u> <u>procedure</u> SYMMATVEC(L, U, I, A, B); <u>code</u> 34018;
   <u>procedure</u> INIVEC(L, U, A, X); <u>code</u> 31010;
   <u>procedure</u> INISYMD(LR, UR, SHIFT, A, X); <u>code</u> 31013;
   <u>procedure</u> MULVEC(L, U, SHIFT, A, B, X); <u>code</u> 31020;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B); <u>code</u> 31030;
   <u>procedure</u> EIGSYM1(A, N, NUMVAL, VAL, VEC, EM); <u>code</u> 34156;
   <u>procedure</u> LINEMIN(N, X, D, ND, A, G, F, F0, F1, DFO, DF1,
     E, S, IN); <u>code</u> 34210;
   <u>procedure</u> RNK1UPD(H, N, V, C); <u>code</u> 34211;
   <u>procedure</u> DAVUPD(H, N, V, W, C1, C2); <u>code</u> 34212;
   <u>procedure</u> FLEUPD(H, N, V, W, C1, C2); <u>code</u> 34213;

   MACHEPS ≔ IN[0]; RELTOL ≔ IN[1]; ABSTOL ≔ IN[2];
   MU ≔ IN[3]; TOLG ≔ IN[4]; FMIN ≔ IN[5]; IT ≔ 0;
   ALFA ≔ IN[6]; EVLMAX ≔ IN[7]; ORTH ≔ IN[8];
   N2 ≔ N × (N + 1) ÷ 2; CNTL ≔ CNTE ≔ 0; <u>if</u> ALFA &gt; 0 <u>then</u>
   <u>begin</u> INIVEC(1, N2, H, 0); INISYMD(1, N, 0, H, ALFA) <u>end</u>;
   F ≔ FUNCT(N, X, G); EVL ≔ 1; DG ≔ SQRT(VECVEC(1, N, 0, G, G));
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        DELTA[I] ≔ - SYMMATVEC(1, N, I, H, G);
   NRMDELTA ≔ SQRT(VECVEC(1, N, 0, DELTA, DELTA));
   DG0 ≔ VECVEC(1, N, 0, DELTA, G); OK ≔ DG0 &lt; 0;
   EPS ≔ SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL;
   <u>for</u> IT ≔ IT + 1  <u>while</u>
     (NRMDELTA &gt; EPS ∨ DG &gt; TOLG ∨ ¬OK) ∧ EVL &lt; EVLMAX
     <u>do</u>
      <u>begin</u> <u>if</u> ¬OK <u>then</u>
         <u>begin</u> <u>array</u> VEC[1:N, 1:N], TH[1:N2], EM[0:9];
            EM[0] ≔ MACHEPS; EM[2] ≔ AID ≔ SQRT(MACHEPS × RELTOL);
            EM[4] ≔ ORTH; EM[6] ≔ AID × N; EM[8] ≔ 5;
            CNTE ≔ CNTE + 1; DUPVEC(1, N2, 0, TH, H);
            EIGSYM1(TH, N, N, V, VEC, EM);
            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> AID ≔ - TAMVEC(1, N, I, VEC, G);
                  S[I] ≔ AID × ABS(V[I]); V[I] ≔ AID × SIGN(V[I])
               <u>end</u>;

            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> DELTA[I] ≔ MATVEC(1, N, I, VEC, S);
                  P[I] ≔ MATVEC(1, N, I, VEC, V)
               <u>end</u>;
            DG0 ≔ VECVEC(1, N, 0, DELTA, G);
            NRMDELTA ≔ SQRT(VECVEC(1, N, 0, DELTA, DELTA))
         <u>end</u> CALCULATING GREENSTADTS DIRECTION;
         DUPVEC(1, N, 0, S, X); DUPVEC(1, N, 0, V, G);
         <u>if</u> IT &gt; N <u>then</u> ALFA ≔ 1 <u>else</u>
         <u>begin</u> <u>if</u> IT ≠ 1 <u>then</u> ALFA ≔ ALFA / NRMDELTA <u>else</u>
            <u>begin</u> ALFA ≔ 2 × (FMIN - F) / DG0;
               <u>if</u> ALFA &gt; 1 <u>then</u> ALFA ≔ 1
            <u>end</u>
         <u>end</u>;
         ELMVEC(1, N, 0, X, DELTA, ALFA);
         F0 ≔ F; F ≔ FUNCT(N, X, G); EVL ≔ EVL + 1 ;
         DG ≔ VECVEC(1, N, 0, DELTA, G);
         <u>if</u> IT = 1 ∨ F0 - F &lt; -MU × DG0 × ALFA <u>then</u>
         <u>begin</u> I ≔ EVLMAX - EVL; CNTL ≔ CNTL + 1 ;
            LINEMIN(N, S, DELTA, NRMDELTA, ALFA, G, FUNCT, F0, F,
              DG0, DG, I, <u>false</u>, IN); EVL ≔ EVL + I;
            DUPVEC(1, N, 0, X, S);
         <u>end</u> LINEMINIMIZATION;
         DUPVEC(1, N, 0, GAMMA, G); ELMVEC(1, N, 0, GAMMA, V, -1);
         <u>if</u> ¬OK <u>then</u> MULVEC(1, N, 0, V, P, -1);
         DG ≔ DG - DG0; <u>if</u> ALFA ≠ 1 <u>then</u>
         <u>begin</u> MULVEC(1, N, 0, DELTA, DELTA, ALFA);
            MULVEC(1, N, 0, V, V, ALFA);
            NRMDELTA ≔ NRMDELTA × ALFA; DG ≔ DG × ALFA
         <u>end</u>;
         DUPVEC(1, N, 0, P, GAMMA); ELMVEC(1, N, 0, P, V, 1);
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              V[I] ≔ SYMMATVEC(1, N, I, H, GAMMA);
         DUPVEC(1, N, 0, S, DELTA); ELMVEC(1, N, 0, S, V, -1);
         GS ≔ VECVEC(1, N, 0, GAMMA, S);
         GHG ≔ VECVEC(1, N, 0, V, GAMMA);
         AID ≔ DG / GS;
         <u>if</u> VECVEC(1, N, 0, DELTA, P) ⭡ 2 &gt; VECVEC(1, N, 0, P, P)× (ORTH × NRMDELTA) ⭡ 2 <u>then</u> RNK1UPD(H, N, S, 1 / GS)
           <u>else</u> <u>if</u> AID &GreaterSlantEqual; 0 <u>then</u>
           FLEUPD(H, N, DELTA, V, 1 / DG, (1 + GHG / DG) / DG) <u>else</u>
           DAVUPD(H, N, DELTA, V, 1 / DG, 1 / GHG);
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              DELTA[I] ≔ -SYMMATVEC(1, N, I, H, G);
         ALFA ≔ NRMDELTA;
         NRMDELTA ≔ SQRT(VECVEC(1, N, 0, DELTA, DELTA));
         EPS ≔ SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL;
         DG ≔ SQRT(VECVEC(1, N, 0, G, G));
         DG0 ≔ VECVEC(1, N, 0, DELTA, G); OK ≔ DG0 &LessSlantEqual; 0
      <u>end</u> ITERATION;
   OUT[0] ≔ NRMDELTA; OUT[1] ≔ DG; OUT[2] ≔ EVL;
   OUT[3] ≔ CNTL; OUT[4] ≔ CNTE; RNK1MIN ≔ F
<u>end</u> RNK1MIN;
<u>comment</u> ================== 34215 ================= ;
<u>real</u> <u>procedure</u> FLEMIN(N, X, G, H, FUNCT, IN, OUT);
   <u>value</u> N;
   <u>integer</u> N; <u>array</u> X, G, H, IN, OUT;
     <u>real</u> <u>procedure</u> FUNCT;
<u>begin</u> <u>integer</u> I, IT, CNTL, EVL, EVLMAX;
   <u>real</u> F, F0, FMIN, MU, DG, DG0, NRMDELTA, ALFA, RELTOL, ABSTOL,
     EPS, TOLG, AID;
   <u>array</u> V, DELTA, S[1:N];
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   <u>real</u> <u>procedure</u> SYMMATVEC(L, U, I, A, B); <u>code</u> 34018;
   <u>procedure</u> INIVEC(L, U, A, X); <u>code</u> 31010;
   <u>procedure</u> INISYMD(LR, UR, SHIFT, A, X); <u>code</u> 31013;
   <u>procedure</u> MULVEC(L, U, SHIFT, A, B, XB); <u>code</u> 31020;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B); <u>code</u> 31030;
   <u>procedure</u> LINEMIN(N, X, D, ND, A, G, F, F0, F1, DF0, DF1,
     E, S, IN); <u>code</u> 34210;
   <u>procedure</u> DAVUPD(H, N, V, W, C1, C2); <u>code</u> 34212;
   <u>procedure</u> FLEUPD(H, N, V, W, C1, C2); <u>code</u> 34213;

   RELTOL ≔ IN[1]; ABSTOL ≔ IN[2]; MU ≔ IN[3];
   TOLG ≔ IN[4]; FMIN ≔ IN[5]; ALFA ≔ IN[6];
   EVLMAX ≔ IN[7]; OUT[4] ≔ 0; IT ≔ 0;
   F ≔ FUNCT(N, X, G); EVL ≔ 1; CNTL ≔ 0; <u>if</u> ALFA &gt; 0 <u>then</u>
   <u>begin</u> INIVEC(1, N × (N + 1) ÷ 2, H, 0);
      INISYMD(1, N, 0, H, ALFA)
   <u>end</u>;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        DELTA[I] ≔ - SYMMATVEC(1, N, I, H, G);
   DG ≔ SQRT(VECVEC(1, N, 0, G, G));
   NRMDELTA ≔ SQRT(VECVEC(1, N, 0, DELTA, DELTA));
   EPS ≔ SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL;
   DG0 ≔ VECVEC(1, N, 0, DELTA, G);
   <u>for</u> IT ≔ IT + 1  <u>while</u>
     (NRMDELTA &gt; EPS ∨ DG &gt; TOLG ) ∧ EVL &lt; EVLMAX <u>do</u>
      <u>begin</u> DUPVEC(1, N, 0, S, X); DUPVEC(1, N, 0, V, G);
         <u>if</u> IT &GreaterSlantEqual; N <u>then</u> ALFA ≔ 1 <u>else</u>
         <u>begin</u> <u>if</u> IT ≠ 1 <u>then</u> ALFA ≔ ALFA / NRMDELTA <u>else</u>
            <u>begin</u> ALFA ≔ 2 × (FMIN - F) / DG0;
               <u>if</u> ALFA &gt; 1 <u>then</u> ALFA ≔ 1
            <u>end</u>
         <u>end</u>;
         ELMVEC(1, N, 0, X, DELTA, ALFA);
         F0 ≔ F; F ≔ FUNCT(N, X, G); EVL ≔ EVL + 1 ;
         DG ≔ VECVEC(1, N, 0, DELTA, G);
         <u>if</u> IT = 1 ∨ F0 - F &lt; - MU × DG0 × ALFA <u>then</u>
         <u>begin</u> I ≔ EVLMAX - EVL; CNTL ≔ CNTL + 1 ;
            LINEMIN(N, S, DELTA, NRMDELTA, ALFA, G, FUNCT, F0, F,
              DG0, DG, I, <u>false</u>, IN); EVL ≔ EVL + I;
            DUPVEC(1, N, 0, X, S);
         <u>end</u> LINEMINIMIZATION;
         <u>if</u> ALFA ≠ 1 <u>then</u> MULVEC(1, N, 0, DELTA, DELTA, ALFA);
         MULVEC(1, N, 0, V, V, -1); ELMVEC(1, N, 0, V, G, 1);
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              S[I] ≔ SYMMATVEC(1, N, I, H, V);
         AID ≔ VECVEC(1, N, 0, V, S); DG ≔ (DG - DG0) × ALFA;
         <u>if</u> DG &gt; 0 <u>then</u>
         <u>begin</u> <u>if</u> DG &GreaterSlantEqual; AID <u>then</u>
              FLEUPD(H, N, DELTA, S, 1 / DG, (1 + AID / DG) / DG)
            <u>else</u> DAVUPD(H, N, DELTA, S, 1 / DG, 1 / AID)
         <u>end</u> UPDATING;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              DELTA[I] ≔ -SYMMATVEC(1, N, I, H, G);
         ALFA ≔ NRMDELTA × ALFA;
         NRMDELTA ≔ SQRT(VECVEC(1, N, 0, DELTA, DELTA));
         EPS ≔ SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL;
         DG ≔ SQRT(VECVEC(1, N, 0, G, G));
         DG0 ≔ VECVEC(1, N, 0, DELTA, G); <u>if</u> DG0 &gt; 0 <u>then</u>
         <u>begin</u> OUT[4] ≔ -1 ; <u>goto</u> EXIT <u>end</u>
      <u>end</u> ITERATION;
   EXIT: OUT[0] ≔ NRMDELTA; OUT[1] ≔ DG; OUT[2] ≔ EVL;
   OUT[3] ≔ CNTL; FLEMIN ≔ F
<u>end</u> FLEMIN;
<u>comment</u> ================== 34352 ================= ;
<u>procedure</u> COMCOLCST(L, U, J, AR, AI, XR, XI);
   <u>value</u> L, U, J, XR, XI; <u>integer</u> L, U, J; <u>real</u> XR, XI;
     <u>array</u> AR, AI;
<u>begin</u>
   <u>procedure</u> COMMUL(AR, AI, BR, BI, RR, RI); <u>code</u> 34341;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
        COMMUL(AR[L, J], AI[L, J], XR, XI, AR[L, J], AI[L, J]);
<u>end</u> COMCOLCST;
<u>comment</u> ================== 34353 ================= ;
<u>procedure</u> COMROWCST(L, U, I, AR, AI, XR, XI);
   <u>value</u> L, U, I, XR, XI; <u>integer</u> L, U, I; <u>real</u> XR, XI;
     <u>array</u> AR, AI;
<u>begin</u>
   <u>procedure</u> COMMUL(AR, AI, BR, BI, RR, RI); <u>code</u> 34341;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> COMMUL(AR[I, L], AI[I, L], XR,
        XI, AR[I, L], AI[I, L]);
<u>end</u> COMROWCST;
<u>comment</u> ================== 34354 ================= ;
<u>procedure</u> COMMATVEC(L, U, I, AR, AI, BR, BI, RR, RI);
   <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>real</u> RR, RI;
     <u>array</u> AR, AI, BR, BI;
<u>begin</u> <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> MV;
   MV ≔ MATVEC(L, U, I, AR, BR) - MATVEC(L, U, I, AI, BI);
   RI ≔ MATVEC(L, U, I, AI, BR) + MATVEC(L, U, I, AR, BI);
   RR ≔ MV
<u>end</u> COMMATVEC;
<u>comment</u> ================== 34355 ================= ;
<u>Boolean</u> <u>procedure</u> HSHCOMCOL(L, U, J, AR, AI, TOL, K, C, S, T);
   <u>value</u> L, U, J, TOL; <u>integer</u> L, U, J; <u>real</u> TOL, K, C, S, T;
     <u>array</u> AR, AI;
<u>begin</u> <u>real</u> VR, DEL, MOD, H, ARLJ, AILJ;
   <u>procedure</u> CARPOL(AR, AI, R, C, S); <u>code</u> 34344;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   VR ≔ TAMMAT(L + 1, U, J, J, AR, AR) + TAMMAT(L + 1, U,
     J, J, AI, AI); ARLJ ≔ AR[L, J]; AILJ ≔ AI[L, J];
   CARPOL(ARLJ, AILJ, MOD, C, S); <u>if</u> VR &gt; TOL <u>then</u>
   <u>begin</u> VR ≔ VR + ARLJ ⭡ 2 + AILJ ⭡ 2; H ≔ K ≔ SQRT(VR);
      T ≔ VR + MOD × H;
      <u>if</u> ARLJ = 0 ∧ AILJ = 0 <u>then</u> AR[L, J] ≔ H <u>else</u>
      <u>begin</u> AR[L, J] ≔ ARLJ + C × K; AI[L, J] ≔ AILJ + S × K;
         S ≔ - S
      <u>end</u>;
      C ≔ - C; HSHCOMCOL ≔ <u>true</u>
   <u>end</u>
   <u>else</u>
   <u>begin</u> HSHCOMCOL ≔ <u>false</u>; K ≔ MOD; T ≔ - 1 <u>end</u>
<u>end</u> HSHCOMCOL;
<u>comment</u> ================== 34356 ================= ;
<u>procedure</u> HSHCOMPRD(I, II, L, U, J, AR, AI, BR, BI, T);
   <u>value</u> I, II, L, U, J, T; <u>integer</u> I, II, L, U, J; <u>real</u> T;
     <u>array</u> AR, AI, BR, BI;
<u>begin</u>
   <u>procedure</u> ELMCOMCOL(L, U, I, J, AR, AI, BR, BI, XR, XI); <u>code</u> 34377;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> ELMCOMCOL(I, II, L, J, AR, AI,
        BR, BI, ( - TAMMAT(I, II, J, L, BR, AR) - TAMMAT(I, II, J,
        L, BI, AI)) / T, (TAMMAT(I, II, J, L, BI, AR) - TAMMAT(I,
        II, J, L, BR, AI)) / T);
<u>end</u> HSHCOMPRD;
<u>comment</u> ================== 34376 ================= ;
<u>procedure</u> ELMCOMVECCOL(L, U, J, AR, AI, BR, BI, XR, XI);
   <u>value</u> L, U, J, XR, XI;
   <u>integer</u> L, U, J; <u>real</u> XR, XI; <u>array</u> AR, AI, BR, BI;
<u>begin</u>
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;
   ELMVECCOL(L, U, J, AR, BR, XR);
   ELMVECCOL(L, U, J, AR, BI, -XI);
   ELMVECCOL(L, U, J, AI, BR, XI);
   ELMVECCOL(L, U, J, AI, BI, XR)
<u>end</u> ELMCOMVECCOL;
<u>comment</u> ================== 34377 ================= ;
<u>procedure</u> ELMCOMCOL(L, U, I, J, AR, AI, BR, BI, XR, XI);
   <u>value</u> L, U, I, J, XR, XI;
   <u>integer</u> L, U, I, J; <u>real</u> XR, XI; <u>array</u> AR, AI, BR, BI;
<u>begin</u>
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   ELMCOL(L, U, I, J, AR, BR, XR);
   ELMCOL(L, U, I, J, AR, BI, -XI);
   ELMCOL(L, U, I, J, AI, BR, XI);
   ELMCOL(L, U, I, J, AI, BI, XR)
<u>end</u> ELMCOMCOL;
<u>comment</u> ================== 34378 ================= ;
<u>procedure</u> ELMCOMROWVEC(L, U, I, AR, AI, BR, BI, XR, XI);
   <u>value</u> L, U, I, XR, XI;
   <u>integer</u> L, U, I; <u>real</u> XR, XI; <u>array</u> AR, AI, BR, BI;
<u>begin</u>
   <u>procedure</u> ELMROWVEC(L, U, I, A, B, X); <u>code</u> 34027;
   ELMROWVEC(L, U, I, AR, BR, XR);
   ELMROWVEC(L, U, I, AR, BI, -XI);
   ELMROWVEC(L, U, I, AI, BR, XI);
   ELMROWVEC(L, U, I, AI, BI, XR)
<u>end</u> ELMCOMROWVEC;
<u>comment</u> ================== 34360 ================= ;
<u>procedure</u> SCLCOM(AR, AI, N, N1, N2); <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> AR, AI;
<u>begin</u> <u>integer</u> I, J, K;
   <u>real</u> S, R;
   <u>procedure</u> COMCOLCST(L, U, J, AR, AI, XR, XI); <u>code</u> 34352;
   <u>for</u> J ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> S ≔ 0;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> R ≔ AR[I, J] ⭡ 2 + AI[I, J] ⭡ 2; <u>if</u> R &gt; S <u>then</u>
               <u>begin</u> S ≔ R; K ≔ I <u>end</u>
            <u>end</u>;
         <u>if</u> S ≠ 0 <u>then</u> COMCOLCST(1, N, J, AR, AI, AR[K, J] /
           S, - AI[K, J] / S)
      <u>end</u>
<u>end</u> SCLCOM;
<u>comment</u> ================== 34359 ================= ;
<u>real</u> <u>procedure</u> COMEUCNRM(AR, AI, LW, N); <u>value</u> N, LW;
   <u>integer</u> N, LW; <u>array</u> AR, AI;
<u>begin</u> <u>integer</u> I, L;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>real</u> R;
   R ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> L ≔ <u>if</u> I &gt; LW <u>then</u> I - LW <u>else</u> 1;
         R ≔ MATTAM(L, N, I, I, AR, AR) + MATTAM(L, N, I,
           I, AI, AI) + R;
      <u>end</u>;
   COMEUCNRM ≔ SQRT(R)
<u>end</u> COMEUCNRM;
<u>comment</u> ================== 34340 ================= ;
<u>real</u> <u>procedure</u> COMABS(XR, XI); <u>value</u> XR, XI; <u>real</u> XR, XI;
<u>begin</u> XR ≔ ABS(XR); XI ≔ ABS(XI);
   COMABS ≔ <u>if</u> XI &gt; XR <u>then</u> SQRT((XR/XI)⭡2 + 1) × XI
   <u>else</u> <u>if</u> XI = 0 <u>then</u> XR <u>else</u> SQRT((XI/XR)⭡2 + 1) × XR
<u>end</u> COMABS;
<u>comment</u> ================== 34343 ================= ;
<u>procedure</u> COMSQRT(AR, AI, PR, PI);
   <u>value</u> AR, AI; <u>real</u> AR, AI, PR, PI;
   <u>if</u> AR = 0 ∧ AI = 0 <u>then</u> PR ≔ PI ≔ 0 <u>else</u>
   <u>begin</u> <u>real</u> BR, BI, H;
      BR ≔ ABS(AR); BI ≔ ABS(AI);
      H ≔ <u>if</u> BI &lt; BR <u>then</u>
        (<u>if</u> BR &lt; 1 <u>then</u> SQRT((SQRT((BI/BR)⭡2 + 1) × ·5 + ·5) × BR)
      <u>else</u> SQRT((SQRT((BI/BR)⭡2 + 1) × ·125 + ·125) × BR) × 2)
      <u>else</u> <u>if</u> BI &lt; 1 <u>then</u> SQRT((SQRT((BR/BI)⭡2 + 1) × BI + BR) × 2) × ·5
      <u>else</u> <u>if</u> BR + 1 = 1 <u>then</u> SQRT(BI × ·5)
      <u>else</u> SQRT(SQRT((BR/BI)⭡2 + 1) × BI × ·125 + BR × ·125) × 2;
      <u>if</u> AR &GreaterSlantEqual; 0 <u>then</u>
      <u>begin</u> PR ≔ H; PI ≔ AI/H × ·5 <u>end</u>
      <u>else</u> <u>begin</u> PI ≔ <u>if</u> AI &GreaterSlantEqual; 0 <u>then</u> H <u>else</u> -H;
         PR ≔ BI/H × ·5
      <u>end</u>
   <u>end</u> COMSQRT;
<u>comment</u> ================== 34342 ================= ;
<u>procedure</u> COMDIV(XR, XI, YR, YI, ZR, ZI);
   <u>value</u> XR, XI, YR, YI; <u>real</u> XR, XI, YR, YI, ZR, ZI;
<u>begin</u> <u>real</u> H, D;
   <u>if</u> ABS(YI) &lt; ABS(YR) <u>then</u>
   <u>begin</u> <u>if</u> YI = 0 <u>then</u>
      <u>begin</u> ZR ≔ XR/YR; ZI ≔ XI/YR <u>end</u> <u>else</u>
      <u>begin</u> H ≔ YI/YR; D ≔ H × YI + YR;
         ZR ≔ (XR + H × XI)/D; ZI ≔ (XI-H × XR)/D
      <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> H ≔ YR/YI; D ≔ H × YR + YI;
      ZR ≔ (XR × H + XI)/D; ZI ≔ (XI × H - XR)/D
   <u>end</u>
<u>end</u> COMDIV;
<u>comment</u> ================== 34301 ================= ;
<u>procedure</u> DECSOL(A, N, AUX, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX, B;
<u>begin</u> <u>integer</u> <u>array</u> P[1:N];
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   DEC(A, N, AUX, P);
   <u>if</u> AUX[3] = N <u>then</u> SOL(A, N, P, B)
<u>end</u> DECSOL;
<u>comment</u> ================== 34061 ================= ;
<u>procedure</u> SOLELM(A, N, RI, CI, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, B;
     <u>integer</u> <u>array</u> RI, CI;
<u>begin</u> <u>integer</u> R, CIR;
   <u>real</u> W;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;
   SOL(A, N, RI, B);
   <u>for</u> R ≔ N <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> CIR ≔ CI[R]; <u>if</u> CIR ≠ R <u>then</u>
         <u>begin</u> W ≔ B[R]; B[R] ≔ B[CIR]; B[CIR] ≔ W <u>end</u>
      <u>end</u>
<u>end</u> SOLELM;
<u>comment</u> ================== 34243 ================= ;
<u>procedure</u> GSSSOLERB(A, N, AUX, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX, B;
<u>begin</u> <u>integer</u> <u>array</u> RI, CI[1:N];
   <u>procedure</u> SOLELM(A, N, RI, CI, B); <u>code</u> 34061;
   <u>procedure</u> GSSERB(A, N, AUX, RI, CI); <u>code</u> 34242;
   GSSERB(A, N, AUX, RI, CI);
   <u>if</u> AUX[3] = N <u>then</u> SOLELM(A, N, RI, CI, B)
<u>end</u> GSSSOLERB;
<u>comment</u> ================== 34302 ================= ;
<u>procedure</u> DECINV(A, N, AUX); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX;
<u>begin</u> <u>integer</u> <u>array</u> P[1:N];
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   <u>procedure</u> INV(A, N, P); <u>code</u> 34053;
   DEC(A, N, AUX, P); <u>if</u> AUX[3] = N <u>then</u> INV(A, N, P)
<u>end</u> DECINV;
<u>comment</u> ================== 34236 ================= ;
<u>procedure</u> GSSINV(A, N, AUX); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX;
<u>begin</u> <u>integer</u> <u>array</u> RI, CI[1:N];
   <u>procedure</u> GSSELM(A, N, AUX, RI, CI); <u>code</u> 34231;
   <u>real</u> <u>procedure</u> INV1(A, N, RI, CI, WITHNORM); <u>code</u> 34235;
   GSSELM(A, N, AUX, RI, CI);
   <u>if</u> AUX[3] = N <u>then</u> AUX[9] ≔ INV1(A, N, RI, CI, <u>true</u>)
<u>end</u> GSSINV;
<u>comment</u> ================== 34244 ================= ;
<u>procedure</u> GSSINVERB(A, N, AUX); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX;
<u>begin</u> <u>integer</u> <u>array</u> RI, CI[1:N];
   <u>procedure</u> GSSELM(A, N, AUX, RI, CI); <u>code</u> 34231;
   <u>real</u> <u>procedure</u> INV1(A, N, RI, CI, WITHNORM); <u>code</u> 34235;
   <u>procedure</u> ERBELM(N, AUX, NRMINV); <u>code</u> 34241;
   GSSELM(A, N, AUX, RI, CI);
   <u>if</u> AUX[3] = N <u>then</u>
     ERBELM(N, AUX, INV1(A, N, RI, CI, <u>true</u>))
<u>end</u> GSSINVERB;
<u>comment</u> ================== 34251 ================= ;
<u>procedure</u> GSSITISOL(A, N, AUX, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX, B;
<u>begin</u> <u>integer</u> I, J;
   <u>array</u> AA[1:N, 1:N];
   <u>integer</u> <u>array</u> RI, CI[1:N];
   <u>procedure</u> GSSELM(A, N, AUX, RI, CI); <u>code</u> 34231;
   <u>procedure</u> ITISOL(A, LU, N, AUX, RI, CI, B); <u>code</u> 34250;
   <u>procedure</u> DUPMAT(L, U, I, J, A, B); <u>code</u> 31035;
   DUPMAT(1, N, 1, N, AA, A);
   GSSELM(A, N, AUX, RI, CI);
   <u>if</u> AUX[3] = N <u>then</u> ITISOL(AA, A, N, AUX, RI, CI, B)
<u>end</u> GSSITISOL;
<u>comment</u> ================== 34254 ================= ;
<u>procedure</u> GSSITISOLERB(A, N, AUX, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, AUX, B;
<u>begin</u> <u>integer</u> I, J;
   <u>array</u> AA[1:N, 1:N];
   <u>integer</u> <u>array</u> RI, CI[1:N];
   <u>procedure</u> GSSNRI(A, N, AUX, RI, CI); <u>code</u> 34252;
   <u>procedure</u> ITISOLERB(A, LU, N, AUX, RI, CI, B); <u>code</u> 34253;
   <u>procedure</u> DUPMAT(L, U, I, J, A, B); <u>code</u> 31035;
   DUPMAT(1, N, 1, N, AA, A);
   GSSNRI(A, N, AUX, RI, CI);
   <u>if</u> AUX[3] = N <u>then</u> ITISOLERB(AA, A, N, AUX, RI, CI, B)
<u>end</u> GSSITISOLERB;
<u>comment</u> ================== 34131 ================= ;
<u>procedure</u> LSQSOL(A, N, M, AID, CI, B); <u>value</u> N, M;
   <u>integer</u> N, M; <u>array</u> A, AID, B; <u>integer</u> <u>array</u> CI;
<u>begin</u> <u>integer</u> K, CIK;
   <u>real</u> W;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;

   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> ELMVECCOL(K, N, K, B, A,
        TAMVEC(K, N, K, A, B) / (AID[K] × A[K, K]));
   <u>for</u> K ≔ M <u>step</u> - 1 <u>until</u> 1 <u>do</u> B[K] ≔ (B[K] - MATVEC
        (K + 1, M, K, A, B)) / AID[K];
   <u>for</u> K ≔ M <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> CIK ≔ CI[K]; <u>if</u> CIK ≠ K <u>then</u>
         <u>begin</u> W ≔ B[K]; B[K] ≔ B[CIK]; B[CIK] ≔ W <u>end</u>
      <u>end</u>
<u>end</u> LSQSOL;
<u>comment</u> ================== 34135 ================= ;
<u>procedure</u> LSQORTDECSOL(A, N, M, AUX, DIAG, B); <u>value</u> N, M;
   <u>integer</u> N, M; <u>array</u> A, AUX, DIAG, B;
<u>begin</u> <u>array</u> AID[1:M];
   <u>integer</u> <u>array</u> CI[1:M];
   <u>procedure</u> LSQORTDEC(A, N, M, AUX, AID, CI); <u>code</u> 34134;
   <u>procedure</u> LSQDGLINV(A, M, AID, CI, DIAG); <u>code</u> 34132;
   <u>procedure</u> LSQSOL(A, N, M, AID, CI, B); <u>code</u> 34131;

   LSQORTDEC(A, N, M, AUX, AID, CI);
   <u>if</u> AUX[3] = M <u>then</u>
   <u>begin</u> LSQDGLINV(A, M, AID, CI, DIAG);
      LSQSOL(A, N, M, AID, CI, B)
   <u>end</u>
<u>end</u> LSQORTDECSOL;
<u>comment</u> ================== 34280 ================= ;
<u>procedure</u> SOLSVDOVR(U, VAL, V, M, N, X, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, X, EM;
<u>begin</u> <u>integer</u> I;
   <u>real</u> MIN;
   <u>array</u> X1[1:N];
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B);
      <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>array</u> A, B;
      <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B);
      <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>array</u> A, B;
      <u>code</u> 34012;
   MIN ≔ EM[6];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        X1[I] ≔ <u>if</u> VAL[I] &LessSlantEqual; MIN <u>then</u> 0 <u>else</u> TAMVEC(1, M, I, U, X) /
        VAL[I];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        X[I] ≔ MATVEC(1, N, I, V, X1)
<u>end</u> SOLSVDOVR;
<u>comment</u> ================== 34281 ================= ;
<u>integer</u> <u>procedure</u> SOLOVR(A, M, N, X, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, X, EM;
<u>begin</u> <u>integer</u> I;
   <u>array</u> VAL[1:N], V[1:N, 1:N];
   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, V, EM;
      <u>code</u> 34273;
   <u>procedure</u> SOLSVDOVR(U, VAL, V, M, N, X, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, X, EM;
      <u>code</u> 34280;

   SOLOVR ≔ I ≔ QRISNGVALDEC(A, M, N, VAL, V, EM);
   <u>if</u> I = 0 <u>then</u> SOLSVDOVR(A, VAL, V, M, N, X, EM)
<u>end</u> SOLOVR;
<u>comment</u> ================== 34282 ================= ;
<u>procedure</u> SOLSVDUND(U, VAL, V, M, N, X, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, X, EM;
<u>begin</u> <u>integer</u> I;
   <u>real</u> MIN;
   <u>array</u> X1[1:N];

   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B);
      <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>array</u> A, B;
      <u>code</u> 34011;

   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B);
      <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>array</u> A, B;
      <u>code</u> 34012;

   MIN ≔ EM[6];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        X1[I] ≔ <u>if</u> VAL[I] &LessSlantEqual; MIN <u>then</u> 0 <u>else</u> TAMVEC(1, N, I, V, X) /
        VAL[I];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
        X[I] ≔ MATVEC(1, N, I, U, X1)
<u>end</u> SOLSVDUND;
<u>comment</u> ================== 34283 ================= ;
<u>integer</u> <u>procedure</u> SOLUND(A, M, N, X, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, X, EM;
<u>begin</u> <u>integer</u> I;
   <u>array</u> VAL[1:N], V[1:N, 1:N];

   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, V, EM;
      <u>code</u> 34273;

   <u>procedure</u> SOLSVDUND(U, VAL, V, M, N, X, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, X, EM;
      <u>code</u> 34282;

   SOLUND ≔ I ≔ QRISNGVALDEC(A, M, N, VAL, V, EM);
   <u>if</u> I = 0 <u>then</u> SOLSVDUND(A, VAL, V, M, N, X, EM)
<u>end</u> SOLUND;
<u>comment</u> ================== 34285 ================= ;
<u>integer</u> <u>procedure</u> HOMSOL(A, M, N, V, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, V, EM;
<u>begin</u> <u>integer</u> I;
   <u>array</u> VAL[1:N];

   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, V, EM;
      <u>code</u> 34273;

   <u>procedure</u> HOMSOLSVD(U, VAL, V, M, N);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V;
      <u>code</u> 34284;

   HOMSOL ≔ I ≔ QRISNGVALDEC(A, M, N, VAL, V, EM);
   <u>if</u> I = 0 <u>then</u> HOMSOLSVD(A, VAL, V, M, N)
<u>end</u> HOMSOL;
<u>comment</u> ================== 34286 ================= ;
<u>procedure</u> PSDINVSVD(U, VAL, V, M, N, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, EM;
<u>begin</u> <u>integer</u> I, J;
   <u>real</u> MIN, VALI;
   <u>array</u> X[1:N];
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B);
      <u>value</u> L, U, I; <u>integer</u> L, U, I; <u>array</u> A, B;
      <u>code</u> 34011;
   MIN ≔ EM[6];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>if</u> VAL[I] &gt; MIN <u>then</u>
      <u>begin</u> VALI ≔ 1 / VAL[I];
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> U[J, I] ≔ U[J, I] × VALI
      <u>end</u>
      <u>else</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> U[J, I] ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
      <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> X[J] ≔ U[I, J];
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              U[I, J] ≔ MATVEC(1, N, J, V, X)
      <u>end</u>
<u>end</u> PSDINVSVD;
<u>comment</u> ================== 34287 ================= ;
<u>integer</u> <u>procedure</u> PSDINV(A, M, N, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, EM;
<u>begin</u> <u>integer</u> I;
   <u>array</u> VAL[1:N], V[1:N, 1:N];
   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, V, EM;
      <u>code</u> 34273;
   <u>procedure</u> PSDINVSVD(U, VAL, V, M, N, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> U, VAL, V, EM;
      <u>code</u> 34286;

   PSDINV ≔ I ≔ QRISNGVALDEC(A, M, N, VAL, V, EM);
   <u>if</u> I = 0 <u>then</u> PSDINVSVD(A, VAL, V, M, N, EM)
<u>end</u> PSDINV;
<u>comment</u> ================== 34320 ================= ;
<u>procedure</u> DECBND(A, N, LW, RW, AUX, M, P); <u>value</u> N, LW, RW;
   <u>integer</u> N, LW, RW; <u>integer</u> <u>array</u> P; <u>array</u> A, M, AUX;
<u>begin</u> <u>integer</u> I, J, K, KK, KK1, PK, MK, IK, LW1, F, Q, W, W1,
     W2, NRW, IW, SDET;
   <u>real</u> R, S, EPS, MIN;
   <u>array</u> V[1:N];

   <u>real</u> <u>procedure</u> VECVEC(A, B, C, D, E); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(A, B, C, D, E, F); <u>code</u> 34020;
   <u>procedure</u> ICHVEC(A, B, C, D); <u>code</u> 34030;
   F ≔ LW; W1 ≔ LW + RW; W ≔ W1 + 1; W2 ≔ W - 2; IW ≔ 0; SDET ≔ 1;
   NRW ≔ N - RW; LW1 ≔ LW + 1; Q ≔ LW - 1;
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> LW <u>do</u>
      <u>begin</u> Q ≔ Q - 1; IW ≔ IW + W1;
         <u>for</u> J ≔ IW - Q <u>step</u> 1 <u>until</u> IW <u>do</u> A[J] ≔ 0
      <u>end</u>;
   IW ≔ - W2; Q ≔ - LW;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> IW ≔ IW + W; <u>if</u> I &LessSlantEqual; LW1 <u>then</u> IW ≔ IW - 1;
         Q ≔ Q + W; <u>if</u> I &gt; NRW <u>then</u> Q ≔ Q - 1;
         V[I] ≔ SQRT(VECVEC(IW, Q, 0, A, A))
      <u>end</u>;
   EPS ≔ AUX[2]; MIN ≔ 1; KK ≔ - W1; MK ≔ - LW;
   <u>if</u> F &gt; NRW <u>then</u> W2 ≔ W2 + NRW - F;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> F &lt; N <u>then</u> F ≔ F + 1; IK ≔ KK ≔ KK + W;
         MK ≔ MK + LW; S ≔ ABS(A[KK]) / V[K]; PK ≔ K; KK1 ≔ KK + 1;
         <u>for</u> I ≔ K + 1 <u>step</u> 1 <u>until</u> F <u>do</u>
            <u>begin</u> IK ≔ IK + W1; M[MK + I - K] ≔ R ≔ A[IK]; A[IK] ≔ 0;
               R ≔ ABS(R) / V[I]; <u>if</u> R &gt; S <u>then</u>
               <u>begin</u> S ≔ R; PK ≔ I <u>end</u>
            <u>end</u>;
         <u>if</u> S &lt; MIN <u>then</u> MIN ≔ S; <u>if</u> S &lt; EPS <u>then</u>
         <u>begin</u> AUX[3] ≔ K - 1; AUX[5] ≔ S; <u>go</u> <u>to</u> END <u>end</u>;
         <u>if</u> K + W2 &GreaterSlantEqual; N <u>then</u> W2 ≔ W2 - 1;
         P[K] ≔ PK; <u>if</u> PK ≠ K <u>then</u>
         <u>begin</u> V[PK] ≔ V[K];
            PK ≔ PK - K; ICHVEC(KK1, KK1 + W2, PK × W1, A);
            SDET ≔ - SDET; R ≔ M[MK + PK]; M[MK + PK] ≔ A[KK];
            A[KK] ≔ R
         <u>end</u> <u>else</u> R ≔ A[KK]; <u>if</u> R &lt; 0 <u>then</u> SDET ≔ - SDET;
         IW ≔ KK1; LW1 ≔ F - K + MK;
         <u>for</u> I ≔ MK + 1 <u>step</u> 1 <u>until</u> LW1 <u>do</u>
            <u>begin</u> M[I] ≔ S ≔ M[I] / R; IW ≔ IW + W1;
               ELMVEC(IW, IW + W2, KK1 - IW, A, A, - S)
            <u>end</u>
      <u>end</u>;
   AUX[3] ≔ N; AUX[5] ≔ MIN;
   END: AUX[1] ≔ SDET
<u>end</u> DECBND;
<u>comment</u> ================== 34321 ================= ;
<u>real</u> <u>procedure</u> DETERMBND(A, N, LW, RW, SGNDET);
   <u>value</u> N, LW, RW, SGNDET; <u>integer</u> N, LW, RW, SGNDET; <u>array</u> A;
<u>begin</u> <u>integer</u> I, L; <u>real</u> P;
   L ≔ 1; P ≔ 1; LW ≔ LW + RW + 1;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> P ≔ A[L] × P; L ≔ L + LW <u>end</u>;
   DETERMBND ≔ ABS(P) × SGNDET
<u>end</u> DETERMBND;
<u>comment</u> ================== 34071 ================= ;
<u>procedure</u> SOLBND(A, N, LW, RW, M, P, B); <u>value</u> N, LW, RW;
   <u>integer</u> N, LW, RW; <u>integer</u> <u>array</u> P; <u>array</u> A, B, M;
<u>begin</u> <u>integer</u> F, I, K, KK, W, W1, W2, SHIFT;
   <u>real</u> S;

   <u>real</u> <u>procedure</u> VECVEC(A, B, C, D, E); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(A, B, C, D, E, F); <u>code</u> 34020;

   F ≔ LW; SHIFT ≔ - LW; W1 ≔ LW - 1;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> F &lt; N <u>then</u> F ≔ F + 1; SHIFT ≔ SHIFT + W1;
         I ≔ P[K]; S ≔ B[I]; <u>if</u> I ≠ K <u>then</u>
         <u>begin</u> B[I] ≔ B[K]; B[K] ≔ S <u>end</u>;
         ELMVEC(K + 1, F, SHIFT, B, M, - S)
      <u>end</u>;
   W1 ≔ LW + RW; W ≔ W1 + 1; KK ≔ (N + 1) × W - W1; W2 ≔ - 1;
   SHIFT ≔ N × W1;
   <u>for</u> K ≔ N <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> KK ≔ KK - W; SHIFT ≔ SHIFT - W1;
         <u>if</u> W2 &lt; W1 <u>then</u> W2 ≔ W2 + 1;
         B[K] ≔ (B[K] - VECVEC(K + 1, K + W2, SHIFT, B, A)) / A[KK]
      <u>end</u>
<u>end</u> SOLBND;
<u>comment</u> ================== 34322 ================= ;
<u>procedure</u> DECSOLBND(A, N, LW, RW, AUX, B); <u>value</u> N, LW, RW;
   <u>integer</u> N, LW, RW; <u>array</u> A, B, AUX;
<u>begin</u> <u>integer</u> I, J, K, KK, KK1, PK, IK, LW1, F, Q, W, W1, W2, IW,
     NRW, SHIFT, SDET;
   <u>real</u> R, S, EPS, MIN; <u>array</u> M[0:LW], V[1:N];

   <u>real</u> <u>procedure</u> VECVEC(A, B, C, D, E); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(A, B, C, D, E, F); <u>code</u> 34020;
   <u>procedure</u> ICHVEC(A, B, C, D); <u>code</u> 34030;

   F ≔ LW; SDET ≔ 1; W1 ≔ LW + RW; W ≔ W1 + 1; W2 ≔ W - 2; IW ≔ 0;
   NRW ≔ N - RW; LW1 ≔ LW + 1; Q ≔ LW - 1;
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> LW <u>do</u>
      <u>begin</u> Q ≔ Q - 1; IW ≔ IW + W1;
         <u>for</u> J ≔ IW - Q <u>step</u> 1 <u>until</u> IW <u>do</u> A[J] ≔ 0
      <u>end</u>;
   IW ≔ - W2; Q ≔ - LW;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> IW ≔ IW + W; <u>if</u> I &LessSlantEqual; LW1 <u>then</u> IW ≔ IW - 1;
         Q ≔ Q + W; <u>if</u> I &gt; NRW <u>then</u> Q ≔ Q - 1;
         V[I] ≔ SQRT(VECVEC(IW, Q, 0, A, A))
      <u>end</u>;
   EPS ≔ AUX[2]; MIN ≔ 1; KK ≔ - W1;
   <u>if</u> F &gt; NRW <u>then</u> W2 ≔ W2 + NRW - F;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> F &lt; N <u>then</u> F ≔ F + 1; IK ≔ KK ≔ KK + W;
         S ≔ ABS(A[KK]) / V[K]; PK ≔ K; KK1 ≔ KK + 1;
         <u>for</u> I ≔ K + 1 <u>step</u> 1 <u>until</u> F <u>do</u>
            <u>begin</u> IK ≔ IK + W1; M[I - K] ≔ R ≔ A[IK]; A[IK] ≔ 0;
               R ≔ ABS(R) / V[I]; <u>if</u> R &gt; S <u>then</u>
               <u>begin</u> S ≔ R; PK ≔ I <u>end</u>
            <u>end</u>;
         <u>if</u> S &lt; MIN <u>then</u> MIN ≔ S; <u>if</u> S &lt; EPS <u>then</u>
         <u>begin</u> AUX[3] ≔ K - 1; AUX[5] ≔ S; <u>go</u> <u>to</u> END <u>end</u>;
         <u>if</u> K + W2 &GreaterSlantEqual; N <u>then</u> W2 ≔ W2 - 1; <u>if</u> PK ≠ K <u>then</u>
         <u>begin</u> V[PK] ≔ V[K];
            PK ≔ PK - K; ICHVEC(KK1, KK1 + W2, PK × W1, A);
            SDET ≔ - SDET; R ≔ B[K]; B[K] ≔ B[PK + K];
            B[PK + K] ≔ R; R ≔ M[PK]; M[PK] ≔ A[KK]; A[KK] ≔ R
         <u>end</u>
         <u>else</u> R ≔ A[KK]; IW ≔ KK1; LW1 ≔ F - K;
         <u>if</u> R &lt; 0 <u>then</u> SDET ≔ - SDET;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> LW1 <u>do</u>
            <u>begin</u> M[I] ≔ S ≔ M[I] / R; IW ≔ IW + W1;
               ELMVEC(IW, IW + W2, KK1 - IW, A, A, - S);
               B[K + I] ≔ B[K + I] - B[K] × S
            <u>end</u>
      <u>end</u>;
   AUX[3] ≔ N; AUX[5] ≔ MIN;
   KK ≔ (N + 1) × W - W1; W2 ≔ - 1; SHIFT ≔ N × W1;
   <u>for</u> K ≔ N <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> KK ≔ KK - W; SHIFT ≔ SHIFT - W1;
         <u>if</u> W2 &lt; W1 <u>then</u> W2 ≔ W2 + 1;
         B[K] ≔ (B[K] - VECVEC(K + 1, K + W2, SHIFT, B, A)) / A[KK]
      <u>end</u>;
   END: AUX[1] ≔ SDET
<u>end</u> DECSOLBND;
<u>comment</u> ================== 34423 ================= ;
<u>procedure</u> DECTRI(SUB, DIAG, SUPER, N, AUX);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, AUX;
<u>begin</u> <u>integer</u> I, N1;
   <u>real</u> D, R, S, U, NORM, NORM1, TOL;
   TOL ≔ AUX[2]; D ≔ DIAG[1]; R ≔ SUPER[1];
   NORM ≔ NORM1 ≔ ABS(D) + ABS(R);
   <u>if</u> ABS(D) &LessSlantEqual; NORM1 × TOL <u>then</u>
   <u>begin</u> AUX[3] ≔ 0; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   U ≔ SUPER[1] ≔ R / D; S ≔ SUB[1]; N1 ≔ N - 1;
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N1 <u>do</u>
      <u>begin</u> D ≔ DIAG[I]; R ≔ SUPER[I];
         NORM1 ≔ ABS(S) + ABS(D) + ABS(R);
         D ≔ DIAG[I] ≔ D - U × S;
         <u>if</u> ABS(D) &LessSlantEqual; NORM1 × TOL <u>then</u>
         <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
         U ≔ SUPER[I] ≔ R / D; S ≔ SUB[I];
         <u>if</u> NORM1 &gt; NORM <u>then</u> NORM ≔ NORM1
      <u>end</u>;
   D ≔ DIAG[N]; NORM1 ≔ ABS(D) + ABS(S);
   D ≔ DIAG[N] ≔ D - U × S;
   <u>if</u> ABS(D) &LessSlantEqual; NORM1 × TOL <u>then</u>
   <u>begin</u> AUX[3] ≔ N1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   <u>if</u> NORM1 &gt; NORM <u>then</u> NORM ≔ NORM1;
   AUX[3] ≔ N; AUX[5] ≔ NORM;
   EXIT:
<u>end</u> DECTRI;
<u>comment</u> ================== 34426 ================= ;
<u>procedure</u> DECTRIPIV(SUB, DIAG, SUPER, N, AID, AUX, PIV);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, AID, AUX;
     <u>Boolean</u> <u>array</u> PIV;
<u>begin</u> <u>integer</u> I, I1, N1, N2;
   <u>real</u> D, R, S, U, T, Q, V, W, NORM, NORM1, NORM2, TOL;
   TOL ≔ AUX[2]; D ≔ DIAG[1]; R ≔ SUPER[1];
   NORM ≔ NORM2 ≔ ABS(D) + ABS(R); N2 ≔ N - 2;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> I1 ≔ I + 1; S ≔ SUB[I]; T ≔ DIAG[I1]; Q ≔ SUPER[I1];
         NORM1 ≔ NORM2; NORM2 ≔ ABS(S) + ABS(T) + ABS(Q);
         <u>if</u> NORM2 &gt; NORM <u>then</u> NORM ≔ NORM2;
         <u>if</u> ABS(D) × NORM2 &lt; ABS(S) × NORM1 <u>then</u>
         <u>begin</u> <u>if</u> ABS(S) &LessSlantEqual; TOL × NORM2 <u>then</u>
            <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ S; <u>goto</u> EXIT <u>end</u>;
            DIAG[I] ≔ S; U ≔ SUPER[I] ≔ T / S;
            V ≔ AID[I] ≔ Q / S; SUB[I] ≔ D;
            W ≔ SUPER[I1] ≔ -V × D; D ≔ DIAG[I1] ≔ R - U × D;
            R ≔ W; NORM2 ≔ NORM1; PIV[I] ≔ <u>true</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM1 <u>then</u>
            <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
            U ≔ SUPER[I] ≔ R / D; D ≔ DIAG[I1] ≔ T - U × S;
            AID[I] ≔ 0; PIV[I] ≔ <u>false</u>; R ≔ Q
         <u>end</u>
      <u>end</u>;
   N1 ≔ N - 1; S ≔ SUB[N1]; T ≔ DIAG[N]; NORM1 ≔ NORM2;
   NORM2 ≔ ABS(S) + ABS(T); <u>if</u> NORM2 &gt; NORM <u>then</u> NORM ≔ NORM2;
   <u>if</u> ABS(D) × NORM2 &lt; ABS(S) × NORM1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(S) &LessSlantEqual; TOL × NORM2 <u>then</u>
      <u>begin</u> AUX[3] ≔ N2; AUX[5] ≔ S; <u>goto</u> EXIT <u>end</u>;
      DIAG[N1] ≔ S; U ≔ SUPER[N1] ≔ T / S; SUB[N1] ≔ D;
      D ≔ DIAG[N] ≔ R - U × D; NORM2 ≔ NORM1; PIV[N1] ≔ <u>true</u>
   <u>end</u> <u>else</u>
   <u>begin</u> <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM1 <u>then</u>
      <u>begin</u> AUX[3] ≔ N2; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
      U ≔ SUPER[N1] ≔ R / D; D ≔ DIAG[N] ≔ T - U × S;
      PIV[N1] ≔ <u>false</u>
   <u>end</u>;
   <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM2 <u>then</u>
   <u>begin</u> AUX[3] ≔ N1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   AUX[3] ≔ N; AUX[5] ≔ NORM;
   EXIT:
<u>end</u> DECTRIPIV;
<u>comment</u> ================== 34424 ================= ;
<u>procedure</u> SOLTRI(SUB, DIAG, SUPER, N, B);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, B;
<u>begin</u> <u>integer</u> I;
   <u>real</u> R;
   R ≔ B[1] ≔ B[1] / DIAG[1];
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
        R ≔ B[I] ≔ (B[I] - SUB[I - 1] × R) / DIAG[I];
   <u>for</u> I ≔ N - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
        R ≔ B[I] ≔ B[I] - SUPER[I] × R
<u>end</u> SOLTRI;
<u>comment</u> ================== 34425 ================= ;
<u>procedure</u> DECSOLTRI(SUB, DIAG, SUPER, N, AUX, B);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, AUX, B;
<u>begin</u> <u>procedure</u> DECTRI(SUB, DIAG, SUPER, N, AUX); <u>code</u> 34423;
   <u>procedure</u> SOLTRI( SUB, DIAG, SUPER, N, B);  <u>code</u> 34424;
   DECTRI(SUB, DIAG, SUPER, N, AUX); <u>if</u> AUX[3] = N <u>then</u>
     SOLTRI(SUB, DIAG, SUPER, N, B)
<u>end</u> DECSOLTRI;
<u>comment</u> ================== 34427 ================= ;
<u>procedure</u> SOLTRIPIV(SUB, DIAG, SUPER, N, AID, PIV, B);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, AID, B;
     <u>Boolean</u> <u>array</u> PIV;
<u>begin</u> <u>integer</u> I, N1;
   <u>real</u> BI, BI1, R, S, T;
   N1 ≔ N - 1;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N1 <u>do</u>
      <u>begin</u> <u>if</u> PIV[I] <u>then</u>
         <u>begin</u> BI ≔ B[I + 1]; BI1 ≔ B[I] <u>end</u>
         <u>else</u>
         <u>begin</u> BI ≔ B[I]; BI1 ≔ B[I + 1] <u>end</u>;
         R ≔ B[I] ≔ BI / DIAG[I];
         B[I + 1] ≔ BI1 - SUB[I] × R
      <u>end</u>;
   R ≔ B[N] ≔ B[N] / DIAG[N];
   T ≔ B[N1] ≔ B[N1] - SUPER[N1] × R;
   <u>for</u> I ≔ N - 2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> S ≔ R; R ≔ T; T ≔ B[I] ≔ B[I] - SUPER[I] × R -
           (<u>if</u> PIV[I] <u>then</u> AID[I] × S <u>else</u> 0)
      <u>end</u>
<u>end</u> SOLTRIPIV;
<u>comment</u> ================== 34428 ================= ;
<u>procedure</u> DECSOLTRIPIV(SUB, DIAG, SUPER, N, AUX, B);
   <u>value</u> N; <u>integer</u> N; <u>array</u> SUB, DIAG, SUPER, AUX, B;
<u>begin</u> <u>integer</u> I, I1, N1, N2;
   <u>real</u> D, R, S, U, T, Q, V, W, NORM, NORM1, NORM2, TOL,
     BI, BI1, BI2;
   <u>Boolean</u> <u>array</u> PIV[1:N];
   TOL ≔ AUX[2]; D ≔ DIAG[1]; R ≔ SUPER[1]; BI ≔ B[1];
   NORM ≔ NORM2 ≔ ABS(D) + ABS(R); N2 ≔ N - 2;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> I1 ≔ I + 1; S ≔ SUB[I]; T ≔ DIAG[I1]; Q ≔ SUPER[I1];
         BI1 ≔ B[I1];
         NORM1 ≔ NORM2; NORM2 ≔ ABS(S) + ABS(T) + ABS(Q);
         <u>if</u> NORM2 &gt; NORM <u>then</u> NORM ≔ NORM2;
         <u>if</u> ABS(D) × NORM2 &lt; ABS(S) × NORM1 <u>then</u>
         <u>begin</u> <u>if</u> ABS(S) &LessSlantEqual; TOL × NORM2 <u>then</u>
            <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ S; <u>goto</u> EXIT <u>end</u>;
            U ≔ SUPER[I] ≔ T / S; BI1 ≔ B[I] ≔ BI1 / S;
            BI ≔ BI - BI1 × D; V ≔ SUB[I] ≔ Q / S;
            W ≔ SUPER[I1] ≔ -V × D; D ≔ DIAG[I1] ≔ R - U × D;
            R ≔ W; NORM2 ≔ NORM1; PIV[I] ≔ <u>true</u>
         <u>end</u> <u>else</u>
         <u>begin</u> <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM1 <u>then</u>
            <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
            U ≔ SUPER[I] ≔ R / D; BI ≔ B[I] ≔ BI / D;
            BI ≔ BI1 - BI × S; D ≔ DIAG[I1] ≔ T - U × S;
            PIV[I] ≔ <u>false</u>; R ≔ Q
         <u>end</u>
      <u>end</u>;
   N1 ≔ N - 1; S ≔ SUB[N1]; T ≔ DIAG[N]; NORM1 ≔ NORM2; BI1 ≔ B[N];
   NORM2 ≔ ABS(S) + ABS(T); <u>if</u> NORM2 &gt; NORM <u>then</u> NORM ≔ NORM2;
   <u>if</u> ABS(D) × NORM2 &lt; ABS(S) × NORM1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(S) &LessSlantEqual; TOL × NORM2 <u>then</u>
      <u>begin</u> AUX[3] ≔ N2; AUX[5] ≔ S; <u>goto</u> EXIT <u>end</u>;
      U ≔ SUPER[N1] ≔ T / S; BI1 ≔ B[N1] ≔ BI1 / S;
      BI ≔ BI - BI1 × D; D ≔ R - U × D; NORM2 ≔ NORM1
   <u>end</u> <u>else</u>
   <u>begin</u> <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM1 <u>then</u>
      <u>begin</u> AUX[3] ≔ N2; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
      U ≔ SUPER[N1] ≔ R / D; BI ≔ B[N1] ≔ BI / D;
      BI ≔ BI1 - BI × S; D ≔ T - U × S
   <u>end</u>;
   <u>if</u> ABS(D) &LessSlantEqual; TOL × NORM2 <u>then</u>
   <u>begin</u> AUX[3] ≔ N1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   AUX[3] ≔ N; AUX[5] ≔ NORM;
   BI1 ≔ B[N] ≔ BI / D; BI ≔ B[N1] ≔ B[N1] - SUPER[N1] × BI1;
   <u>for</u> I ≔ N - 2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> BI2 ≔ BI1; BI1 ≔ BI;
         BI ≔ B[I] ≔ B[I] - SUPER[I] × BI1 -
           (<u>if</u> PIV[I] <u>then</u> SUB[I] × BI2 <u>else</u> 0)
      <u>end</u>;
   EXIT:
<u>end</u> DECSOLTRIPIV;
<u>comment</u> ================== 34330 ================= ;
<u>procedure</u> CHLDECBND(A, N, W, AUX); <u>value</u> N, W; <u>integer</u> N, W;
     <u>array</u> A, AUX;
<u>begin</u> <u>integer</u> J, K, JMAX, KK, KJ, W1, START;
   <u>real</u> R, EPS, MAX;
   <u>real</u> <u>procedure</u> VECVEC(L, U, S, A, B); <u>code</u> 34010;
   MAX ≔ 0; KK ≔ - W; W1 ≔ W + 1;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> KK ≔ KK + W1; <u>if</u> A[KK] &gt; MAX <u>then</u> MAX ≔ A[KK] <u>end</u>;
   JMAX ≔ W; W1 ≔ W + 1; KK ≔ - W; EPS ≔ AUX[2] × MAX;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> K + W &gt; N <u>then</u> JMAX ≔ JMAX - 1; KK ≔ KK + W1;
         START ≔ KK - K + 1;
         R ≔ A[KK] - VECVEC(<u>if</u> K &LessSlantEqual; W1 <u>then</u> START <u>else</u> KK - W,
           KK - 1, 0, A, A); <u>if</u> R &LessSlantEqual; EPS <u>then</u>
         <u>begin</u> AUX[3] ≔ K - 1; <u>go</u> <u>to</u> END <u>end</u>;
         A[KK] ≔ R ≔ SQRT(R); KJ ≔ KK;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> JMAX <u>do</u>
            <u>begin</u> KJ ≔ KJ + W;
               A[KJ] ≔ (A[KJ] - VECVEC(<u>if</u> K + J &LessSlantEqual; W1 <u>then</u> START
               <u>else</u> KK - W + J, KK - 1, KJ - KK, A, A)) / R
            <u>end</u>
      <u>end</u>;
   AUX[3] ≔ N;
   END:
<u>end</u> CHLDECBND;
<u>comment</u> ================== 34331 ================= ;
<u>real</u> <u>procedure</u> CHLDETERMBND(A, N, W); <u>value</u> N, W; <u>integer</u> N, W;
     <u>array</u> A;
<u>begin</u> <u>integer</u> J, KK, W1; <u>real</u> P;
   W1 ≔ W + 1; KK ≔ - W; P ≔ 1;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> KK ≔ KK + W1; P ≔ A[KK] × P <u>end</u>;
   CHLDETERMBND ≔ P × P
<u>end</u> CHLDETERMBND;
<u>comment</u> ================== 34332 ================= ;
<u>procedure</u> CHLSOLBND(A, N, W, B); <u>value</u> N, W; <u>integer</u> N, W;
     <u>array</u> A, B;
<u>begin</u> <u>integer</u> I, K, IMAX, KK, W1;
   <u>real</u> <u>procedure</u> VECVEC(L, U, S, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> SCAPRD1(LA, SA, LB, SB, N, A, B);
      <u>code</u> 34017;
   KK ≔ - W; W1 ≔ W + 1;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> KK ≔ KK + W1;
         B[K] ≔ (B[K] - VECVEC(<u>if</u> K &LessSlantEqual; W1 <u>then</u> 1 <u>else</u> K - W,
           K - 1, KK - K, B, A)) / A[KK]
      <u>end</u>;
   IMAX ≔ - 1;
   <u>for</u> K ≔ N <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> <u>if</u> IMAX &lt; W <u>then</u> IMAX ≔ IMAX + 1;
         B[K] ≔ (B[K] - SCAPRD1(KK + W, W, K + 1, 1, IMAX, A, B)) /
           A[KK]; KK ≔ KK - W1
      <u>end</u>
<u>end</u> CHLSOLBND;
<u>comment</u> ================== 34333 ================= ;
<u>procedure</u> CHLDECSOLBND(A, N, W, AUX, B); <u>value</u> N, W;
   <u>integer</u> N, W; <u>array</u> A, AUX, B;
<u>begin</u> <u>procedure</u> CHLDECBND(A, N, W, AUX); <u>code</u> 34330;
   <u>procedure</u> CHLSOLBND(A, N, W, B); <u>code</u> 34332;
   CHLDECBND(A, N, W, AUX);
   <u>if</u> AUX[3] = N <u>then</u> CHLSOLBND(A, N, W, B)
<u>end</u> CHLDECSOLBND;
<u>comment</u> ================== 34420 ================= ;
<u>procedure</u> DECSYMTRI(DIAG, CO, N, AUX); <u>value</u> N; <u>integer</u> N;
     <u>array</u> DIAG, CO, AUX;
<u>begin</u>  <u>integer</u> I, N1;
   <u>real</u> D, R, S, U, TOL, NORM, NORMR;
   TOL ≔ AUX[2]; D ≔ DIAG[1]; R ≔ CO[1];
   NORM ≔ NORMR ≔ ABS(D) + ABS(R);
   <u>if</u> ABS(D) &LessSlantEqual; NORMR × TOL <u>then</u>
   <u>begin</u> AUX[3] ≔ 0; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   U ≔ CO[1] ≔ R / D; N1 ≔ N - 1;
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N1 <u>do</u>
      <u>begin</u> S ≔ R; R ≔ CO[I]; D ≔ DIAG[I];
         NORMR ≔ ABS(S) + ABS(D) + ABS(R);
         D ≔ DIAG[I] ≔ D - U × S;
         <u>if</u> ABS(D) &LessSlantEqual; NORMR × TOL <u>then</u>
         <u>begin</u> AUX[3] ≔ I - 1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
         U ≔ CO[I] ≔ R / D; <u>if</u> NORMR &gt; NORM <u>then</u> NORM ≔ NORMR
      <u>end</u>;
   D ≔ DIAG[N]; NORMR ≔ ABS(D) + ABS(R);
   D ≔ DIAG[N] ≔ D - U × R;
   <u>if</u> ABS(D) &LessSlantEqual; NORMR × TOL <u>then</u>
   <u>begin</u> AUX[3] ≔ N1; AUX[5] ≔ D; <u>goto</u> EXIT <u>end</u>;
   <u>if</u> NORMR &gt; NORM <u>then</u> NORM ≔ NORMR;
   AUX[3] ≔ N; AUX[5] ≔ NORM;
   EXIT:
<u>end</u> DECSYMTRI;
<u>comment</u> ================== 34421 ================= ;
<u>procedure</u> SOLSYMTRI(DIAG, CO, N, B); <u>value</u> N; <u>integer</u> N;
     <u>array</u> DIAG, CO, B;
<u>begin</u> <u>integer</u> I;
   <u>real</u> R, S;
   R ≔ B[1]; B[1] ≔ R / DIAG[1];
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> R ≔ B[I] - CO[I-1] × R; B[I] ≔ R / DIAG[I] <u>end</u>;
   S ≔ B[N];
   <u>for</u> I ≔ N - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
        S ≔ B[I] ≔ B[I] - CO[I] × S
<u>end</u> SOLSYMTRI;
<u>comment</u> ================== 34422 ================= ;
<u>procedure</u> DECSOLSYMTRI(DIAG, CO, N, AUX, B); <u>value</u> N;
   <u>integer</u> N; <u>array</u> DIAG, CO, AUX, B;
<u>begin</u> <u>procedure</u> DECSYMTRI(DIAG, CO, N, AUX); <u>code</u> 34420;
   <u>procedure</u> SOLSYMTRI(DIAG, CO, N, B);   <u>code</u> 34421;
   DECSYMTRI(DIAG, CO, N, AUX); <u>if</u> AUX[3] = N <u>then</u>
     SOLSYMTRI(DIAG, CO, N, B)
<u>end</u> DECSOLSYMTRI;
<u>comment</u> ================== 34220 ================= ;
<u>procedure</u> CONJ GRAD( MATVEC, X, R, L, N, GO ON, ITERATE, NORM2);
   <u>value</u> L, N; <u>procedure</u> MATVEC; <u>array</u> X, R; <u>Boolean</u> GO ON;
     <u>integer</u> L, N, ITERATE; <u>real</u> NORM2;
<u>begin</u> <u>array</u> P, AP[ L: N];
   <u>integer</u> I;
   <u>real</u>  A, B, PRR, RRP;
   <u>real</u> <u>procedure</u> VECVEC( A, B, C, D, E); <u>code</u> 34010;
   <u>procedure</u> ELMVEC( A, B, C, D, E, F); <u>code</u> 34020;
   <u>for</u> ITERATE ≔ 0, ITERATE + 1 <u>while</u> GO ON <u>do</u>
      <u>begin</u> <u>if</u> ITERATE = 0 <u>then</u>
         <u>begin</u> MATVEC( X, P);
            <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> N <u>do</u>
                 P[ I] ≔ R[ I] ≔ R[ I] - P[ I];
            PRR ≔ VECVEC( L, N, 0, R, R)
         <u>end</u> <u>else</u>
         <u>begin</u> B ≔ RRP / PRR; PRR ≔ RRP;
            <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> N <u>do</u>
                 P[ I] ≔ R[ I] + B × P[ I]
         <u>end</u>;
         MATVEC( P, AP);
         A ≔ PRR / VECVEC( L, N, 0, P, AP);
         ELMVEC( L, N, 0, X, P, A);
         ELMVEC( L, N, 0, R, AP, -A);
         NORM2 ≔ RRP ≔ VECVEC( L, N, 0, R, R)
      <u>end</u>
<u>end</u> CONJ GRAD;
<u>comment</u> ================== 34173 ================= ;
<u>comment</u> MCA 2405;
<u>procedure</u> EQILBR(A, N, EM, D, INT); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, EM, D; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, IM, I1, P, Q, J, T, COUNT, EXPONENT, NI;
   <u>real</u> C, R, EPS, OMEGA, FACTOR;

   <u>procedure</u> MOVE(K); <u>value</u> K; <u>integer</u> K;
   <u>begin</u> <u>real</u> DI;
      NI ≔ Q - P; T ≔ T + 1; <u>if</u> K ≠ I <u>then</u>
      <u>begin</u> ICHCOL(1, N, K, I, A); ICHROW(1, N, K, I, A);
         DI ≔ D[I]; D[I] ≔ D[K]; D[K] ≔ DI
      <u>end</u>
   <u>end</u> MOVE;

   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>procedure</u> ICHCOL(L, U, I, J, A); <u>code</u> 34031;
   <u>procedure</u> ICHROW(L, U, I, J, A); <u>code</u> 34032;

   FACTOR ≔ 1 / (2 × LN(2)); <u>comment</u> MORE GENERALLY: LN(BASE);
   EPS ≔ EM[0]; OMEGA ≔ 1 / EPS; T ≔ P ≔ 1; Q ≔ NI ≔ I ≔ N;
   COUNT ≔ (N + 1) × N ÷ 2;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> D[J] ≔ 1; INT[J] ≔ 0 <u>end</u>;
   <u>for</u> I ≔ <u>if</u> I &lt; Q <u>then</u> I + 1 <u>else</u> P
     <u>while</u> COUNT &gt; 0 ∧ NI &gt; 0 <u>do</u>
      <u>begin</u> COUNT ≔ COUNT - 1; IM ≔ I - 1; I1 ≔ I + 1;
         C ≔ SQRT(TAMMAT(P, IM, I, I, A, A) +
           TAMMAT(I1, Q, I, I, A, A));
         R ≔ SQRT(MATTAM(P, IM, I, I, A, A) +
           MATTAM(I1, Q, I, I, A, A));
         <u>if</u> C × OMEGA &LessSlantEqual; R × EPS <u>then</u>
         <u>begin</u> INT[T] ≔ I; MOVE(P); P ≔ P + 1 <u>end</u>
           <u>else</u> <u>if</u> R × OMEGA &LessSlantEqual; C × EPS <u>then</u>
         <u>begin</u> INT[T] ≔ -I; MOVE(Q); Q ≔ Q - 1 <u>end</u>
         <u>else</u>
         <u>begin</u> EXPONENT ≔ LN(R / C) × FACTOR;
            <u>if</u> ABS(EXPONENT) &gt; 1 <u>then</u>
            <u>begin</u> NI ≔ Q - P; C ≔ 2 ⭡ EXPONENT; R ≔ 1 / C;
               D[I] ≔ D[I] × C;
               <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> IM,
                 I1 <u>step</u> 1 <u>until</u> N <u>do</u>
                  <u>begin</u> A[J, I] ≔ A[J, I] × C;
                     A[I, J] ≔ A[I, J] × R
                  <u>end</u>
            <u>end</u> <u>else</u> NI ≔ NI - 1
         <u>end</u>
      <u>end</u>
<u>end</u> EQILBR;
<u>comment</u> ================== 34174 ================= ;
<u>comment</u> MCA 2406;
<u>procedure</u> BAKLBR(N, N1, N2, D, INT, VEC); <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> D, VEC; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, J, K, P, Q; <u>real</u> DI;

   <u>procedure</u> ICHROW(L, U, I, J, A); <u>code</u> 34032;

   P ≔ 1; Q ≔ N;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> DI ≔ D[I]; <u>if</u> DI ≠ 1 <u>then</u>
           <u>for</u> J ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u> VEC[I, J] ≔               VEC[I, J] × DI; K ≔ INT[I];
         <u>if</u> K &gt; 0 <u>then</u> P ≔ P + 1 <u>else</u>
         <u>if</u> K &lt; 0 <u>then</u> Q ≔ Q - 1
      <u>end</u>;
   <u>for</u> I ≔ P - 1 + N - Q <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> K ≔ INT[I]; <u>if</u> K &gt; 0 <u>then</u>
         <u>begin</u> P ≔ P - 1; <u>if</u> K ≠ P <u>then</u>
              ICHROW(N1, N2, K, P, VEC)
         <u>end</u> <u>else</u>
         <u>begin</u> Q ≔ Q + 1; <u>if</u> -K ≠ Q <u>then</u>
              ICHROW(N1, N2, -K, Q, VEC)
         <u>end</u>
      <u>end</u>
<u>end</u> BAKLBR;
<u>comment</u> ================== 34361 ================= ;
<u>procedure</u> EQILBRCOM(A1, A2, N, EM, D, INT); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A1, A2, EM, D; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, P, Q, J, T, COUNT, EXPONENT, NI, IM, I1;
   <u>real</u> C, R, EPS;
   <u>procedure</u> ICHCOL(L, U, I, J, A); <u>code</u> 34031;
   <u>procedure</u> ICHROW(L, U, I, J, A); <u>code</u> 34032;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>procedure</u> MOVE(K); <u>value</u> K; <u>integer</u> K;
   <u>begin</u> <u>real</u> DI;
      NI ≔ Q - P; T ≔ T + 1; <u>if</u> K ≠ I <u>then</u>
      <u>begin</u> ICHCOL(1, N, K, I, A1); ICHROW(1, N, K, I, A1);
         ICHCOL(1, N, K, I, A2); ICHROW(1, N, K, I, A2);
         DI ≔ D[I]; D[I] ≔ D[K]; D[K] ≔ DI
      <u>end</u>
   <u>end</u> MOVE;
   EPS ≔ EM[0] ⭡ 4; T ≔ P ≔ 1; Q ≔ NI ≔ I ≔ N;
   COUNT ≔ EM[6];
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> D[J] ≔ 1; INT[J] ≔ 0 <u>end</u>;
   <u>for</u> I ≔ <u>if</u> I &lt; Q <u>then</u> I + 1 <u>else</u> P <u>while</u> COUNT &gt; 0∧ NI &gt; 0 <u>do</u>
      <u>begin</u> COUNT ≔ COUNT - 1; IM ≔ I - 1; I1 ≔ I + 1;
         C ≔ TAMMAT(P, IM, I, I, A1, A1) + TAMMAT(I1, Q, I,
           I, A1, A1) + TAMMAT(P, IM, I, I, A2, A2) +
           TAMMAT(I1, Q, I, I, A2, A2);
         R ≔ MATTAM(P, IM, I, I, A1, A1) + MATTAM(I1, Q, I,
           I, A1, A1) + MATTAM(P, IM, I, I, A2, A2) +
           MATTAM(I1, Q, I, I, A2, A2); <u>if</u> C / EPS &LessSlantEqual; R <u>then</u>
         <u>begin</u> INT[T] ≔ I; MOVE(P); P ≔ P + 1 <u>end</u>
           <u>else</u> <u>if</u> R / EPS &LessSlantEqual; C <u>then</u>
         <u>begin</u> INT[T] ≔ - I; MOVE(Q); Q ≔ Q - 1 <u>end</u>
         <u>else</u>
         <u>begin</u> EXPONENT ≔ LN(R / C) × 0·36067;
            <u>if</u> ABS(EXPONENT) &gt; 1 <u>then</u>
            <u>begin</u> NI ≔ Q - P; C ≔ 2 ⭡ EXPONENT;
               D[I] ≔ D[I] × C;
               <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> IM, I1 <u>step</u> 1
                 <u>until</u> N <u>do</u>
                  <u>begin</u> A1[J, I] ≔ A1[J, I] × C;
                     A1[I, J] ≔ A1[I, J] / C;
                     A2[J, I] ≔ A2[J, I] × C;
                     A2[I, J] ≔ A2[I, J] / C
                  <u>end</u>
            <u>end</u>
            <u>else</u> NI ≔ NI - 1
         <u>end</u>
      <u>end</u>;
   EM[7] ≔ EM[6] - COUNT
<u>end</u> EQILBRCOM;
<u>comment</u> ================== 34362 ================= ;
<u>procedure</u> BAKLBRCOM(N, N1, N2, D, INT, VR, VI);
   <u>value</u> N, N1, N2; <u>integer</u> N, N1, N2; <u>array</u> D, VR, VI;
     <u>integer</u> <u>array</u> INT;
<u>begin</u>
   <u>procedure</u> BAKLBR(N, N1, N2, D, INT, VEC); <u>code</u> 34174;
   BAKLBR(N, N1, N2, D, INT, VR);
   BAKLBR(N, N1, N2, D, INT, VI)
<u>end</u> BAKLBRCOM;
<u>comment</u> ================== 34140 ================= ;
<u>comment</u> MCA 2300;
<u>procedure</u> TFMSYMTRI2(A, N, D, B, BB, EM); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, B, BB, D, EM;
<u>begin</u> <u>integer</u> I, J, R, R1;
   <u>real</u> W, X, A1, B0, BB0, D0, MACHTOL, NORM;

   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>procedure</u> ELMCOLVEC(L, U, I, A, B, X); <u>code</u> 34022;

   NORM ≔ 0;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> W ≔ 0;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> J <u>do</u> W ≔ ABS(A[I, J]) + W;
         <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u> W ≔ ABS(A[J, I]) +
              W; <u>if</u> W &gt; NORM <u>then</u> NORM ≔ W
      <u>end</u>;
   MACHTOL ≔ EM[0] × NORM; EM[1] ≔ NORM; R ≔ N;
   <u>for</u> R1 ≔ N - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> D[R] ≔ A[R, R]; X ≔ TAMMAT(1, R - 2, R, R, A, A);
         A1 ≔ A[R1, R]; <u>if</u> SQRT(X) &LessSlantEqual; MACHTOL <u>then</u>
         <u>begin</u> B0 ≔ B[R1] ≔ A1; BB[R1] ≔ B0 × B0; A[R, R] ≔ 1 <u>end</u>
         <u>else</u>
         <u>begin</u> BB0 ≔ BB[R1] ≔ A1 × A1 + X;
            B0 ≔ <u>if</u> A1 &gt; 0 <u>then</u> -SQRT(BB0) <u>else</u> SQRT(BB0);
            A1 ≔ A[R1, R] ≔ A1 - B0; W ≔ A[R, R] ≔ 1 / (A1 × B0);
            <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> R1 <u>do</u> B[J] ≔ (TAMMAT(1,
                 J, J, R, A, A) + MATMAT(J + 1, R1, J, R, A, A)) × W;
            ELMVECCOL(1, R1, R, B, A, TAMVEC(1, R1, R, A, B) ×
              W × ·5); <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> R1 <u>do</u>
               <u>begin</u> ELMCOL(1, J, J, R, A, A, B[J]);
                  ELMCOLVEC(1, J, J, A, B, A[J, R])
               <u>end</u>; B[R1] ≔ B0
         <u>end</u>; R ≔ R1
      <u>end</u>;
   D[1] ≔ A[1, 1]; A[1, 1] ≔ 1; B[N] ≔ BB[N] ≔ 0
<u>end</u> TFMSYMTRI2;
<u>comment</u> ================== 34141 ================= ;
<u>comment</u> MCA 2301;
<u>procedure</u> BAKSYMTRI2(A, N, N1, N2, VEC); <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> A, VEC;
<u>begin</u> <u>integer</u> I, J, K; <u>real</u> W;

   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;

   <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> W ≔ A[J, J]; <u>if</u> W &lt; 0 <u>then</u>
           <u>for</u> K ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
              ELMCOL(1, J - 1, K, J, VEC, A,
              TAMMAT(1, J - 1, J, K, A, VEC) × W)
      <u>end</u>
<u>end</u> BAKSYMTRI2;
<u>comment</u> ================== 34142 ================= ;
<u>comment</u> MCA 2302;
<u>procedure</u> TFMPREVEC(A, N); <u>value</u> N; <u>integer</u> N; <u>array</u> A;
<u>begin</u> <u>integer</u> I, J, J1, K; <u>real</u> AB;

   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;

   J1 ≔ 1;
   <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> J1 - 1 ,
           J <u>step</u> 1 <u>until</u> N <u>do</u> A[I, J1] ≔ 0;
         A[J1, J1] ≔ 1; AB ≔ A[J, J];
         <u>if</u> AB &lt; 0 <u>then</u>
           <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> J1 <u>do</u>
              ELMCOL(1, J1, K, J, A, A,
              TAMMAT(1, J1, J, K, A, A) × AB); J1 ≔ J
      <u>end</u>;
   <u>for</u> I ≔ N - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
        A[I, N] ≔ 0; A[N, N] ≔ 1
<u>end</u> TFMPREVEC;
<u>comment</u> ================== 34143 ================= ;
<u>comment</u> MCA 2305;
<u>procedure</u> TFMSYMTRI1(A, N, D, B, BB, EM); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, B, BB, D, EM;
<u>begin</u> <u>integer</u> I, J, R, R1, P, Q, TI, TJ;
   <u>real</u> S, W, X, A1, B0, BB0, D0, NORM, MACHTOL;

   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> SEQVEC(L, U, IL, SHIFT, A, B); <u>code</u> 34016;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;

   NORM ≔ 0; TJ ≔ 0;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> W ≔ 0;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> J <u>do</u> W ≔ ABS(A[I + TJ]) + W;
         TJ ≔ TJ + J; TI ≔ TJ + J;
         <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> W ≔ ABS(A[TI]) + W; TI ≔ TI + I <u>end</u>;
         <u>if</u> W &gt; NORM <u>then</u> NORM ≔ W
      <u>end</u>;
   MACHTOL ≔ EM[0] × NORM; EM[1] ≔ NORM; Q ≔ (N + 1) × N ÷ 2;
   R ≔ N; <u>for</u> R1 ≔ N - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> P ≔ Q - R; D[R] ≔ A[Q];
         X ≔ VECVEC(P + 1, Q - 2, 0, A, A);
         A1 ≔ A[Q - 1]; <u>if</u> SQRT(X) &LessSlantEqual; MACHTOL <u>then</u>
         <u>begin</u> B0 ≔ B[R1] ≔ A1; BB[R1] ≔ B0 × B0; A[Q] ≔ 1 <u>end</u>
         <u>else</u>
         <u>begin</u> BB0 ≔ BB[R1] ≔ A1 × A1 + X;
            B0 ≔ <u>if</u> A1 &gt; 0 <u>then</u> -SQRT(BB0) <u>else</u> SQRT(BB0);
            A1 ≔ A[Q - 1] ≔ A1 - B0; W ≔ A[Q] ≔ 1 / (A1 × B0);
            TJ ≔ 0; <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> R1 <u>do</u>
               <u>begin</u> TI ≔ TJ + J; S ≔ VECVEC(TJ + 1, TI, P - TJ,
                    A, A); TJ ≔ TI + J;
                  B[J] ≔ (SEQVEC(J + 1, R1, TJ, P, A, A) + S) × W;
                  TJ ≔ TI
               <u>end</u>;
            ELMVEC(1, R1, P, B, A, VECVEC(1, R1, P, B, A) × W × ·5);
            TJ ≔ 0; <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> R1 <u>do</u>
               <u>begin</u> TI ≔ TJ + J; ELMVEC(TJ + 1, TI, P - TJ, A, A,
                    B[J]); ELMVEC(TJ + 1, TI, -TJ, A, B, A[J + P]);
                  TJ ≔ TI
               <u>end</u>; B[R1] ≔ B0
         <u>end</u>;
         Q ≔ P; R ≔ R1
      <u>end</u>;
   D[1] ≔ A[1]; A[1] ≔ 1; B[N] ≔ BB[N] ≔ 0
<u>end</u> TFMSYMTRI1;
<u>comment</u> ================== 34144 ================= ;
<u>comment</u> MCA 2306;
<u>procedure</u> BAKSYMTRI1(A, N, N1, N2, VEC); <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> A, VEC;
<u>begin</u> <u>integer</u> J, J1, K, TI, TJ;
   <u>real</u> W; <u>array</u> AUXVEC[1:N];

   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;

   <u>for</u> K ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              AUXVEC[J] ≔ VEC[J, K]; TJ ≔ J1 ≔ 1;
         <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> TI ≔ TJ + J; W ≔ A[TI];
               <u>if</u> W &lt; 0 <u>then</u> ELMVEC(1, J1, TJ, AUXVEC, A, VECVEC(1,
                 J1, TJ, AUXVEC, A) × W); J1 ≔ J; TJ ≔ TI
            <u>end</u>;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC[J, K] ≔ AUXVEC[J]
      <u>end</u>
<u>end</u> BAKSYMTRI1;
<u>comment</u> ================== 34170 ================= ;
<u>comment</u> MCA 2400;
<u>procedure</u> TFMREAHES(A, N, EM, INT); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, EM; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, J, J1, K, L;
   <u>real</u> S, T, MACHTOL, MACHEPS, NORM;
   <u>array</u> B[0:N - 1];

   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> ICHCOL(L, U, I, J, A); <u>code</u> 34031;
   <u>procedure</u> ICHROW(L, U, I, J, A); <u>code</u> 34032;

   MACHEPS ≔ EM[0]; NORM ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> S ≔ 0;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> S ≔ S + ABS(A[I, J]);
         <u>if</u> S &gt; NORM <u>then</u> NORM ≔ S
      <u>end</u>;
   EM[1] ≔ NORM; MACHTOL ≔ NORM × MACHEPS; INT[1] ≔ 0;
   <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> J1 ≔ J - 1; L ≔ 0; S ≔ MACHTOL;
         <u>for</u> K ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> T ≔ ABS(A[K, J1]); <u>if</u> T &gt; S <u>then</u>
               <u>begin</u> L ≔ K; S ≔ T <u>end</u>
            <u>end</u>;
         <u>if</u> L ≠ 0 <u>then</u>
         <u>begin</u> <u>if</u> ABS(A[J, J1]) &lt; S <u>then</u>
            <u>begin</u> ICHROW(1, N, J, L, A);
               ICHCOL(1, N, J, L, A)
            <u>end</u>
            <u>else</u> L ≔ J; T ≔ A[J, J1];
            <u>for</u> K ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 A[K, J1] ≔ A[K, J1] / T
         <u>end</u>
         <u>else</u>
           <u>for</u> K ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u> A[K, J1] ≔ 0;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              B[I - 1] ≔ A[I, J] ≔ A[I, J] +
              (<u>if</u> L = 0 <u>then</u> 0 <u>else</u> MATMAT(J + 1, N, I, J1, A, A))-
              MATVEC(1, <u>if</u> J1 &lt; I - 2 <u>then</u> J1 <u>else</u> I - 2, I, A, B);
         INT[J] ≔ L
      <u>end</u>
<u>end</u> TFMREAHES;
<u>comment</u> ================== 34171 ================= ;
<u>comment</u> MCA 2401;
<u>procedure</u> BAKREAHES1(A, N, INT, V); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, V; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, L;
   <u>real</u> W; <u>array</u> X[1:N];

   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;

   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u> X[I - 1] ≔ V[I];
   <u>for</u> I ≔ N <u>step</u> -1 <u>until</u> 2 <u>do</u>
      <u>begin</u> V[I] ≔ V[I] + MATVEC(1, I - 2, I, A, X);
         L ≔ INT[I]; <u>if</u> L &gt; I <u>then</u>
         <u>begin</u> W ≔ V[I]; V[I] ≔ V[L]; V[L] ≔ W <u>end</u>
      <u>end</u>
<u>end</u> BAKREAHES1;
<u>comment</u> ================== 34172 ================= ;
<u>comment</u> MCA 2402;
<u>procedure</u> BAKREAHES2(A, N, N1, N2, INT, VEC); <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> A, VEC; <u>integer</u> <u>array</u> INT;
<u>begin</u> <u>integer</u> I, L, K; <u>array</u> U[1:N];

   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>procedure</u> ICHROW(L, U, I, J, A); <u>code</u> 34032;

   <u>for</u> I ≔ N <u>step</u> -1 <u>until</u> 2 <u>do</u>
      <u>begin</u> <u>for</u> K ≔ I - 2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
              U[K + 1] ≔ A[I, K];
         <u>for</u> K ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
              VEC[I, K] ≔ VEC[I, K] + TAMVEC(2 , I - 1, K, VEC, U);
         L ≔ INT[I]; <u>if</u> L &gt; I <u>then</u> ICHROW(N1, N2, I, L, VEC)
      <u>end</u>
<u>end</u> BAKREAHES2;
<u>comment</u> ================== 34363 ================= ;
<u>procedure</u> HSHHRMTRI(A, N, D, B, BB, EM, TR, TI); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, D, B, BB, EM, TR, TI;
<u>begin</u> <u>integer</u> I, J, J1, JM1, R, RM1;
   <u>real</u> NRM, W, TOL2, X, AR, AI, MOD, C, S, H, K, T, Q,
     AJR, ARJ, BJ, BBJ;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;
   <u>procedure</u> ELMCOLVEC(L, U, I, A, B, X); <u>code</u> 34022;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>procedure</u> ELMROW(L, U, I, J, A, B, X); <u>code</u> 34024;
   <u>procedure</u> ELMVECROW(L, U, I, A, B, X); <u>code</u> 34026;
   <u>procedure</u> ELMROWVEC(L, U, I, A, B, X); <u>code</u> 34027;
   <u>procedure</u> ELMROWCOL(L, U, I, J, A, B, X); <u>code</u> 34028;
   <u>procedure</u> ELMCOLROW(L, U, I, J, A, B, X); <u>code</u> 34029;
   <u>procedure</u> CARPOL(AR, AI, R, C, S); <u>code</u> 34344;
   NRM ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> W ≔ ABS(A[I, I]);
         <u>for</u> J ≔ I - 1 <u>step</u> - 1 <u>until</u> 1, I + 1 <u>step</u> 1
           <u>until</u> N <u>do</u> W ≔ W + ABS(A[I, J]) + ABS(A[J, I]);
         <u>if</u> W &gt; NRM <u>then</u> NRM ≔ W
      <u>end</u> I;
   TOL2 ≔ (EM[0] × NRM) ⭡ 2; EM[1] ≔ NRM; R ≔ N;
   <u>for</u> RM1 ≔ N - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> X ≔ TAMMAT(1, R - 2, R, R, A, A) + MATTAM(1, R -
           2, R, R, A, A); AR ≔ A[RM1, R]; AI ≔ - A[R, RM1];
         D[R] ≔ A[R, R]; CARPOL(AR, AI, MOD, C, S);
         <u>if</u> X &lt; TOL2 <u>then</u>
         <u>begin</u> A[R, R] ≔ - 1; B[RM1] ≔ MOD;
            BB[RM1] ≔ MOD × MOD
         <u>end</u>
         <u>else</u>
         <u>begin</u> H ≔ MOD × MOD + X; K ≔ SQRT(H);
            T ≔ A[R, R] ≔ H + MOD × K;
            <u>if</u> AR = 0 ∧ AI = 0 <u>then</u> A[RM1, R] ≔ K <u>else</u>
            <u>begin</u> A[RM1, R] ≔ AR + C × K;
               A[R, RM1] ≔ - AI - S × K; S ≔ - S
            <u>end</u>;
            C ≔ - C; J ≔ 1; JM1 ≔ 0;
            <u>for</u> J1 ≔ 2 <u>step</u> 1 <u>until</u> R <u>do</u>
               <u>begin</u> B[J] ≔ (TAMMAT(1, J, J, R, A, A) +
                    MATMAT(J1, RM1, J, R, A, A) + MATTAM(1,
                    JM1, J, R, A, A) - MATMAT(J1, RM1, R, J,
                    A, A)) / T;
                  BB[J] ≔ (MATMAT(1, JM1, J, R, A, A) -
                    TAMMAT(J1, RM1, J, R, A, A) - MATMAT(1, J,
                    R, J, A, A) - MATTAM(J1, RM1, J, R, A, A))
                    / T; JM1 ≔ J; J ≔ J1
               <u>end</u> J1;
            Q ≔ (TAMVEC(1, RM1, R, A, B) - MATVEC(1, RM1,
              R, A, BB)) / T / 2;
            ELMVECCOL(1, RM1, R, B, A, - Q);
            ELMVECROW(1, RM1, R, BB, A, Q); J ≔ 1;
            <u>for</u> J1 ≔ 2 <u>step</u> 1 <u>until</u> R <u>do</u>
               <u>begin</u> AJR ≔ A[J, R]; ARJ ≔ A[R, J]; BJ ≔ B[J];
                  BBJ ≔ BB[J];
                  ELMROWVEC(J, RM1, J, A, B, - AJR);
                  ELMROWVEC(J, RM1, J, A, BB, ARJ);
                  ELMROWCOL(J, RM1, J, R, A, A, - BJ);
                  ELMROW(J, RM1, J, R, A, A, BBJ);
                  ELMCOLVEC(J1, RM1, J, A, B, - ARJ);
                  ELMCOLVEC(J1, RM1, J, A, BB, - AJR);
                  ELMCOL(J1, RM1, J, R, A, A, BBJ);
                  ELMCOLROW(J1, RM1, J, R, A, A, BJ); J ≔ J1;
               <u>end</u> J1;
            BB[RM1] ≔ H; B[RM1] ≔ K;
         <u>end</u>;
         TR[RM1] ≔ C; TI[RM1] ≔ S; R ≔ RM1;
      <u>end</u> RM1;
   D[1] ≔ A[1, 1];
<u>end</u> HSHHRMTRI;
<u>comment</u> ================== 34365 ================= ;
<u>procedure</u> BAKHRMTRI(A, N, N1, N2, VECR, VECI, TR, TI);
   <u>value</u> N, N1, N2; <u>integer</u> N, N1, N2;
     <u>array</u> A, VECR, VECI, TR, TI;
<u>begin</u> <u>integer</u> I, J, R, RM1;
   <u>real</u> C, S, T, QR, QI;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>procedure</u> ELMCOLROW(L, U, I, J, A, B, X); <u>code</u> 34029;
   <u>procedure</u> COMMUL(AR, AI, BR, BI, RR, RI); <u>code</u> 34341;
   <u>procedure</u> COMROWCST(L, U, I, AR, AI, XR, XI); <u>code</u> 34353;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>for</u> J ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u> VECI[I, J] ≔ 0; C ≔ 1;
   S ≔ 0;
   <u>for</u> J ≔ N - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> COMMUL(C, S, TR[J], TI[J], C, S);
         COMROWCST(N1, N2, J, VECR, VECI, C, S)
      <u>end</u> J;
   RM1 ≔ 2;
   <u>for</u> R ≔ 3 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> T ≔ A[R, R]; <u>if</u> T &gt; 0 <u>then</u>
           <u>for</u> J ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
            <u>begin</u> QR ≔ (TAMMAT(1, RM1, R, J, A, VECR) -
                 MATMAT(1, RM1, R, J, A, VECI)) / T;
               QI ≔ (TAMMAT(1, RM1, R, J, A, VECI) +
                 MATMAT(1, RM1, R, J, A, VECR)) / T;
               ELMCOL(1, RM1, J, R, VECR, A, - QR);
               ELMCOLROW(1, RM1, J, R, VECR, A, - QI);
               ELMCOLROW(1, RM1, J, R, VECI, A, QR);
               ELMCOL(1, RM1, J, R, VECI, A, - QI)
            <u>end</u>;
         RM1 ≔ R;
      <u>end</u> R;
<u>end</u> BAKHRMTRI;
<u>comment</u> ================== 34364 ================= ;
<u>procedure</u> HSHHRMTRIVAL(A, N, D, BB, EM); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, D, BB, EM;
<u>begin</u> <u>integer</u> I, J, J1, JM1, R, RM1;
   <u>real</u> NRM, W, TOL2, X, AR, AI, H, T, Q, AJR, ARJ, DJ,
     BBJ, MOD2;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;
   <u>procedure</u> ELMCOLVEC(L, U, I, A, B, X); <u>code</u> 34022;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>procedure</u> ELMROW(L, U, I, J, A, B, X); <u>code</u> 34024;
   <u>procedure</u> ELMVECROW(L, U, I, A, B, X); <u>code</u> 34026;
   <u>procedure</u> ELMROWVEC(L, U, I, A, B, X); <u>code</u> 34027;
   <u>procedure</u> ELMROWCOL(L, U, I, J, A, B, X); <u>code</u> 34028;
   <u>procedure</u> ELMCOLROW(L, U, I, J, A, B, X); <u>code</u> 34029;
   NRM ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> W ≔ ABS(A[I, I]);
         <u>for</u> J ≔ I - 1 <u>step</u> - 1 <u>until</u> 1, I + 1 <u>step</u> 1
           <u>until</u> N <u>do</u> W ≔ W + ABS(A[I, J]) + ABS(A[J, I]);
         <u>if</u> W &gt; NRM <u>then</u> NRM ≔ W
      <u>end</u> I;
   TOL2 ≔ (EM[0] × NRM) ⭡ 2; EM[1] ≔ NRM; R ≔ N;
   <u>for</u> RM1 ≔ N - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> X ≔ TAMMAT(1, R - 2, R, R, A, A) + MATTAM(1, R -
           2, R, R, A, A); AR ≔ A[RM1, R]; AI ≔ - A[R, RM1];
         D[R] ≔ A[R, R];
         <u>if</u> X &lt; TOL2 <u>then</u> BB[RM1] ≔ AR × AR + AI × AI <u>else</u>
         <u>begin</u> MOD2 ≔ AR × AR + AI × AI; <u>if</u> MOD2 = 0 <u>then</u>
            <u>begin</u> A[RM1, R] ≔ SQRT(X); T ≔ X <u>end</u>
            <u>else</u>
            <u>begin</u> X ≔ X + MOD2; H ≔ SQRT(MOD2 × X);
               T ≔ X + H; H ≔ 1 + X / H;
               A[R, RM1] ≔ - AI × H; A[RM1, R] ≔ AR × H;
            <u>end</u>;
            J ≔ 1; JM1 ≔ 0;
            <u>for</u> J1 ≔ 2 <u>step</u> 1 <u>until</u> R <u>do</u>
               <u>begin</u> D[J] ≔ (TAMMAT(1, J, J, R, A, A) +
                    MATMAT(J1, RM1, J, R, A, A) + MATTAM(1,
                    JM1, J, R, A, A) - MATMAT(J1, RM1, R, J,
                    A, A)) / T;
                  BB[J] ≔ (MATMAT(1, JM1, J, R, A, A) -
                    TAMMAT(J1, RM1, J, R, A, A) - MATMAT(1, J,
                    R, J, A, A) - MATTAM(J1, RM1, J, R, A, A))
                    / T; JM1 ≔ J; J ≔ J1
               <u>end</u> J1;
            Q ≔ (TAMVEC(1, RM1, R, A, D) - MATVEC(1, RM1,
              R, A, BB)) / T / 2;
            ELMVECCOL(1, RM1, R, D, A, - Q);
            ELMVECROW(1, RM1, R, BB, A, Q); J ≔ 1;
            <u>for</u> J1 ≔ 2 <u>step</u> 1 <u>until</u> R <u>do</u>

               <u>begin</u> AJR ≔ A[J, R]; ARJ ≔ A[R, J]; DJ ≔ D[J];
                  BBJ ≔ BB[J];
                  ELMROWVEC(J, RM1, J, A, D, - AJR);
                  ELMROWVEC(J, RM1, J, A, BB, ARJ);
                  ELMROWCOL(J, RM1, J, R, A, A, - DJ);
                  ELMROW(J, RM1, J, R, A, A, BBJ);
                  ELMCOLVEC(J1, RM1, J, A, D, - ARJ);
                  ELMCOLVEC(J1, RM1, J, A, BB, - AJR);
                  ELMCOL(J1, RM1, J, R, A, A, BBJ);
                  ELMCOLROW(J1, RM1, J, R, A, A, DJ); J ≔ J1;
               <u>end</u> J1;
            BB[RM1] ≔ X;
         <u>end</u>;
         R ≔ RM1;
      <u>end</u> RM1;
   D[1] ≔ A[1, 1];
<u>end</u> HSHHRMTRIVAL;
<u>comment</u> ================== 34366 ================= ;
<u>procedure</u> HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL); <u>value</u> N;
   <u>integer</u> N; <u>array</u> AR, AI, EM, B, TR, TI, DEL;
<u>begin</u> <u>integer</u> R, RM1, I, J, NM1;
   <u>real</u> TOL, T, XR, XI;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> ELMROWCOL(L, U, I, J, A, B, X); <u>code</u> 34028;
   <u>procedure</u> HSHCOMPRD(I, II, L, U, J, AR, AI, BR, BI, T); <u>code</u> 34356;
   <u>procedure</u> COMCOLCST(L, U, J, AR, AI, XR, XI); <u>code</u> 34352;
   <u>procedure</u> COMROWCST(L, U, I, AR, AI, XR, XI); <u>code</u> 34353;
   <u>procedure</u> CARPOL(AR, AI, R, C, S); <u>code</u> 34344;
   <u>procedure</u> COMMUL(AR, AI, BR, BI, RR, RI); <u>code</u> 34341;
   <u>Boolean</u> <u>procedure</u> HSHCOMCOL(L, U, J, AR, AI, TOL, K, C, S, T);
      <u>code</u> 34355;
   NM1 ≔ N - 1; TOL ≔ (EM[0] × EM[1]) ⭡ 2; RM1 ≔ 1;
   <u>for</u> R ≔ 2 <u>step</u> 1 <u>until</u> NM1 <u>do</u>
      <u>begin</u> <u>if</u> HSHCOMCOL(R, N, RM1, AR, AI, TOL, B[RM1],
           TR[R], TI[R], T) <u>then</u>
         <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> XR ≔ (MATMAT(R, N, I, RM1, AI, AI) -
                    MATMAT(R, N, I, RM1, AR, AR)) / T;
                  XI ≔ ( - MATMAT(R, N, I, RM1, AR, AI) -
                    MATMAT(R, N, I, RM1, AI, AR)) / T;
                  ELMROWCOL(R, N, I, RM1, AR, AR, XR);
                  ELMROWCOL(R, N, I, RM1, AR, AI, XI);
                  ELMROWCOL(R, N, I, RM1, AI, AR, XI);
                  ELMROWCOL(R, N, I, RM1, AI, AI, - XR)
               <u>end</u>;
            HSHCOMPRD(R, N, R, N, RM1, AR, AI, AR, AI, T);
         <u>end</u>;
         DEL[RM1] ≔ T; RM1 ≔ R
      <u>end</u> FORR;
   <u>if</u> N &gt; 1 <u>then</u> CARPOL(AR[N, NM1], AI[N, NM1], B[NM1],
     TR[N], TI[N]); RM1 ≔ 1; TR[1] ≔ 1; TI[1] ≔ 0;
   <u>for</u> R ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> COMMUL(TR[RM1], TI[RM1], TR[R], TI[R], TR[R],
           TI[R]); COMCOLCST(1, RM1, R, AR, AI, TR[R], TI[R]);
         COMROWCST(R + 1, N, R, AR, AI, TR[R], - TI[R]);
         RM1 ≔ R
      <u>end</u>;
<u>end</u> HSHCOMHES;
<u>comment</u> ================== 34367 ================= ;
<u>procedure</u> BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, N1, N2);
   <u>value</u> N, N1, N2; <u>integer</u> N, N1, N2;
     <u>array</u> AR, AI, TR, TI, DEL, VR, VI;
<u>begin</u> <u>integer</u> I, R, RM1;
   <u>real</u> H;
   <u>procedure</u> HSHCOMPRD(I, II, L, U, J, AR, AI, BR, BI, T); <u>code</u> 34356;
   <u>procedure</u> COMROWCST(L, U, I, AR, AI, XR, XI); <u>code</u> 34353;
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u> COMROWCST(N1, N2, I, VR,
        VI, TR[I], TI[I]); R ≔ N - 1;
   <u>for</u> RM1 ≔ N - 2 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> H ≔ DEL[RM1];
         <u>if</u> H &gt; 0 <u>then</u> HSHCOMPRD(R, N, N1, N2, RM1, VR, VI,
           AR, AI, H); R ≔ RM1
      <u>end</u>
<u>end</u> BAKCOMHES;
<u>comment</u> ================== 34260 ================= ;
<u>procedure</u> HSHREABID(A, M, N, D, B, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, D, B, EM;
<u>begin</u> <u>integer</u> I, J, I1;
   <u>real</u> NORM, MACHTOL, W, S, F, G, H;

   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B);
      <u>value</u> L, U, I, J; <u>integer</u> L, U, I, J; <u>array</u> A, B;
      <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B);
      <u>value</u> L, U, I, J; <u>array</u> A, B;
      <u>code</u> 34015;

   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X);
      <u>value</u> L, U, I, J, X; <u>integer</u> L, U, I, J; <u>real</u> X;
        <u>array</u> A, B;
      <u>code</u> 34023;
   <u>procedure</u> ELMROW(L, U, I, J, A, B, X);
      <u>value</u> L, U, I, J, X; <u>integer</u> L, U, I, J; <u>real</u> X;
        <u>array</u> A, B;
      <u>code</u> 34024;

   NORM ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
      <u>begin</u> W ≔ 0;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> W ≔ ABS(A[I, J]) + W;
         <u>if</u> W &gt; NORM <u>then</u> NORM ≔ W
      <u>end</u>;
   MACHTOL ≔ EM[0] × NORM; EM[1] ≔ NORM;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> I1 ≔ I + 1; S ≔ TAMMAT(I1, M, I, I, A, A);
         <u>if</u> S &lt; MACHTOL <u>then</u> D[I] ≔ A[I, I] <u>else</u>
         <u>begin</u> F ≔ A[I, I]; S ≔ F × F + S;
            D[I] ≔ G ≔ <u>if</u> F &lt; 0 <u>then</u> SQRT(S) <u>else</u> - SQRT(S);
            H ≔ F × G - S; A[I, I] ≔ F - G;
            <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 ELMCOL(I, M, J, I, A, A, TAMMAT(I, M, I, J, A, A) / H)
         <u>end</u>;
         <u>if</u> I &lt; N <u>then</u>
         <u>begin</u> S ≔ MATTAM(I1 + 1, N, I, I, A, A);
            <u>if</u> S &lt; MACHTOL <u>then</u> B[I] ≔ A[I, I1] <u>else</u>
            <u>begin</u> F ≔ A[I, I1]; S ≔ F × F + S;
               B[I] ≔ G ≔ <u>if</u> F &lt; 0 <u>then</u> SQRT(S) <u>else</u> - SQRT(S);
               H ≔ F × G - S; A[I, I1] ≔ F - G;
               <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> M <u>do</u>
                    ELMROW(I1, N, J, I, A, A, MATTAM(I1, N, I, J, A, A) /
                    H)
            <u>end</u>
         <u>end</u>
      <u>end</u>
<u>end</u> HSHREABID;
<u>comment</u> ================== 34261 ================= ;
<u>procedure</u> PSTTFMMAT(A, N, V, B);
   <u>value</u> N; <u>integer</u> N; <u>array</u> A, V, B;
<u>begin</u> <u>integer</u> I, I1, J;
   <u>real</u> H;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B);
      <u>value</u> L, U, I, J; <u>integer</u> L, U, I, J; <u>array</u> A, B;
      <u>code</u> 34013;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X);
      <u>value</u> L, U, I, J, X; <u>integer</u> L, U, I, J; <u>real</u> X;
        <u>array</u> A, B;
      <u>code</u> 34023;

   I1 ≔ N; V[N, N] ≔ 1;
   <u>for</u> I ≔ N - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> H ≔ B[I] × A[I, I1]; <u>if</u> H &lt; 0 <u>then</u>
         <u>begin</u> <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u> V[J, I] ≔ A[I, J] /
                 H;
            <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 ELMCOL(I1, N, J, I, V, V, MATMAT(I1, N, I, J, A, V))
         <u>end</u>;
         <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u> V[I, J] ≔ V[J, I] ≔ 0;
         V[I, I] ≔ 1; I1 ≔ I
      <u>end</u>
<u>end</u> PSTTFMMAT;
<u>comment</u> ================== 34262 ================= ;
<u>procedure</u> PRETFMMAT(A, M, N, D);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, D;
<u>begin</u> <u>integer</u> I, I1, J;
   <u>real</u> G, H;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B);
      <u>value</u> L, U, I, J; <u>integer</u> L, U, I, J; <u>array</u> A, B;
      <u>code</u> 34014;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X);
      <u>value</u> L, U, I, J, X; <u>integer</u> L, U, I, J; <u>real</u> X;
        <u>array</u> A, B;
      <u>code</u> 34023;

   <u>for</u> I ≔ N <u>step</u> - 1 <u>until</u> 1 <u>do</u>
      <u>begin</u> I1 ≔ I + 1; G ≔ D[I]; H ≔ G × A[I, I];
         <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u> A[I, J] ≔ 0;
         <u>if</u> H &lt; 0 <u>then</u>
         <u>begin</u> <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 ELMCOL(I, M, J, I, A, A, TAMMAT(I1, M, I, J, A, A) / H);
            <u>for</u> J ≔ I <u>step</u> 1 <u>until</u> M <u>do</u> A[J, I] ≔ A[J, I] / G
         <u>end</u>
         <u>else</u>
           <u>for</u> J ≔ I <u>step</u> 1 <u>until</u> M <u>do</u> A[J, I] ≔ 0;
         A[I, I] ≔ A[I, I] + 1
      <u>end</u>
<u>end</u> PRETFMMAT;
<u>comment</u> ================== 34151 ================= ;
<u>comment</u> MCA 2311;
<u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM);
   <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> D, BB, VAL, EM;
<u>begin</u> <u>integer</u> K, COUNT;
   <u>real</u> MAX, X, Y, MACHEPS, NORM, RE, MACHTOL, UB, LB, LAMBDA;

   <u>real</u> <u>procedure</u> STURM;
   <u>begin</u> <u>integer</u> P, I; <u>real</u> F;
      COUNT ≔ COUNT + 1;
      P ≔ K; F ≔ D[1] - X;
      <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>if</u> F &LessSlantEqual; 0 <u>then</u>
            <u>begin</u> P ≔ P + 1;
               <u>if</u> P &gt; N <u>then</u> <u>goto</u> OUT
            <u>end</u>
              <u>else</u> <u>if</u> P &lt; I - 1 <u>then</u>
            <u>begin</u> LB ≔ X; <u>goto</u> OUT <u>end</u>;
            <u>if</u> ABS(F) &lt; MACHTOL <u>then</u>
              F ≔ <u>if</u> F &LessSlantEqual; 0 <u>then</u> - MACHTOL <u>else</u> MACHTOL;
            F ≔ D[I] - X - BB[I - 1] / F
         <u>end</u>;
      <u>if</u> P = N ∨ F &LessSlantEqual; 0 <u>then</u>
      <u>begin</u> <u>if</u> X &lt; UB <u>then</u> UB ≔ X <u>end</u> <u>else</u> LB ≔ X;
      OUT: STURM ≔ <u>if</u> P = N <u>then</u> F <u>else</u> (N - P) × MAX
   <u>end</u> STURM;

   <u>Boolean</u> <u>procedure</u> ZEROIN(X, Y, FX, TOLX); <u>code</u> 34150;

   MACHEPS ≔ EM[0]; NORM ≔ EM[1]; RE ≔ EM[2];
   MACHTOL ≔ NORM × MACHEPS; MAX ≔ NORM / MACHEPS; COUNT ≔ 0;
   UB ≔ 1·1 × NORM; LB ≔ - UB; LAMBDA ≔ UB;
   <u>for</u> K ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> X ≔ LB; Y ≔ UB; LB ≔ -1·1  × NORM;
         ZEROIN(X, Y, STURM, ABS(X) × RE + MACHTOL);
         VAL[K] ≔ LAMBDA ≔ <u>if</u> X &gt; LAMBDA <u>then</u> LAMBDA <u>else</u> X;
         <u>if</u> UB &gt; X <u>then</u> UB ≔ <u>if</u> X &gt; Y <u>then</u> X <u>else</u> Y
      <u>end</u>;
   EM[3] ≔ COUNT
<u>end</u> VALSYMTRI;
<u>comment</u> ================== 34152 ================= ;
<u>comment</u> MCA 2312;
<u>procedure</u> VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM);
   <u>value</u> N, N1, N2;
   <u>integer</u> N, N1, N2; <u>array</u> D, B, VAL, VEC, EM;
<u>begin</u> <u>integer</u> I, J, K, COUNT, MAXCOUNT, COUNTLIM, ORTH, IND;
   <u>real</u> BI, BI1, U, W, Y, MI1, LAMBDA, OLDLAMBDA, ORTHEPS,
     VALSPREAD, SPR, RES, MAXRES, OLDRES, NORM, NEWNORM, OLDNORM,
     MACHTOL, VECTOL;
   <u>array</u> M, P, Q, R, X[1:N];
   <u>Boolean</u> <u>array</u> INT[1:N];

   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X); <u>code</u> 34021;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;

   NORM ≔ EM[1]; MACHTOL ≔ EM[0] × NORM; VALSPREAD ≔ EM[4] × NORM;
   VECTOL ≔ EM[6] × NORM; COUNTLIM ≔ EM[8]; ORTHEPS ≔ SQRT(EM[0]);
   MAXCOUNT ≔ IND ≔ 0; MAXRES ≔ 0;
   <u>if</u> N1 &gt; 1 <u>then</u>
   <u>begin</u> ORTH ≔ EM[5]; OLDLAMBDA ≔ VAL[N1 - ORTH];
      <u>for</u> K ≔ N1 - ORTH + 1 <u>step</u> 1 <u>until</u> N1 - 1  <u>do</u>
         <u>begin</u> LAMBDA ≔ VAL[K]; SPR ≔ OLDLAMBDA - LAMBDA;
            <u>if</u> SPR &lt; MACHTOL <u>then</u> LAMBDA ≔ OLDLAMBDA - MACHTOL;
            OLDLAMBDA ≔ LAMBDA
         <u>end</u>
   <u>end</u> <u>else</u> ORTH ≔ 1;
   <u>for</u> K ≔ N1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u> LAMBDA ≔ VAL[K]; <u>if</u> K &gt; 1 <u>then</u>
         <u>begin</u> SPR ≔ OLDLAMBDA - LAMBDA;
            <u>if</u> SPR &lt; VALSPREAD <u>then</u>
            <u>begin</u> <u>if</u> SPR &lt; MACHTOL <u>then</u>
                 LAMBDA ≔ OLDLAMBDA - MACHTOL;
               ORTH ≔ ORTH + 1
            <u>end</u> <u>else</u> ORTH ≔ 1
         <u>end</u>;
         COUNT ≔ 0; U ≔ D[1] - LAMBDA; BI ≔ W ≔ B[1];
         <u>if</u> ABS(BI) &lt; MACHTOL <u>then</u> BI ≔ MACHTOL;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1  <u>do</u>
            <u>begin</u> BI1 ≔ B[I + 1];
               <u>if</u> ABS(BI1) &lt; MACHTOL <u>then</u> BI1 ≔ MACHTOL;
               <u>if</u> ABS(BI) &GreaterSlantEqual; ABS(U) <u>then</u>
               <u>begin</u> MI1 ≔ M[I + 1] ≔ U / BI; P[I] ≔ BI;
                  Y ≔ Q[I] ≔ D[I + 1] - LAMBDA; R[I] ≔ BI1;
                  U ≔ W - MI1 × Y; W ≔ - MI1 × BI1; INT[I] ≔ <u>true</u>
               <u>end</u>
               <u>else</u>
               <u>begin</u> MI1 ≔ M[I + 1] ≔ BI / U; P[I] ≔ U; Q[I] ≔ W;
                  R[I] ≔ 0; U ≔ D[I + 1] - LAMBDA - MI1 × W; W ≔ BI1;
                  INT[I] ≔ <u>false</u>
               <u>end</u>;
               X[I] ≔ 1; BI ≔ BI1
            <u>end</u> TRANSFORM;

         P[N] ≔ <u>if</u> ABS(U) &lt; MACHTOL <u>then</u> MACHTOL <u>else</u> U;
         Q[N] ≔ R[N] ≔ 0; X[N] ≔ 1; <u>goto</u> ENTRY;
         ITERATE: W ≔ X[1];
         <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>if</u> INT[I - 1] <u>then</u>
               <u>begin</u> U ≔ W; W ≔ X[I - 1] ≔ X[I] <u>end</u>
               <u>else</u> U ≔ X[I]; W ≔ X[I] ≔ U - M[I] × W
            <u>end</u> ALTERNATE;
         ENTRY: U ≔ W ≔ 0;
         <u>for</u> I ≔ N <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> Y ≔ U; U ≔ X[I] ≔ (X[I] - Q[I] × U - R[I] × W) /
                 P[I]; W ≔ Y
            <u>end</u> NEXT ITERATION;
         NEWNORM ≔ SQRT(VECVEC(1, N, 0, X, X)); <u>if</u> ORTH &gt; 1 <u>then</u>
         <u>begin</u> OLDNORM ≔ NEWNORM;
            <u>for</u> J ≔ K - ORTH + 1 <u>step</u> 1 <u>until</u> K - 1 <u>do</u>
                 ELMVECCOL(1, N, J, X, VEC, -TAMVEC(1, N, J, VEC, X));
            NEWNORM ≔ SQRT(VECVEC(1, N, 0, X, X));
            <u>if</u> NEWNORM &lt; ORTHEPS × OLDNORM <u>then</u>
            <u>begin</u> IND ≔ IND + 1; COUNT ≔ 1;
               <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> IND - 1,
                 IND + 1 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ 0;
               X[IND] ≔ 1; <u>if</u> IND = N <u>then</u> IND ≔ 0;
               <u>goto</u> ITERATE
            <u>end</u> NEW START
         <u>end</u> ORTHOGONALISATION;
         RES ≔ 1 / NEWNORM; <u>if</u> RES &gt; VECTOL ∨ COUNT = 0 <u>then</u>
         <u>begin</u> COUNT ≔ COUNT + 1; <u>if</u> COUNT &LessSlantEqual; COUNTLIM <u>then</u>
            <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    X[I] ≔ X[I] × RES; <u>goto</u> ITERATE
            <u>end</u>
         <u>end</u>;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC[I, K] ≔ X[I] × RES;
         <u>if</u> COUNT &gt; MAXCOUNT <u>then</u> MAXCOUNT ≔ COUNT;
         <u>if</u> RES &gt; MAXRES <u>then</u> MAXRES ≔ RES; OLDLAMBDA ≔ LAMBDA
      <u>end</u>;
   EM[5] ≔ ORTH; EM[7] ≔ MAXRES; EM[9] ≔ MAXCOUNT
<u>end</u> VECSYMTRI;
<u>comment</u> ================== 34161 ================= ;
<u>comment</u> MCA 2321;
<u>integer</u> <u>procedure</u> QRISYMTRI(A, N, D, B, BB, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, D, B, BB, EM;
<u>begin</u> <u>integer</u> I, J, J1, K, M, M1, COUNT, MAX;
   <u>real</u> BBMAX, R, S, SIN, T, C, COS, OLDCOS, G, P, W, TOL, TOL2,
     LAMBDA, DK1, A0, A1;

   <u>procedure</u> ROTCOL(L, U, I, J, A, C, S); <u>code</u> 34040;

   TOL ≔ EM[2] × EM[1]; TOL2 ≔ TOL × TOL; COUNT ≔ 0; BBMAX ≔ 0;
   MAX ≔ EM[4]; M ≔ N;
   IN: K ≔ M; M1 ≔ M - 1;
   NEXT: K ≔ K - 1; <u>if</u> K &gt; 0 <u>then</u>
   <u>begin</u> <u>if</u> BB[K] &GreaterSlantEqual; TOL2 <u>then</u> <u>goto</u> NEXT;
      <u>if</u> BB[K] &gt; BBMAX <u>then</u> BBMAX ≔ BB[K]
   <u>end</u>;
   <u>if</u> K = M1 <u>then</u> M ≔ M1 <u>else</u>
   <u>begin</u>
      T ≔ D[M] - D[M1]; R ≔ BB[M1];
      <u>if</u> ABS(T) &lt; TOL <u>then</u> S ≔ SQRT(R) <u>else</u>
      <u>begin</u> W ≔ 2 / T; S ≔ W × R / (SQRT(W × W × R + 1) + 1)
      <u>end</u>; <u>if</u> K = M - 2 <u>then</u>
      <u>begin</u> D[M] ≔ D[M] + S; D[M1] ≔ D[M1] - S;
         T ≔ - S / B[M1]; R ≔ SQRT(T × T + 1); COS ≔ 1 / R;
         SIN ≔ T / R; ROTCOL(1, N, M1, M, A, COS, SIN); M ≔ M - 2
      <u>end</u>
      <u>else</u>
      <u>begin</u> COUNT ≔ COUNT + 1;
         <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> END;
         LAMBDA ≔ D[M] + S; <u>if</u> ABS(T) &lt; TOL <u>then</u>
         <u>begin</u> W ≔ D[M1] - S;
            <u>if</u> ABS(W) &lt; ABS(LAMBDA) <u>then</u> LAMBDA ≔ W
         <u>end</u>;
         K ≔ K + 1; T ≔ D[K] - LAMBDA; COS ≔ 1; W ≔ B[K];
         P ≔ SQRT(T × T + W × W); J1 ≔ K;
         <u>for</u> J ≔ K + 1 <u>step</u> 1 <u>until</u> M <u>do</u>
            <u>begin</u> OLDCOS ≔ COS; COS ≔ T / P; SIN ≔ W / P;
               DK1 ≔ D[J] - LAMBDA; T ≔ OLDCOS × T;
               D[J1] ≔ (T + DK1) × SIN × SIN + LAMBDA + T;
               T ≔ COS × DK1 - SIN × W × OLDCOS; W ≔ B[J];
               P ≔ SQRT(T × T + W × W); G ≔ B[J1] ≔ SIN × P;
               BB[J1] ≔ G × G; ROTCOL(1, N, J1, J, A, COS, SIN);
               J1 ≔ J
            <u>end</u>;
         D[M] ≔ COS × T + LAMBDA; <u>if</u> T &lt; 0 <u>then</u> B[M1] ≔ - G
      <u>end</u> QRSTEP
   <u>end</u>;
   <u>if</u> M &gt; 0 <u>then</u> <u>goto</u> IN;
   END: EM[3] ≔ SQRT(BBMAX); EM[5] ≔ COUNT; QRISYMTRI ≔ M
<u>end</u> QRISYMTRI;
<u>comment</u> ================== 34153 ================= ;
<u>comment</u> MCA 2313;
<u>procedure</u> EIGVALSYM2(A, N, NUMVAL, VAL, EM); <u>value</u> N, NUMVAL;
   <u>integer</u> N, NUMVAL; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB, D[1:N];

   <u>procedure</u> TFMSYMTRI2(A, N, D, B, BB, EM); <u>code</u> 34140;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;

   TFMSYMTRI2(A, N, D, B, BB, EM);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
<u>end</u> EIGVALSYM2;
<u>comment</u> ================== 34154 ================= ;
<u>comment</u> MCA 2314;
<u>procedure</u> EIGSYM2(A, N, NUMVAL, VAL, VEC, EM); <u>value</u> N, NUMVAL;
   <u>integer</u> N, NUMVAL; <u>array</u> A, VAL, VEC, EM;
<u>begin</u> <u>array</u> B, BB, D[1:N];

   <u>procedure</u> TFMSYMTRI2(A, N, D, B, BB, EM); <u>code</u> 34140;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;
   <u>procedure</u> VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM);
      <u>code</u> 34152;
   <u>procedure</u> BAKSYMTRI2(A, N, N1, N2, VEC); <u>code</u> 34141;

   TFMSYMTRI2(A, N, D, B, BB, EM);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM);
   VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VEC, EM);
   BAKSYMTRI2(A, N, 1, NUMVAL, VEC)
<u>end</u> EIGSYM2;
<u>comment</u> ================== 34155 ================= ;
<u>comment</u> MCA 2318;
<u>procedure</u> EIGVALSYM1(A, N, NUMVAL, VAL, EM); <u>value</u> N, NUMVAL;
   <u>integer</u> N, NUMVAL; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB, D[1:N];

   <u>procedure</u> TFMSYMTRI1(A, N, D, B, BB, EM); <u>code</u> 34143;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;

   TFMSYMTRI1(A, N, D, B, BB, EM);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
<u>end</u> EIGVALSYM1;
<u>comment</u> ================== 34156 ================= ;
<u>comment</u> MCA 2319;
<u>procedure</u> EIGSYM1(A, N, NUMVAL, VAL, VEC, EM); <u>value</u> N, NUMVAL;
   <u>integer</u> N, NUMVAL; <u>array</u> A, VAL, VEC, EM;
<u>begin</u> <u>array</u> B, BB, D[1:N];

   <u>procedure</u> TFMSYMTRI1(A, N, D, B, BB, EM); <u>code</u> 34143;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;
   <u>procedure</u> VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM);
      <u>code</u> 34152;
   <u>procedure</u> BAKSYMTRI1(A, N, N1, N2, VEC); <u>code</u> 34144;

   TFMSYMTRI1(A, N, D, B, BB, EM);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM);
   VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VEC, EM);
   BAKSYMTRI1(A, N, 1, NUMVAL, VEC)
<u>end</u> EIGSYM1;
<u>comment</u> ================== 34162 ================= ;
<u>comment</u> MCA 2322;
<u>integer</u> <u>procedure</u> QRIVALSYM2(A, N, VAL, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB[1:N];

   <u>procedure</u> TFMSYMTRI2(A, N, D, B, BB, EM); <u>code</u> 34140;
   <u>integer</u> <u>procedure</u> QRIVALSYMTRI(D, BB, N, EM);
      <u>code</u> 34160;

   TFMSYMTRI2(A, N, VAL, B, BB, EM);
   QRIVALSYM2 ≔ QRIVALSYMTRI(VAL, BB, N, EM)
<u>end</u> QRIVALSYM2;
<u>comment</u> ================== 34163 ================= ;
<u>comment</u> MCA 2323;
<u>integer</u> <u>procedure</u> QRISYM(A, N, VAL, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB[1:N];

   <u>procedure</u> TFMSYMTRI2(A, N, D, B, BB, EM); <u>code</u> 34140;
   <u>procedure</u> TFMPREVEC(A, N); <u>code</u> 34142;
   <u>integer</u> <u>procedure</u> QRISYMTRI(A, N, D, B, BB, EM);
      <u>code</u> 34161;

   TFMSYMTRI2(A, N, VAL, B, BB, EM); TFMPREVEC(A, N);
   QRISYM ≔ QRISYMTRI(A, N, VAL, B, BB, EM)
<u>end</u> QRISYM;
<u>comment</u> ================== 34164 ================= ;
<u>comment</u> MCA 2327;
<u>integer</u> <u>procedure</u> QRIVALSYM1(A, N, VAL, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB[1 : N];

   <u>procedure</u> TFMSYMTRI1(A, N, D, B, BB, EM); <u>code</u> 34143;
   <u>integer</u> <u>procedure</u> QRIVALSYMTRI(D, BB, N, EM);
      <u>code</u> 34160;

   TFMSYMTRI1(A, N, VAL, B, BB, EM);
   QRIVALSYM1 ≔ QRIVALSYMTRI(VAL, BB, N, EM)
<u>end</u> QRIVALSYM1;
<u>comment</u> ================== 34180 ================= ;
<u>comment</u> MCA 2410;
<u>integer</u> <u>procedure</u> REAVALQRI(A, N, EM, VAL); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, VAL;
<u>begin</u> <u>integer</u> N1, I, I1, J, Q, MAX, COUNT;
   <u>real</u> DET, W, SHIFT, KAPPA, NU, MU, R, TOL, DELTA, MACHTOL, S;

   <u>procedure</u> ROTCOL(L, U, I, J, A, C, S); <u>code</u> 34040;
   <u>procedure</u> ROTROW(L, U, I, J, A, C, S); <u>code</u> 34041;
   MACHTOL ≔ EM[0] × EM[1]; TOL ≔ EM[1] × EM[2]; MAX ≔ EM[4];
   COUNT ≔ 0; R ≔ 0;
   IN: N1 ≔ N - 1;
   <u>for</u> I ≔ N, I - 1 <u>while</u> (<u>if</u> I &GreaterSlantEqual; 1 <u>then</u>
     ABS(A[I + 1, I]) &gt; TOL <u>else</u> <u>false</u>) <u>do</u> Q ≔ I;
   <u>if</u> Q &gt; 1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(A[Q, Q - 1]) &gt; R <u>then</u>
        R ≔ ABS(A[Q, Q - 1])
   <u>end</u>;
   <u>if</u> Q = N <u>then</u>
   <u>begin</u> VAL[N] ≔ A[N, N]; N ≔ N1 <u>end</u>
   <u>else</u>
   <u>begin</u> DELTA ≔ A[N, N] - A[N1, N1]; DET ≔ A[N, N1] × A[N1, N];
      <u>if</u> ABS(DELTA) &lt; MACHTOL <u>then</u> S ≔ SQRT(DET) <u>else</u>
      <u>begin</u> W ≔ 2 / DELTA; S ≔ W × W × DET + 1;
         S ≔ <u>if</u> S &LessSlantEqual; 0 <u>then</u> -DELTA × ·5 <u>else</u>
           W × DET / (SQRT(S) + 1)
      <u>end</u>;
      <u>if</u> Q = N1 <u>then</u>
      <u>begin</u> VAL[N] ≔ A[N, N] + S;
         VAL[N1] ≔ A[N1, N1] - S; N ≔ N - 2
      <u>end</u>
      <u>else</u>
      <u>begin</u> COUNT ≔ COUNT + 1;
         <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> OUT;
         SHIFT ≔ A[N, N] + S; <u>if</u> ABS(DELTA) &lt; TOL <u>then</u>
         <u>begin</u> W ≔ A[N1, N1] - S;
            <u>if</u> ABS(W) &lt; ABS(SHIFT) <u>then</u> SHIFT ≔ W
         <u>end</u>;
         A[Q, Q] ≔ A[Q, Q] - SHIFT;
         <u>for</u> I ≔ Q <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
            <u>begin</u> I1 ≔ I + 1; A[I1, I1] ≔ A[I1, I1] - SHIFT;
               KAPPA ≔ SQRT(A[I, I] ⭡ 2 + A[I1, I] ⭡ 2);
               <u>if</u> I &gt; Q <u>then</u>
               <u>begin</u> A[I, I - 1] ≔ KAPPA × NU;
                  W ≔ KAPPA × MU
               <u>end</u>
               <u>else</u> W ≔ KAPPA; MU ≔ A[I, I] / KAPPA;
               NU ≔ A[I1, I] / KAPPA; A[I, I] ≔ W;
               ROTROW(I1, N, I, I1, A, MU, NU);
               ROTCOL(Q, I, I, I1, A, MU, NU);
               A[I, I] ≔ A[I, I] + SHIFT
            <u>end</u>;
         A[N, N - 1] ≔ A[N, N] × NU; A[N, N] ≔ A[N, N] × MU + SHIFT
      <u>end</u>
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   OUT: EM[3] ≔ R; EM[5] ≔ COUNT; REAVALQRI ≔ N
<u>end</u> REAVALQRI;
<u>comment</u> ================== 34181 ================= ;
<u>comment</u> MCA 2411;
<u>procedure</u> REAVECHES(A, N, LAMBDA, EM, V); <u>value</u> N, LAMBDA;
   <u>integer</u> N; <u>real</u> LAMBDA; <u>array</u> A, EM, V;
<u>begin</u> <u>integer</u> I, I1, J, COUNT, MAX;
   <u>real</u> M, R, NORM, MACHTOL, TOL;
   <u>Boolean</u> <u>array</u> P[1:N];

   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;

   NORM ≔ EM[1]; MACHTOL ≔ EM[0] × NORM; TOL ≔ EM[6] × NORM;
   MAX ≔ EM[8]; A[1, 1] ≔ A[1, 1] - LAMBDA;
   GAUSS: <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
      <u>begin</u> I1 ≔ I + 1; R ≔ A[I, I]; M ≔ A[I1, I];
         <u>if</u> ABS(M) &lt; MACHTOL <u>then</u> M ≔ MACHTOL;
         P[I] ≔ ABS(M) &LessSlantEqual; ABS(R);
         <u>if</u> P[I] <u>then</u>
         <u>begin</u> A[I1, I] ≔ M ≔ M / R;
            <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 A[I1, J] ≔ (<u>if</u> J &gt; I1 <u>then</u> A[I1, J]
               <u>else</u> A[I1, J] - LAMBDA) - M × A[I, J]
         <u>end</u>
         <u>else</u>
         <u>begin</u> A[I, I] ≔ M; A[I1, I] ≔ M ≔ R / M;
            <u>for</u> J ≔ I1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> R ≔ (<u>if</u> J &gt; I1 <u>then</u> A[I1, J] <u>else</u>
                    A[I1, J] - LAMBDA);
                  A[I1, J] ≔ A[I, J] - M × R; A[I, J] ≔ R
               <u>end</u>
         <u>end</u>
      <u>end</u> GAUSS;
   <u>if</u> ABS(A[N, N]) &lt; MACHTOL <u>then</u> A[N, N] ≔ MACHTOL;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> V[J] ≔ 1; COUNT ≔ 0;
   FORWARD: COUNT ≔ COUNT + 1; <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> OUT;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
      <u>begin</u> I1 ≔ I + 1;
         <u>if</u> P[I] <u>then</u> V[I1] ≔ V[I1] - A[I1, I] × V[I] <u>else</u>
         <u>begin</u> R ≔ V[I1]; V[I1] ≔ V[I] - A[I1, I] × R;
            V[I] ≔ R
         <u>end</u>
      <u>end</u> FORWARD;
   BACKWARD: <u>for</u> I ≔ N <u>step</u> -1 <u>until</u> 1 <u>do</u>
        V[I] ≔ (V[I] - MATVEC(I + 1, N, I, A, V)) / A[I, I];
   R ≔ 1 / SQRT(VECVEC(1, N, 0, V, V));
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> V[J] ≔ V[J] × R;
   <u>if</u> R &gt; TOL <u>then</u> <u>goto</u> FORWARD;
   OUT: EM[7] ≔ R; EM[9] ≔ COUNT
<u>end</u> REAVECHES;
<u>comment</u> ================== 34186 ================= ;
<u>comment</u> MCA 2416;
<u>integer</u> <u>procedure</u> REAQRI(A, N, EM, VAL, VEC); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, VAL, VEC;
<u>begin</u> <u>integer</u> M1, I, I1, M, J, Q, MAX, COUNT;
   <u>real</u> W, SHIFT, KAPPA, NU, MU, R, TOL, S, MACHTOL,
     ELMAX, T, DELTA, DET;
   <u>array</u> TF[1:N];

   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> ROTCOL(L, U, I, J, A, C, S); <u>code</u> 34040;
   <u>procedure</u> ROTROW(L, U, I, J, A, C, S); <u>code</u> 34041;

   MACHTOL ≔ EM[0] × EM[1]; TOL ≔ EM[1] × EM[2]; MAX ≔ EM[4];
   COUNT ≔ 0; ELMAX ≔ 0; M ≔ N;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> VEC[I, I] ≔ 1;
         <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              VEC[I, J] ≔ VEC[J, I] ≔ 0
      <u>end</u>;
   IN: M1 ≔ M - 1;
   <u>for</u> I ≔ M, I - 1 <u>while</u> (<u>if</u> I &GreaterSlantEqual; 1 <u>then</u>
     ABS(A[I + 1, I]) &gt; TOL <u>else</u> <u>false</u>) <u>do</u> Q ≔ I;
   <u>if</u> Q &gt; 1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(A[Q, Q - 1]) &gt; ELMAX <u>then</u>
        ELMAX ≔ ABS(A[Q, Q - 1])
   <u>end</u>;
   <u>if</u> Q = M <u>then</u>
   <u>begin</u> VAL[M] ≔ A[M, M]; M ≔ M1 <u>end</u>
   <u>else</u>
   <u>begin</u> DELTA ≔ A[M, M] - A[M1, M1]; DET ≔ A[M, M1] × A[M1, M];
      <u>if</u> ABS(DELTA) &lt; MACHTOL <u>then</u> S ≔ SQRT(DET) <u>else</u>
      <u>begin</u> W ≔ 2 / DELTA; S ≔ W × W × DET + 1;
         S ≔ <u>if</u> S &LessSlantEqual; 0 <u>then</u> -DELTA × ·5 <u>else</u>
           W × DET / (SQRT(S) + 1)
      <u>end</u>;
      <u>if</u> Q = M1 <u>then</u>
      <u>begin</u> A[M, M] ≔ VAL[M] ≔ A[M, M] + S;
         A[Q, Q] ≔ VAL[Q] ≔ A[Q, Q] - S;
         T ≔ <u>if</u> ABS(S) &lt; MACHTOL <u>then</u>
           (S + DELTA) / A[M, Q] <u>else</u> A[Q, M] / S;
         R ≔ SQRT(T × T + 1); NU ≔ 1 / R;
         MU ≔ -T × NU; A[Q, M] ≔ A[Q, M] - A[M, Q];
         ROTROW(Q + 2, N, Q, M, A, MU, NU);
         ROTCOL(1, Q - 1, Q, M, A, MU, NU);
         ROTCOL(1, N, Q, M, VEC, MU, NU); M ≔ M - 2
      <u>end</u>
      <u>else</u>
      <u>begin</u> COUNT ≔ COUNT + 1;
         <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> END;
         SHIFT ≔ A[M, M] + S; <u>if</u> ABS(DELTA) &lt; TOL <u>then</u>
         <u>begin</u> W ≔ A[M1, M1] - S;
            <u>if</u> ABS(W) &lt; ABS(SHIFT) <u>then</u> SHIFT ≔ W
         <u>end</u>;
         A[Q, Q] ≔ A[Q, Q] - SHIFT;
         <u>for</u> I ≔ Q <u>step</u> 1 <u>until</u> M1 <u>do</u>
            <u>begin</u> I1 ≔ I + 1; A[I1, I1] ≔ A[I1, I1] - SHIFT;
               KAPPA ≔ SQRT(A[I, I] ⭡ 2 + A[I1, I] ⭡ 2);
               <u>if</u> I &gt; Q <u>then</u>
               <u>begin</u> A[I, I - 1] ≔ KAPPA × NU;
                  W ≔ KAPPA × MU
               <u>end</u>
               <u>else</u> W ≔ KAPPA; MU ≔ A[I, I] / KAPPA;
               NU ≔ A[I1, I] / KAPPA; A[I, I] ≔ W;
               ROTROW(I1, N, I, I1, A, MU, NU);
               ROTCOL(1, I, I, I1, A, MU, NU);
               A[I, I] ≔ A[I, I] + SHIFT;
               ROTCOL(1, N, I, I1, VEC, MU, NU)
            <u>end</u>;
         A[M, M1] ≔ A[M, M] × NU; A[M, M] ≔ A[M, M] × MU + SHIFT
      <u>end</u>
   <u>end</u>;
   <u>if</u> M &gt; 0 <u>then</u> <u>goto</u> IN;
   <u>for</u> J ≔ N <u>step</u> -1 <u>until</u> 2 <u>do</u>
      <u>begin</u> TF[J] ≔ 1; T ≔ A[J, J];
         <u>for</u> I ≔ J - 1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> DELTA ≔ T - A[I, I];
               TF[I] ≔ MATVEC(I + 1, J, I, A, TF) /
                 (<u>if</u> ABS(DELTA) &lt; MACHTOL <u>then</u> MACHTOL <u>else</u> DELTA)
            <u>end</u>;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              VEC[I, J] ≔ MATVEC(1, J, I, VEC, TF)
      <u>end</u>;
   END: EM[3] ≔ ELMAX; EM[5] ≔ COUNT; REAQRI ≔ M
<u>end</u> REAQRI;
<u>comment</u> ================== 34190 ================= ;
<u>comment</u> MCA 2420;
<u>integer</u> <u>procedure</u> COMVALQRI(A, N, EM, RE, IM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, RE, IM;
<u>begin</u> <u>integer</u> I, J, P, Q, MAX, COUNT, N1, P1, P2, IMIN1,
     I1, I2, I3;
   <u>real</u> DISC, SIGMA, RHO, G1, G2, G3, PSI1, PSI2, AA, E, K,
     S, NORM, MACHTOL2, TOL, W;
   <u>Boolean</u> B;

   NORM ≔ EM[1]; MACHTOL2 ≔ (EM[0] × NORM) ⭡ 2;
   TOL ≔ EM[2] × NORM; MAX ≔ EM[4]; COUNT ≔ 0; W ≔ 0;
   IN: <u>for</u> I ≔ N, I - 1 <u>while</u>
     (<u>if</u> I &GreaterSlantEqual; 1 <u>then</u> ABS(A[I + 1, I]) &gt; TOL <u>else</u> <u>false</u>)
     <u>do</u> Q ≔ I; <u>if</u> Q &gt; 1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(A[Q, Q - 1]) &gt; W <u>then</u> W ≔ ABS(A[Q, Q - 1])
   <u>end</u>;
   <u>if</u> Q &GreaterSlantEqual; N - 1 <u>then</u>
   <u>begin</u> N1 ≔ N - 1; <u>if</u> Q = N <u>then</u>
      <u>begin</u> RE[N] ≔ A[N, N]; IM[N] ≔ 0; N ≔ N1 <u>end</u>
      <u>else</u>
      <u>begin</u> SIGMA ≔ A[N, N] - A[N1, N1];
         RHO ≔ -A[N, N1] × A[N1, N];
         DISC ≔ SIGMA ⭡ 2 - 4 × RHO; <u>if</u> DISC &gt; 0 <u>then</u>
         <u>begin</u> DISC ≔ SQRT(DISC);
            S ≔ -2 × RHO / (SIGMA + (<u>if</u> SIGMA &GreaterSlantEqual; 0
              <u>then</u> DISC <u>else</u> -DISC));
            RE[N] ≔ A[N, N] + S;
            RE[N1] ≔ A[N1, N1] - S; IM[N] ≔ IM[N1] ≔ 0
         <u>end</u>
         <u>else</u>
         <u>begin</u> RE[N] ≔ RE[N1] ≔ (A[N1, N1] + A[N, N]) / 2;
            IM[N1] ≔ SQRT( -DISC) / 2; IM[N] ≔ -IM[N1]
         <u>end</u>;
         N ≔ N - 2
      <u>end</u>
   <u>end</u>
   <u>else</u>
   <u>begin</u> COUNT ≔ COUNT + 1; <u>if</u> COUNT &gt; MAX <u>then</u>
        <u>goto</u> OUT; N1 ≔ N - 1;
      SIGMA ≔ A[N, N] + A[N1, N1] + SQRT(ABS(A[N1, N - 2] × A[N, N1])× EM[0]); RHO ≔ A[N, N] × A[N1, N1] - A[N, N1] × A[N1, N];
      <u>for</u> I ≔ N - 1, I - 1 <u>while</u>
        (<u>if</u> I - 1 &GreaterSlantEqual; Q <u>then</u> ABS(A[I, I - 1] ×
        A[I1, I] × (ABS(A[I, I] + A[I1, I1] - SIGMA) +
        ABS(A[I + 2, I1]))) &gt; ABS(A[I, I] × ((A[I, I] - SIGMA) +
        A[I, I1] × A[I1, I] + RHO)) × TOL
      <u>else</u> <u>false</u>) <u>do</u> P1 ≔ I1 ≔ I; P ≔ P1 - 1;
      P2 ≔ P + 2;
      <u>for</u> I ≔ P <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
         <u>begin</u> IMIN1 ≔ I - 1; I1 ≔ I + 1; I2 ≔ I + 2;
            <u>if</u> I = P <u>then</u>
            <u>begin</u> G1 ≔ A[P, P] × (A[P, P] - SIGMA) + A[P, P1] ×
                 A[P1, P] + RHO;
               G2 ≔ A[P1, P] × (A[P, P] + A[P1, P1] - SIGMA);
               <u>if</u> P1 &LessSlantEqual; N1 <u>then</u>
               <u>begin</u> G3 ≔ A[P1, P] × A[P2, P1]; A[P2, P] ≔ 0 <u>end</u>
               <u>else</u> G3 ≔ 0
            <u>end</u>
            <u>else</u>
            <u>begin</u> G1 ≔ A[I, IMIN1]; G2 ≔ A[I1, IMIN1];
               G3 ≔ <u>if</u> I2 &LessSlantEqual; N <u>then</u> A[I2, IMIN1] <u>else</u> 0
            <u>end</u>;
            K ≔ <u>if</u> G1 &GreaterSlantEqual; 0 <u>then</u>
              SQRT(G1 ⭡ 2 + G2 ⭡ 2 + G3 ⭡ 2) <u>else</u>
              -SQRT(G1 ⭡ 2 + G2 ⭡ 2 + G3 ⭡ 2);
            B ≔ ABS(K) &gt; MACHTOL2;
            AA ≔ <u>if</u> B <u>then</u> G1 / K + 1 <u>else</u> 2;
            PSI1 ≔ <u>if</u> B <u>then</u> G2 / (G1 + K) <u>else</u> 0;
            PSI2 ≔ <u>if</u> B <u>then</u> G3 / (G1 + K) <u>else</u> 0;
            <u>if</u> I ≠ Q <u>then</u> A[I, IMIN1] ≔ <u>if</u> I = P <u>then</u>
              -A[I, IMIN1] <u>else</u> -K;
            <u>for</u> J ≔ I <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> E ≔ AA × (A[I, J] + PSI1 × A[I1, J] +
                    (<u>if</u> I2 &LessSlantEqual; N <u>then</u> PSI2 × A[I2, J] <u>else</u> 0));
                  A[I, J] ≔ A[I, J] - E; A[I1, J] ≔ A[I1, J] - PSI1 × E;
                  <u>if</u> I2 &LessSlantEqual; N <u>then</u> A[I2, J] ≔ A[I2, J] - PSI2 × E
               <u>end</u>;
            <u>for</u> J ≔ Q <u>step</u> 1 <u>until</u>
              (<u>if</u> I2 &LessSlantEqual; N <u>then</u> I2 <u>else</u> N) <u>do</u>
               <u>begin</u> E ≔ AA × (A[J, I] + PSI1 × A[J, I1] +
                    (<u>if</u> I2 &LessSlantEqual; N <u>then</u> PSI2 × A[J, I2] <u>else</u> 0));
                  A[J, I] ≔ A[J, I] - E; A[J, I1] ≔ A[J, I1] - PSI1 × E;
                  <u>if</u> I2 &LessSlantEqual; N <u>then</u> A[J, I2] ≔ A[J, I2] - PSI2 × E
               <u>end</u>;
            <u>if</u> I2 &LessSlantEqual; N1 <u>then</u>
            <u>begin</u> I3 ≔ I + 3; E ≔ AA × PSI2 × A[I3, I2];
               A[I3, I] ≔ -E;
               A[I3, I1] ≔ -PSI1 × E;
               A[I3, I2] ≔ A[I3, I2] - PSI2 × E
            <u>end</u>
         <u>end</u>
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   OUT: EM[3] ≔ W; EM[5] ≔ COUNT; COMVALQRI ≔ N
<u>end</u> COMVALQRI;
<u>comment</u> ================== 34191 ================= ;
<u>comment</u> MCA 2421;
<u>procedure</u> COMVECHES(A, N, LAMBDA, MU, EM, U, V);
   <u>value</u> N, LAMBDA, MU;
   <u>integer</u> N; <u>real</u> LAMBDA, MU; <u>array</u> A, EM, U, V;
<u>begin</u> <u>integer</u> I, I1, J, COUNT, MAX;
   <u>real</u> AA, BB, D, M, R, S, W, X, Y, NORM, MACHTOL, TOL;
   <u>array</u> G, F[1:N];
   <u>Boolean</u> <u>array</u> P[1:N];

   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;

   NORM ≔ EM[1]; MACHTOL ≔ EM[0] × NORM; TOL ≔ EM[6] × NORM;
   MAX ≔ EM[8];
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> F[I - 1] ≔ A[I, I - 1]; A[I, 1] ≔ 0 <u>end</u>;
   AA ≔ A[1, 1] - LAMBDA; BB ≔ -MU;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
      <u>begin</u> I1 ≔ I + 1; M ≔ F[I];
         <u>if</u> ABS(M) &lt; MACHTOL <u>then</u> M ≔ MACHTOL;
         A[I, I] ≔ M; D ≔ AA ⭡ 2 + BB ⭡ 2; P[I] ≔ ABS(M) &lt; SQRT(D);
         <u>if</u> P[I] <u>then</u>
         <u>begin</u> <u>comment</u> A[I, J] × FACTOR AND A[I1, J] - A[I, J];
            F[I] ≔ R ≔ M × AA / D; G[I] ≔ S ≔ -M × BB / D;
            W ≔ A[I1, I]; X ≔ A[I, I1]; A[I1, I] ≔ Y ≔ X × S + W × R;
            A[I, I1] ≔ X ≔ X × R - W × S;
            AA ≔ A[I1, I1] - LAMBDA - X; BB ≔ -(MU + Y);
            <u>for</u> J ≔ I + 2 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> W ≔ A[J, I]; X ≔ A[I, J];
                  A[J, I] ≔ Y ≔ X × S + W × R;
                  A[I, J] ≔ X ≔ X × R - W × S; A[J, I1] ≔ -Y;
                  A[I1, J] ≔ A[I1, J] - X
               <u>end</u>
         <u>end</u>
         <u>else</u>
         <u>begin</u> <u>comment</u> INTERCHANGE A[I1, J] AND
              A[I, J] - A[I1, J] × FACTOR;
            F[I] ≔ R ≔ AA / M; G[I] ≔ S ≔ BB / M;
            W ≔ A[I1, I1] - LAMBDA; AA ≔ A[I, I1] - R × W - S × MU;
            A[I, I1] ≔ W; BB ≔ A[I1, I] - S × W + R × MU;
            A[I1, I] ≔ -MU;
            <u>for</u> J ≔ I + 2 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> W ≔ A[I1, J]; A[I1, J] ≔ A[I, J] - R × W;
                  A[I, J] ≔ W;
                  A[J, I1] ≔ A[J, I] - S × W; A[J, I] ≔ 0
               <u>end</u>
         <u>end</u>
      <u>end</u>
        P[N] ≔ <u>true</u>; D ≔ AA ⭡ 2 + BB ⭡ 2; <u>if</u> D &lt; MACHTOL ⭡ 2
     <u>then</u> <u>begin</u> AA ≔ MACHTOL; BB ≔ 0; D ≔ MACHTOL ⭡ 2 <u>end</u>;
   A[N, N] ≔ D; F[N] ≔ AA; G[N] ≔ -BB;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> U[I] ≔ 1; V[I] ≔ 0 <u>end</u>;
   COUNT ≔ 0;
   FORWARD: <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> OUTM;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> P[I] <u>then</u>
         <u>begin</u> W ≔ V[I]; V[I] ≔ G[I] × U[I] + F[I] × W;
            U[I] ≔ F[I] × U[I] - G[I] × W; <u>if</u> I &lt; N <u>then</u>
            <u>begin</u> V[I + 1] ≔ V[I + 1] - V[I];
               U[I + 1] ≔ U[I + 1] - U[I]
            <u>end</u>
         <u>end</u>
         <u>else</u>
         <u>begin</u> AA ≔ U[I + 1]; BB ≔ V[I + 1];
            U[I + 1] ≔ U[I] - (F[I] × AA - G[I] × BB); U[I] ≔ AA;
            V[I + 1] ≔ V[I] - (G[I] × AA + F[I] × BB); V[I] ≔ BB
         <u>end</u>
      <u>end</u> FORWARD;
   BACKWARD: <u>for</u> I ≔ N <u>step</u> -1 <u>until</u> 1 <u>do</u>
      <u>begin</u> I1 ≔ I + 1;
         U[I] ≔ (U[I] - MATVEC(I1, N, I, A, U) + (<u>if</u> P[I] <u>then</u>
           TAMVEC(I1, N, I, A, V) <u>else</u> A[I1, I] × V[I1])) / A[I, I];
         V[I] ≔ (V[I] - MATVEC(I1, N, I, A, V) - (<u>if</u> P[I] <u>then</u>
           TAMVEC(I1, N, I, A, U) <u>else</u> A[I1, I] × U[I1])) / A[I, I]
      <u>end</u> BACKWARD;
   NORMALISE: W ≔ 1 / SQRT(VECVEC(1, N, 0, U, U) +
     VECVEC(1, N, 0, V, V));
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> U[J] ≔ U[J] × W; V[J] ≔ V[J] × W <u>end</u>;
   COUNT ≔ COUNT + 1; <u>if</u> W &gt; TOL <u>then</u> <u>goto</u> FORWARD;
   OUTM: EM[7] ≔ W; EM[9] ≔ COUNT
<u>end</u> COMVECHES;
<u>comment</u> ================== 34182 ================= ;
<u>comment</u> MCA 2412;
<u>integer</u> <u>procedure</u> REAEIGVAL(A, N, EM, VAL); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, VAL;
<u>begin</u> <u>integer</u> I, J; <u>real</u> R;
   <u>array</u> D[1:N]; <u>integer</u> <u>array</u> INT, INT0[1:N];

   <u>procedure</u> TFMREAHES(A, N, EM, INT); <u>code</u> 34170;
   <u>procedure</u> EQILBR(A, N, EM, D, INT); <u>code</u> 34173;
   <u>integer</u> <u>procedure</u> REAVALQRI(A, N, EM, VAL); <u>code</u> 34180;

   EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
   J ≔ REAEIGVAL ≔ REAVALQRI(A, N, EM, VAL);
   <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>if</u> VAL[J] &gt; VAL[I] <u>then</u>
            <u>begin</u> R ≔ VAL[I]; VAL[I] ≔ VAL[J]; VAL[J] ≔ R <u>end</u>
         <u>end</u>
<u>end</u> REAEIGVAL;
<u>comment</u> ================== 34184 ================= ;
<u>comment</u> MCA 2414;
<u>integer</u> <u>procedure</u> REAEIG1(A, N, EM, VAL, VEC); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, VAL, VEC;
<u>begin</u> <u>integer</u> I, K, MAX, J, L;
   <u>real</u> RESIDU, R, MACHTOL;
   <u>array</u> D, V[1:N], B[1:N, 1:N];
   <u>integer</u> <u>array</u> INT, INT0[1:N];

   <u>procedure</u> TFMREAHES(A, N, EM, INT); <u>code</u> 34170;
   <u>procedure</u> BAKREAHES2(A, N, N1, N2, INT, VEC); <u>code</u> 34172;
   <u>procedure</u> EQILBR(A, N, EM, D, INT); <u>code</u> 34173;
   <u>procedure</u> BAKLBR(N, N1, N2, D, INT, VEC); <u>code</u> 34174;
   <u>integer</u> <u>procedure</u> REAVALQRI(A, N, EM, VAL); <u>code</u> 34180;
   <u>procedure</u> REAVECHES(A, N, LAMBDA, EM, V); <u>code</u> 34181;
   <u>procedure</u> REASCL(A, N, N1, N2); <u>code</u> 34183;

   RESIDU ≔ 0; MAX ≔ 0; EQILBR(A, N, EM, D, INT0);
   TFMREAHES(A, N, EM, INT);
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>for</u> J ≔ (<u>if</u> I = 1 <u>then</u> 1 <u>else</u> I - 1)
        <u>step</u> 1 <u>until</u> N <u>do</u> B[I, J] ≔ A[I, J];
   K ≔ REAEIG1 ≔ REAVALQRI(B, N, EM, VAL);
   <u>for</u> I ≔ K + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>if</u> VAL[J] &gt; VAL[I] <u>then</u>
            <u>begin</u> R ≔ VAL[I]; VAL[I] ≔ VAL[J]; VAL[J] ≔ R <u>end</u>
         <u>end</u>;
   MACHTOL ≔ EM[0] × EM[1];
   <u>for</u> L ≔ K + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> L &gt; 1 <u>then</u>
         <u>begin</u> <u>if</u> VAL[L - 1] - VAL[L] &lt; MACHTOL <u>then</u>
              VAL[L] ≔ VAL[L - 1] - MACHTOL
         <u>end</u>;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              <u>for</u> J ≔ (<u>if</u> I = 1 <u>then</u> 1 <u>else</u> I - 1)
              <u>step</u> 1 <u>until</u> N <u>do</u> B[I, J] ≔ A[I, J];
         REAVECHES(B, N, VAL[L], EM, V);
         <u>if</u> EM[7] &gt; RESIDU <u>then</u> RESIDU ≔ EM[7];
         <u>if</u> EM[9] &gt; MAX <u>then</u> MAX ≔ EM[9];
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC[J, L] ≔ V[J]
      <u>end</u>;
   EM[7] ≔ RESIDU; EM[9] ≔ MAX;
   BAKREAHES2(A, N, K + 1, N, INT, VEC);
   BAKLBR(N, K + 1, N, D, INT0, VEC);
   REASCL(VEC, N, K + 1, N)
<u>end</u> REAEIG1;
<u>comment</u> ================== 34187 ================= ;
<u>comment</u> MCA 2417;
<u>integer</u> <u>procedure</u> REAEIG3(A, N, EM, VAL, VEC); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, VAL, VEC;
<u>begin</u> <u>integer</u> I; <u>real</u> S;
   <u>integer</u> <u>array</u> INT, INT0[1:N]; <u>array</u> D[1:N];

   <u>procedure</u> TFMREAHES(A, N, EM, INT); <u>code</u> 34170;
   <u>procedure</u> BAKREAHES2(A, N, N1, N2, INT, VEC); <u>code</u> 34172;
   <u>procedure</u> EQILBR(A, N, EM, D, INT); <u>code</u> 34173;
   <u>procedure</u> BAKLBR(N, N1, N2, D, INT, VEC); <u>code</u> 34174;
   <u>procedure</u> REASCL(A, N, N1, N2); <u>code</u> 34183;
   <u>integer</u> <u>procedure</u> REAQRI(A, N, EM, VAL, VEC); <u>code</u> 34186;

   EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
   I ≔ REAEIG3 ≔ REAQRI(A, N, EM, VAL, VEC);
   <u>if</u> I = 0 <u>then</u>
   <u>begin</u> BAKREAHES2(A, N, 1, N, INT, VEC);
      BAKLBR(N, 1, N, D, INT0, VEC); REASCL(VEC, N, 1, N)
   <u>end</u>
<u>end</u> REAEIG3;
<u>comment</u> ================== 34192 ================= ;
<u>comment</u> MCA 2422;
<u>integer</u> <u>procedure</u> COMEIGVAL(A, N, EM, RE, IM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, EM, RE, IM;
<u>begin</u> <u>integer</u> <u>array</u> INT, INT0[1:N];
   <u>array</u> D[1:N];

   <u>procedure</u> EQILBR(A, N, EM, D, INT); <u>code</u> 34173;
   <u>procedure</u> TFMREAHES(A, N, EM, INT); <u>code</u> 34170;
   <u>integer</u> <u>procedure</u> COMVALQRI(A, N, EM, RE, IM);
      <u>code</u> 34190;

   EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT);
   COMEIGVAL ≔ COMVALQRI(A, N, EM, RE, IM)
<u>end</u> COMEIGVAL;
<u>comment</u> ================== 34194 ================= ;
<u>comment</u> MCA 2424;
<u>integer</u> <u>procedure</u> COMEIG1(A, N, EM, RE, IM, VEC);
   <u>value</u> N; <u>integer</u> N;
     <u>array</u> A, EM, RE, IM, VEC;
<u>begin</u> <u>integer</u> I, J, K, PJ, ITT;
   <u>real</u> X, Y, MAX, NEPS;
   <u>array</u> AB[1:N, 1:N], D, U, V[1:N];
   <u>integer</u> <u>array</u> INT, INT0[1:N];

   <u>procedure</u> TRANSFER;
   <u>begin</u> <u>integer</u> I, J;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
           <u>for</u> J ≔ (<u>if</u> I = 1 <u>then</u> 1 <u>else</u> I - 1) <u>step</u> 1
           <u>until</u> N <u>do</u> AB[I, J] ≔ A[I, J]
   <u>end</u> TRANSFER;

   <u>procedure</u> EQILBR(A, N, EM, D, INT); <u>code</u> 34173;
   <u>procedure</u> TFMREAHES(A, N, EM, INT); <u>code</u> 34170;
   <u>procedure</u> BAKREAHES2(A, N, N1, N2, INT, VEC); <u>code</u> 34172;
   <u>procedure</u> BAKLBR(N, N1, N2, D, INT, VEC); <u>code</u> 34174;
   <u>procedure</u> REAVECHES(A, N, LAMBDA, EM, V); <u>code</u> 34181;
   <u>procedure</u> COMSCL(A, N, N1, N2, IM); <u>code</u> 34193;
   <u>integer</u> <u>procedure</u> COMVALQRI(A, N, EM, RE, IM);
      <u>code</u> 34190;
   <u>procedure</u> COMVECHES(A, N, LAMBDA, MU, EM, U, V);
      <u>code</u> 34191;

   EQILBR(A, N, EM, D, INT0); TFMREAHES(A, N, EM, INT); TRANSFER;
   K ≔ COMEIG1 ≔ COMVALQRI(AB, N, EM, RE, IM);
   NEPS ≔ EM[0] × EM[1]; MAX ≔ 0; ITT ≔ 0;
   <u>for</u> I ≔ K + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> X ≔ RE[I]; Y ≔ IM[I]; PJ ≔ 0;
         AGAIN: <u>for</u> J ≔ K + 1 <u>step</u> 1 <u>until</u> I - 1 <u>do</u>
            <u>begin</u> <u>if</u> ((X - RE[J]) ⭡ 2 +
                 (Y - IM[J]) ⭡ 2 &LessSlantEqual; NEPS ⭡ 2) <u>then</u>
               <u>begin</u> <u>if</u> PJ = J <u>then</u> NEPS ≔ EM[2] × EM[1]
                  <u>else</u> PJ ≔ J; X ≔ X + 2 × NEPS; <u>goto</u> AGAIN
               <u>end</u>
            <u>end</u>;
         RE[I] ≔ X; TRANSFER; <u>if</u> Y ≠ 0 <u>then</u>
         <u>begin</u> COMVECHES(AB, N, RE[I], IM[I], EM, U, V);
            <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC[J, I] ≔ U[J];
            I ≔ I + 1; RE[I] ≔ X
         <u>end</u>
         <u>else</u> REAVECHES(AB, N, X, EM, V);
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC[J, I] ≔ V[J];
         <u>if</u> EM[7] &gt; MAX <u>then</u> MAX ≔ EM[7];
         ITT ≔ <u>if</u> ITT &gt; EM[9] <u>then</u> ITT <u>else</u> EM[9]
      <u>end</u>;
   EM[7] ≔ MAX; EM[9] ≔ ITT; BAKREAHES2(A, N, K + 1, N, INT, VEC);
   BAKLBR(N, K + 1, N, D, INT0, VEC); COMSCL(VEC, N, K + 1, N, IM)
<u>end</u> COMEIG1;
<u>comment</u> ================== 34368 ================= ;
<u>procedure</u> EIGVALHRM(A, N, NUMVAL, VAL, EM); <u>value</u> N, NUMVAL;
   <u>integer</u> N, NUMVAL; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> D[1:N], BB[1:N - 1];
   <u>procedure</u> HSHHRMTRIVAL(A, N, D, BB, EM); <u>code</u> 34364;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;
   HSHHRMTRIVAL(A, N, D, BB, EM);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM)
<u>end</u> EIGVALHRM;
<u>comment</u> ================== 34369 ================= ;
<u>procedure</u> EIGHRM(A, N, NUMVAL, VAL, VECR, VECI, EM);
   <u>value</u> N, NUMVAL; <u>integer</u> N, NUMVAL;
     <u>array</u> A, VAL, VECR, VECI, EM;
<u>begin</u> <u>array</u> BB, TR, TI[1:N - 1], D, B[1:N];
   <u>procedure</u> HSHHRMTRI(A, N, D, B, BB, EM, TR, TI); <u>code</u> 34363;
   <u>procedure</u> VALSYMTRI(D, BB, N, N1, N2, VAL, EM); <u>code</u> 34151;
   <u>procedure</u> VECSYMTRI(D, B, N, N1, N2, VAL, VEC, EM); <u>code</u> 34152;
   <u>procedure</u> BAKHRMTRI(A, N, N1, N2, VECR, VECI, TR, TI); <u>code</u> 34365;
   HSHHRMTRI(A, N, D, B, BB, EM, TR, TI);
   VALSYMTRI(D, BB, N, 1, NUMVAL, VAL, EM); B[N] ≔ 0;
   VECSYMTRI(D, B, N, 1, NUMVAL, VAL, VECR, EM);
   BAKHRMTRI(A, N, 1, NUMVAL, VECR, VECI, TR, TI)
<u>end</u> EIGHRM;
<u>comment</u> ================== 34370 ================= ;
<u>integer</u> <u>procedure</u> QRIVALHRM(A, N, VAL, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B, BB[1:N];
   <u>integer</u> I;
   <u>procedure</u> HSHHRMTRIVAL(A, N, D, BB, EM); <u>code</u> 34364;
   <u>integer</u> <u>procedure</u> QRIVALSYMTRI(D, BB, N, EM); <u>code</u> 34160;
   HSHHRMTRIVAL(A, N, VAL, BB, EM); B[N] ≔ BB[N] ≔ 0;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N-1 <u>do</u> B[I] ≔ SQRT(BB[I]);
   QRIVALHRM ≔ QRIVALSYMTRI(VAL, BB, N, EM)
<u>end</u> QRIVALHRM;
<u>comment</u> ================== 34371 ================= ;
<u>integer</u> <u>procedure</u> QRIHRM(A, N, VAL, VR, VI, EM); <u>value</u> N;
   <u>integer</u> N; <u>array</u> A, VAL, VR, VI, EM;
<u>begin</u> <u>integer</u> I, J;
   <u>array</u> B, BB[1:N], TR, TI[1:N - 1];
   <u>procedure</u> HSHHRMTRI(A, N, D, B, BB, EM, TR, TI); <u>code</u> 34363;
   <u>integer</u> <u>procedure</u> QRISYMTRI(A, N, D, B, BB, EM); <u>code</u> 34161;
   <u>procedure</u> BAKHRMTRI(A, N, N1, N2, VECR, VECI, TR, TI); <u>code</u> 34365;
   HSHHRMTRI(A, N, VAL, B, BB, EM, TR, TI);
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> VR[I, I] ≔ 1;
         <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u> VR[I, J] ≔ VR[J, I] ≔               0
      <u>end</u>;
   B[N] ≔ BB[N] ≔ 0;
   I ≔ QRIHRM ≔ QRISYMTRI(VR, N, VAL, B, BB, EM);
   BAKHRMTRI(A, N, I + 1, N, VR, VI, TR, TI);
<u>end</u> QRIHRM;
<u>comment</u> ================== 34372 ================= ;
<u>integer</u> <u>procedure</u> VALQRICOM(A1, A2, B, N, EM, VAL1, VAL2);
   <u>value</u> N; <u>integer</u> N; <u>array</u> A1, A2, B, EM, VAL1, VAL2;
<u>begin</u> <u>integer</u> M, NM1, I, I1, Q, Q1, MAX, COUNT;
   <u>real</u> R, Z1, Z2, DD1, DD2, CC, G1, G2, K1, K2, HC, A1NN,
     A2NN, AIJ1, AIJ2, AI1I, KAPPA, NUI, MUI1, MUI2,
     MUIM11, MUIM12, NUIM1, TOL;
   <u>procedure</u> COMCOLCST(L, U, J, AR, AI, XR, XI); <u>code</u> 34352;
   <u>procedure</u> ROTCOMCOL(L, U, I, J, AR, AI, CR, CI, S); <u>code</u> 34357;
   <u>procedure</u> ROTCOMROW(L, U, I, J, AR, AI, CR, CI, S); <u>code</u> 34358;
   <u>procedure</u> COMKWD(PR, PI, QR, QI, GR, GI, KR, KI); <u>code</u> 34345;
   TOL ≔ EM[1] × EM[2]; MAX ≔ EM[4]; COUNT ≔ 0; R ≔ 0;
   M ≔ N; <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1];
   IN: NM1 ≔ N - 1;
   <u>for</u> I ≔ N, I - 1 <u>while</u> (<u>if</u> I &GreaterSlantEqual; 1 <u>then</u> ABS(B[I]) &gt; TOL
   <u>else</u> <u>false</u>) <u>do</u> Q ≔ I; <u>if</u> Q &gt; 1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(B[Q - 1]) &gt; R <u>then</u> R ≔ ABS(B[Q - 1]) <u>end</u>;
   <u>if</u> Q = N <u>then</u>
   <u>begin</u> VAL1[N] ≔ A1[N, N]; VAL2[N] ≔ A2[N, N]; N ≔ NM1;
      <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1];
   <u>end</u>
   <u>else</u>
   <u>begin</u> DD1 ≔ A1[N, N]; DD2 ≔ A2[N, N]; CC ≔ B[NM1];
      COMKWD((A1[NM1, NM1] - DD1) / 2, (A2[NM1, NM1] - DD2)
        / 2, CC × A1[NM1, N], CC × A2[NM1, N], G1, G2, K1,
        K2); <u>if</u> Q = NM1 <u>then</u>
      <u>begin</u> VAL1[NM1] ≔ G1 + DD1; VAL2[NM1] ≔ G2 + DD2;
         VAL1[N] ≔ K1 + DD1; VAL2[N] ≔ K2 + DD2;
         N ≔ N - 2; <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1];
      <u>end</u>
      <u>else</u>
      <u>begin</u> COUNT ≔ COUNT + 1;
         <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> OUT; Z1 ≔ K1 + DD1;
         Z2 ≔ K2 + DD2;
         <u>if</u> ABS(CC) &gt; ABS(HC) <u>then</u> Z1 ≔ Z1 + ABS(CC);
         HC ≔ CC / 2; I ≔ Q1 ≔ Q + 1;
         AIJ1 ≔ A1[Q, Q] - Z1; AIJ2 ≔ A2[Q, Q] - Z2;
         AI1I ≔ B[Q];
         KAPPA ≔ SQRT(AIJ1 ⭡ 2 + AIJ2 ⭡ 2 + AI1I ⭡ 2);
         MUI1 ≔ AIJ1 / KAPPA; MUI2 ≔ AIJ2 / KAPPA;
         NUI ≔ AI1I / KAPPA; A1[Q, Q] ≔ KAPPA;
         A2[Q, Q] ≔ 0; A1[Q1, Q1] ≔ A1[Q1, Q1] - Z1;
         A2[Q1, Q1] ≔ A2[Q1, Q1] - Z2;
         ROTCOMROW(Q1, N, Q, Q1, A1, A2, MUI1, MUI2,
           NUI);
         ROTCOMCOL(Q, Q, Q, Q1, A1, A2, MUI1, - MUI2, -
           NUI); A1[Q, Q] ≔ A1[Q, Q] + Z1;
         A2[Q, Q] ≔ A2[Q, Q] + Z2;
         <u>for</u> I1 ≔ Q1 + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> AIJ1 ≔ A1[I, I]; AIJ2 ≔ A2[I, I];
               AI1I ≔ B[I];
               KAPPA ≔ SQRT(AIJ1 ⭡ 2 + AIJ2 ⭡ 2 + AI1I ⭡
                 2); MUIM11 ≔ MUI1; MUIM12 ≔ MUI2;
               NUIM1 ≔ NUI; MUI1 ≔ AIJ1 / KAPPA;
               MUI2 ≔ AIJ2 / KAPPA; NUI ≔ AI1I / KAPPA;
               A1[I1, I1] ≔ A1[I1, I1] - Z1;
               A2[I1, I1] ≔ A2[I1, I1] - Z2;
               ROTCOMROW(I1, N, I, I1, A1, A2, MUI1,
                 MUI2, NUI); A1[I, I] ≔ MUIM11 × KAPPA;
               A2[I, I] ≔ - MUIM12 × KAPPA;
               B[I - 1] ≔ NUIM1 × KAPPA;

               ROTCOMCOL(Q, I, I, I1, A1, A2, MUI1, -
                 MUI2, - NUI); A1[I, I] ≔ A1[I, I] + Z1;
               A2[I, I] ≔ A2[I, I] + Z2; I ≔ I1;
            <u>end</u>;
         AIJ1 ≔ A1[N, N]; AIJ2 ≔ A2[N, N];
         KAPPA ≔ SQRT(AIJ1 ⭡ 2 + AIJ2 ⭡ 2);
         <u>if</u> (<u>if</u> KAPPA &lt; TOL <u>then</u> <u>true</u> <u>else</u> AIJ2 ⭡ 2&LessSlantEqual; EM[0] × AIJ1 ⭡ 2) <u>then</u>
         <u>begin</u> B[NM1] ≔ NUI × AIJ1;
            A1[N, N] ≔ AIJ1 × MUI1 + Z1;
            A2[N, N] ≔ - AIJ1 × MUI2 + Z2
         <u>end</u>
         <u>else</u>
         <u>begin</u> B[NM1] ≔ NUI × KAPPA; A1NN ≔ MUI1 × KAPPA;
            A2NN ≔ - MUI2 × KAPPA; MUI1 ≔ AIJ1 / KAPPA;
            MUI2 ≔ AIJ2 / KAPPA;
            COMCOLCST(Q, NM1, N, A1, A2, MUI1, MUI2);
            A1[N, N] ≔ MUI1 × A1NN - MUI2 × A2NN + Z1;
            A2[N, N] ≔ MUI1 × A2NN + MUI2 × A1NN + Z2;
         <u>end</u>;
      <u>end</u>
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   OUT: EM[3] ≔ R; EM[5] ≔ COUNT; VALQRICOM ≔ N;
<u>end</u> VALQRICOM;
<u>comment</u> ================== 34373 ================= ;
<u>integer</u> <u>procedure</u> QRICOM(A1, A2, B, N, EM, VAL1, VAL2, VEC1,
  VEC2); <u>value</u> N; <u>integer</u> N;
     <u>array</u> A1, A2, B, EM, VAL1, VAL2, VEC1, VEC2;
<u>begin</u> <u>integer</u> M, NM1, I, I1, J, Q, Q1, MAX, COUNT;
   <u>real</u> R, Z1, Z2, DD1, DD2, CC, P1, P2, T1, T2, DELTA1,
     DELTA2, MV1, MV2, H, H1, H2, G1, G2, K1, K2, HC,
     AIJ12, AIJ22, A1NN, A2NN, AIJ1, AIJ2, AI1I, KAPPA,
     NUI, MUI1, MUI2, MUIM11, MUIM12, NUIM1, TOL, MACHTOL;
   <u>array</u> TF1, TF2[1:N];
   <u>procedure</u> COMKWD(PR, PI, QR, QI, GR, GI, KR, KI); <u>code</u> 34345;
   <u>procedure</u> ROTCOMROW(L, U, I, J, AR, AI, CR, CI, S); <u>code</u> 34358;
   <u>procedure</u> ROTCOMCOL(L, U, I, J, AR, AI, CR, CI, S); <u>code</u> 34357;
   <u>procedure</u> COMCOLCST(L, U, J, AR, AI, XR, XI); <u>code</u> 34352;
   <u>procedure</u> COMROWCST(L, U, I, AR, AI, XR, XI); <u>code</u> 34353;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> COMMATVEC(L, U, I, AR, AI, BR, BI, RR, RI); <u>code</u> 34354;
   <u>procedure</u> COMDIV(XR, XI, YR, YI, ZR, ZI); <u>code</u> 34342;
   TOL ≔ EM[1] × EM[2]; MACHTOL ≔ EM[0] × EM[1];
   MAX ≔ EM[4]; COUNT ≔ 0; R ≔ 0; M ≔ N;
   <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1];
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> VEC1[I, I] ≔ 1; VEC2[I, I] ≔ 0;
         <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u> VEC1[I, J] ≔               VEC1[J, I] ≔ VEC2[I, J] ≔ VEC2[J, I] ≔ 0
      <u>end</u>;
   IN: NM1 ≔ N - 1;
   <u>for</u> I ≔ N, I - 1 <u>while</u> (<u>if</u> I &GreaterSlantEqual; 1 <u>then</u> ABS(B[I]) &gt; TOL
   <u>else</u> <u>false</u>) <u>do</u> Q ≔ I; <u>if</u> Q &gt; 1 <u>then</u>
   <u>begin</u> <u>if</u> ABS(B[Q - 1]) &gt; R <u>then</u> R ≔ ABS(B[Q - 1]) <u>end</u>;
   <u>if</u> Q = N <u>then</u>
   <u>begin</u> VAL1[N] ≔ A1[N, N]; VAL2[N] ≔ A2[N, N]; N ≔ NM1;
      <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1];
   <u>end</u>
   <u>else</u>
   <u>begin</u> DD1 ≔ A1[N, N]; DD2 ≔ A2[N, N]; CC ≔ B[NM1];
      P1 ≔ (A1[NM1, NM1] - DD1) × ·5;
      P2 ≔ (A2[NM1, NM1] - DD2) × ·5;
      COMKWD(P1, P2, CC × A1[NM1, N], CC × A2[NM1, N], G1,
        G2, K1, K2); <u>if</u> Q = NM1 <u>then</u>
      <u>begin</u> A1[N, N] ≔ VAL1[N] ≔ G1 + DD1;
         A2[N, N] ≔ VAL2[N] ≔ G2 + DD2;
         A1[Q, Q] ≔ VAL1[Q] ≔ K1 + DD1;
         A2[Q, Q] ≔ VAL2[Q] ≔ K2 + DD2;
         KAPPA ≔ SQRT(K1 ⭡ 2 + K2 ⭡ 2 + CC ⭡ 2);
         NUI ≔ CC / KAPPA; MUI1 ≔ K1 / KAPPA;
         MUI2 ≔ K2 / KAPPA; AIJ1 ≔ A1[Q, N];
         AIJ2 ≔ A2[Q, N]; H1 ≔ MUI1 ⭡ 2 - MUI2 ⭡ 2;
         H2 ≔ 2 × MUI1 × MUI2; H ≔ - NUI × 2;
         A1[Q, N] ≔ H × (P1 × MUI1 + P2 × MUI2) - NUI ×
           NUI × CC + AIJ1 × H1 + AIJ2 × H2;
         A2[Q, N] ≔ H × (P2 × MUI1 - P1 × MUI2) + AIJ2 ×
           H1 - AIJ1 × H2;
         ROTCOMROW(Q + 2, M, Q, N, A1, A2, MUI1, MUI2,
           NUI);
         ROTCOMCOL(1, Q - 1, Q, N, A1, A2, MUI1, -
           MUI2, - NUI);
         ROTCOMCOL(1, M, Q, N, VEC1, VEC2, MUI1, -
           MUI2, - NUI); N ≔ N - 2;
         <u>if</u> N &gt; 1 <u>then</u> HC ≔ B[N - 1]; B[Q] ≔ 0
      <u>end</u>
      <u>else</u>
      <u>begin</u> COUNT ≔ COUNT + 1;
         <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> OUT; Z1 ≔ K1 + DD1;
         Z2 ≔ K2 + DD2;
         <u>if</u> ABS(CC) &gt; ABS(HC) <u>then</u> Z1 ≔ Z1 + ABS(CC);
         HC ≔ CC / 2; Q1 ≔ Q + 1; AIJ1 ≔ A1[Q, Q] - Z1;
         AIJ2 ≔ A2[Q, Q] - Z2; AI1I ≔ B[Q];
         KAPPA ≔ SQRT(AIJ1 ⭡ 2 + AIJ2 ⭡ 2 + AI1I ⭡ 2);
         MUI1 ≔ AIJ1 / KAPPA; MUI2 ≔ AIJ2 / KAPPA;
         NUI ≔ AI1I / KAPPA; A1[Q, Q] ≔ KAPPA;
         A2[Q, Q] ≔ 0; A1[Q1, Q1] ≔ A1[Q1, Q1] - Z1;
         A2[Q1, Q1] ≔ A2[Q1, Q1] - Z2;
         ROTCOMROW(Q1, M, Q, Q1, A1, A2, MUI1, MUI2,
           NUI);
         ROTCOMCOL(1, Q, Q, Q1, A1, A2, MUI1, - MUI2, -
           NUI); A1[Q, Q] ≔ A1[Q, Q] + Z1;
         A2[Q, Q] ≔ A2[Q, Q] + Z2;
         ROTCOMCOL(1, M, Q, Q1, VEC1, VEC2, MUI1, -
           MUI2, - NUI);
         <u>for</u> I ≔ Q1 <u>step</u> 1 <u>until</u> NM1 <u>do</u>
            <u>begin</u> I1 ≔ I + 1; AIJ1 ≔ A1[I, I]; AIJ2 ≔ A2[I, I];
               AI1I ≔ B[I];
               KAPPA ≔ SQRT(AIJ1 ⭡ 2 + AIJ2 ⭡ 2 + AI1I ⭡
                 2); MUIM11 ≔ MUI1; MUIM12 ≔ MUI2;
               NUIM1 ≔ NUI; MUI1 ≔ AIJ1 / KAPPA;
               MUI2 ≔ AIJ2 / KAPPA; NUI ≔ AI1I / KAPPA;
               A1[I1, I1] ≔ A1[I1, I1] - Z1;
               A2[I1, I1] ≔ A2[I1, I1] - Z2;
               ROTCOMROW(I1, M, I, I1, A1, A2, MUI1,
                 MUI2, NUI); A1[I, I] ≔ MUIM11 × KAPPA;
               A2[I, I] ≔ - MUIM12 × KAPPA;
               B[I - 1] ≔ NUIM1 × KAPPA;
               ROTCOMCOL(1, I, I, I1, A1, A2, MUI1, -
                 MUI2, - NUI); A1[I, I] ≔ A1[I, I] + Z1;
               A2[I, I] ≔ A2[I, I] + Z2;
               ROTCOMCOL(1, M, I, I1, VEC1, VEC2, MUI1, -
                 MUI2, - NUI);
            <u>end</u>;

         AIJ1 ≔ A1[N, N]; AIJ2 ≔ A2[N, N]; AIJ12 ≔ AIJ1 ⭡ 2;
         AIJ22 ≔ AIJ2 ⭡ 2; KAPPA ≔ SQRT(AIJ12 + AIJ22);
         <u>if</u> (<u>if</u> KAPPA &lt; TOL <u>then</u> <u>true</u> <u>else</u> AIJ22 &LessSlantEqual;
           EM[0] × AIJ12) <u>then</u>
         <u>begin</u> B[NM1] ≔ NUI × AIJ1;
            A1[N, N] ≔ AIJ1 × MUI1 + Z1;
            A2[N, N] ≔ - AIJ1 × MUI2 + Z2
         <u>end</u>
         <u>else</u>
         <u>begin</u> B[NM1] ≔ NUI × KAPPA; A1NN ≔ MUI1 × KAPPA;
            A2NN ≔ - MUI2 × KAPPA; MUI1 ≔ AIJ1 / KAPPA;
            MUI2 ≔ AIJ2 / KAPPA;
            COMCOLCST(1, NM1, N, A1, A2, MUI1, MUI2);
            COMCOLCST(1, NM1, N, VEC1, VEC2, MUI1,
              MUI2);
            COMROWCST(N + 1, M, N, A1, A2, MUI1, -
              MUI2);
            COMCOLCST(N, M, N, VEC1, VEC2, MUI1, MUI2);
            A1[N, N] ≔ MUI1 × A1NN - MUI2 × A2NN + Z1;
            A2[N, N] ≔ MUI1 × A2NN + MUI2 × A1NN + Z2;
         <u>end</u>;
      <u>end</u>;
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   <u>for</u> J ≔ M <u>step</u> - 1 <u>until</u> 2 <u>do</u>
      <u>begin</u> TF1[J] ≔ 1; TF2[J] ≔ 0; T1 ≔ A1[J, J]; T2 ≔ A2[J, J];
         <u>for</u> I ≔ J - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
            <u>begin</u> DELTA1 ≔ T1 - A1[I, I]; DELTA2 ≔ T2 - A2[I, I];
               COMMATVEC(I + 1, J, I, A1, A2, TF1, TF2, MV1,
                 MV2);
               <u>if</u> ABS(DELTA1) &lt; MACHTOL ∧ ABS(DELTA2) &lt;
                 MACHTOL <u>then</u>
               <u>begin</u> TF1[I] ≔ MV1 / MACHTOL;
                  TF2[I] ≔ MV2 / MACHTOL
               <u>end</u>
               <u>else</u> COMDIV(MV1, MV2, DELTA1, DELTA2, TF1[I],
                 TF2[I]);
            <u>end</u>;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> COMMATVEC(1, J, I,
              VEC1, VEC2, TF1, TF2, VEC1[I, J], VEC2[I, J]);
      <u>end</u>;
   OUT: EM[3] ≔ R; EM[5] ≔ COUNT; QRICOM ≔ N;
<u>end</u> QRICOM;
<u>comment</u> ================== 34374 ================= ;
<u>integer</u> <u>procedure</u> EIGVALCOM(AR, AI, N, EM, VALR, VALI);
   <u>value</u> N; <u>integer</u> N; <u>array</u> AR, AI, EM, VALR, VALI;
<u>begin</u> <u>integer</u> <u>array</u> INT[1:N];
   <u>array</u> D, B, DEL, TR, TI[1:N];
   <u>procedure</u> HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL); <u>code</u> 34366;
   <u>real</u> <u>procedure</u> COMEUCNRM(AR, AI, LW, N); <u>code</u> 34359;
   <u>procedure</u> EQILBRCOM(A1, A2, N, EM, D, INT); <u>code</u> 34361;
   <u>integer</u> <u>procedure</u> VALQRICOM(A1, A2, B, N, EM, VAL1, VAL2);
      <u>code</u> 34372;
   EQILBRCOM(AR, AI, N, EM, D, INT);
   EM[1] ≔ COMEUCNRM(AR, AI, N - 1, N);
   HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL);
   EIGVALCOM ≔ VALQRICOM(AR, AI, B, N, EM, VALR, VALI)
<u>end</u> EIGVALCOM;
<u>comment</u> ================== 34375 ================= ;
<u>integer</u> <u>procedure</u> EIGCOM(AR, AI, N, EM, VALR, VALI, VR, VI);
   <u>value</u> N; <u>integer</u> N; <u>array</u> AR, AI, EM, VALR, VALI, VR, VI;
<u>begin</u> <u>integer</u> I;
   <u>integer</u> <u>array</u> INT[1:N];
   <u>array</u> D, B, DEL, TR, TI[1:N];
   <u>procedure</u> EQILBRCOM(A1, A2, N, EM, D, INT); <u>code</u> 34361;
   <u>real</u> <u>procedure</u> COMEUCNRM(AR, AI, LW, N); <u>code</u> 34359;
   <u>procedure</u> HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL); <u>code</u> 34366;
   <u>integer</u> <u>procedure</u> QRICOM(A1, A2, B, N, EM, VAL1, VAL2, VEC1, VEC2);
      <u>code</u> 34373;
   <u>procedure</u> BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, N1, N2);
      <u>code</u> 34367;
   <u>procedure</u> BAKLBRCOM(N, N1, N2, D, INT, VR, VI); <u>code</u> 34362;
   <u>procedure</u> SCLCOM(AR, AI, N, N1, N2); <u>code</u> 34360;
   EQILBRCOM(AR, AI, N, EM, D, INT);
   EM[1] ≔ COMEUCNRM(AR, AI, N - 1, N);
   HSHCOMHES(AR, AI, N, EM, B, TR, TI, DEL);
   I ≔ EIGCOM ≔ QRICOM(AR, AI, B, N, EM, VALR, VALI, VR,
     VI); <u>if</u> I = 0 <u>then</u>
   <u>begin</u> BAKCOMHES(AR, AI, TR, TI, DEL, VR, VI, N, 1, N);
      BAKLBRCOM(N, 1, N, D, INT, VR, VI);
      SCLCOM(VR, VI, N, 1, N)
   <u>end</u>
<u>end</u> EIGCOM;
<u>comment</u> ================== 34270 ================= ;
<u>integer</u> <u>procedure</u> QRISNGVALBID(D, B, N, EM);
   <u>value</u> N; <u>integer</u> N; <u>array</u> D, B, EM;
<u>begin</u> <u>integer</u> N1, K, K1, I, I1, COUNT, MAX, RNK;
   <u>real</u> TOL, BMAX, Z, X, Y, G, H, F, C, S, MIN;
   TOL ≔ EM[2] × EM[1]; COUNT ≔ 0; BMAX ≔ 0; MAX ≔ EM[4]; MIN ≔ EM[6];
   RNK ≔ N;
   IN: K ≔ N; N1 ≔ N - 1;
   NEXT: K ≔ K - 1; <u>if</u> K &gt; 0 <u>then</u>
   <u>begin</u> <u>if</u> ABS(B[K]) &GreaterSlantEqual; TOL <u>then</u>
      <u>begin</u> <u>if</u> ABS(D[K]) &GreaterSlantEqual; TOL <u>then</u> <u>goto</u> NEXT;
         C ≔ 0; S ≔ 1;
         <u>for</u> I ≔ K <u>step</u> 1 <u>until</u> N1 <u>do</u>
            <u>begin</u> F ≔ S × B[I]; B[I] ≔ C × B[I]; I1 ≔ I + 1;
               <u>if</u> ABS(F) &lt; TOL <u>then</u> <u>goto</u> NEGLECT;
               G ≔ D[I1]; D[I1] ≔ H ≔ SQRT(F × F + G × G);
               C ≔ G / H; S ≔ - F / H
            <u>end</u>;
         NEGLECT:
      <u>end</u>
        <u>else</u> <u>if</u> ABS(B[K]) &gt; BMAX <u>then</u> BMAX ≔ ABS(B[K])
   <u>end</u>;
   <u>if</u> K = N1 <u>then</u>
   <u>begin</u> <u>if</u> D[N] &lt; 0 <u>then</u> D[N] ≔ - D[N];
      <u>if</u> D[N] &LessSlantEqual; MIN <u>then</u> RNK ≔ RNK - 1; N ≔ N1
   <u>end</u>
   <u>else</u>
   <u>begin</u> COUNT ≔ COUNT + 1; <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> END;
      K1 ≔ K + 1; Z ≔ D[N]; X ≔ D[K1]; Y ≔ D[N1];
      G ≔ <u>if</u> N1 = 1 <u>then</u> 0 <u>else</u> B[N1 - 1]; H ≔ B[N1];
      F ≔ ((Y - Z) × (Y + Z) + (G - H) × (G + H)) / (2 × H × Y);
      G ≔ SQRT(F × F + 1);
      F ≔ ((X - Z) × (X + Z) + H × (Y / (<u>if</u> F &lt; 0 <u>then</u> F - G
      <u>else</u> F + G) - H)) / X; C ≔ S ≔ 1;
      <u>for</u> I ≔ K1 + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> I1 ≔ I - 1; G ≔ B[I1]; Y ≔ D[I]; H ≔ S × G; G ≔ C × G;
            Z ≔ SQRT(F × F + H × H); C ≔ F / Z; S ≔ H / Z;
            <u>if</u> I1 ≠ K1 <u>then</u> B[I1 - 1] ≔ Z; F ≔ X × C + G × S;
            G ≔ G × C - X × S; H ≔ Y × S; Y ≔ Y × C;
            D[I1] ≔ Z ≔ SQRT(F × F + H × H); C ≔ F / Z; S ≔ H / Z;
            F ≔ C × G + S × Y; X ≔ C × Y - S × G
         <u>end</u>;
      B[N1] ≔ F; D[N] ≔ X
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   END: EM[3] ≔ BMAX; EM[5] ≔ COUNT; EM[7] ≔ RNK; QRISNGVALBID ≔ N
<u>end</u> QRISNGVALBID;
<u>comment</u> ================== 34271 ================= ;
<u>integer</u> <u>procedure</u> QRISNGVALDECBID(D, B, M, N, U, V, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> D, B, U, V, EM;
<u>begin</u> <u>integer</u> N0, N1, K, K1, I, I1, COUNT, MAX, RNK;
   <u>real</u> TOL, BMAX, Z, X, Y, G, H, F, C, S, MIN;

   <u>procedure</u> ROTCOL(L, U, I, J, A, C, S);
      <u>value</u> L, U, I, J, C, S; <u>integer</u> L, U, I, J;
        <u>real</u> C, S; <u>array</u> A;
      <u>code</u> 34040;
   TOL ≔ EM[2] × EM[1]; COUNT ≔ 0; BMAX ≔ 0; MAX ≔ EM[4]; MIN ≔ EM[6];
   RNK ≔ N0 ≔ N;
   IN: K ≔ N; N1 ≔ N - 1;
   NEXT: K ≔ K - 1; <u>if</u> K &gt; 0 <u>then</u>
   <u>begin</u> <u>if</u> ABS(B[K]) &GreaterSlantEqual; TOL <u>then</u>
      <u>begin</u> <u>if</u> ABS(D[K]) &GreaterSlantEqual; TOL <u>then</u> <u>goto</u> NEXT;
         C ≔ 0; S ≔ 1;
         <u>for</u> I ≔ K <u>step</u> 1 <u>until</u> N1 <u>do</u>
            <u>begin</u> F ≔ S × B[I]; B[I] ≔ C × B[I]; I1 ≔ I + 1;
               <u>if</u> ABS(F) &lt; TOL <u>then</u> <u>goto</u> NEGLECT;
               G ≔ D[I1]; D[I1] ≔ H ≔ SQRT(F × F + G × G);
               C ≔ G / H; S ≔ - F / H;
               ROTCOL(1, M, K, I1, U, C, S)
            <u>end</u>;
         NEGLECT:
      <u>end</u>
        <u>else</u> <u>if</u> ABS(B[K]) &gt; BMAX <u>then</u> BMAX ≔ ABS(B[K])
   <u>end</u>;
   <u>if</u> K = N1 <u>then</u>
   <u>begin</u> <u>if</u> D[N] &lt; 0 <u>then</u>
      <u>begin</u> D[N] ≔ - D[N];
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N0 <u>do</u> V[I, N] ≔ - V[I, N]
      <u>end</u>;
      <u>if</u> D[N] &LessSlantEqual; MIN <u>then</u> RNK ≔ RNK - 1; N ≔ N1
   <u>end</u>
   <u>else</u>
   <u>begin</u> COUNT ≔ COUNT + 1; <u>if</u> COUNT &gt; MAX <u>then</u> <u>goto</u> END;
      K1 ≔ K + 1; Z ≔ D[N]; X ≔ D[K1]; Y ≔ D[N1];
      G ≔ <u>if</u> N1 = 1 <u>then</u> 0 <u>else</u> B[N1 - 1]; H ≔ B[N1];
      F ≔ ((Y - Z) × (Y + Z) + (G - H) × (G + H)) / (2 × H × Y);
      G ≔ SQRT(F × F + 1);
      F ≔ ((X - Z) × (X + Z) + H × (Y / (<u>if</u> F &lt; 0 <u>then</u> F - G
      <u>else</u> F + G) - H)) / X; C ≔ S ≔ 1;
      <u>for</u> I ≔ K1 + 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> I1 ≔ I - 1; G ≔ B[I1]; Y ≔ D[I]; H ≔ S × G; G ≔ C × G;
            Z ≔ SQRT(F × F + H × H); C ≔ F / Z; S ≔ H / Z;
            <u>if</u> I1 ≠ K1 <u>then</u> B[I1 - 1] ≔ Z; F ≔ X × C + G × S;
            G ≔ G × C - X × S; H ≔ Y × S; Y ≔ Y × C;
            ROTCOL(1, N0, I1, I, V, C, S);
            D[I1] ≔ Z ≔ SQRT(F × F + H × H); C ≔ F / Z; S ≔ H / Z;
            F ≔ C × G + S × Y; X ≔ C × Y - S × G;
            ROTCOL(1, M, I1, I, U, C, S)
         <u>end</u>;
      B[N1] ≔ F; D[N] ≔ X
   <u>end</u>;
   <u>if</u> N &gt; 0 <u>then</u> <u>goto</u> IN;
   END: EM[3] ≔ BMAX; EM[5] ≔ COUNT; EM[7] ≔ RNK; QRISNGVALDECBID ≔ N
<u>end</u> QRISNGVALDECBID;
<u>comment</u> ================== 34272 ================= ;
<u>integer</u> <u>procedure</u> QRISNGVAL(A, M, N, VAL, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, EM;
<u>begin</u> <u>array</u> B[1:N];

   <u>procedure</u> HSHREABID(A, M, N, D, B, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> D, B, EM;
      <u>code</u> 34260;

   <u>integer</u> <u>procedure</u> QRISNGVALBID(D, B, N, EM);
      <u>value</u> N; <u>integer</u> N; <u>array</u> D, B, EM;
      <u>code</u> 34270;

   HSHREABID(A, M, N, VAL, B, EM);
   QRISNGVAL ≔ QRISNGVALBID(VAL, B, N, EM)
<u>end</u> QRISNGVAL;
<u>comment</u> ================== 34273 ================= ;
<u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, VAL, V, EM;
<u>begin</u> <u>array</u> B[1:N];

   <u>procedure</u> HSHREABID(A, M, N, D, B, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, D, B, EM;
      <u>code</u> 34260;

   <u>procedure</u> PSTTFMMAT(A, N, V, B);
      <u>value</u> N; <u>integer</u> N; <u>array</u> A, V, B;
      <u>code</u> 34261;

   <u>procedure</u> PRETFMMAT(A, M, N, D);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> A, D;
      <u>code</u> 34262;

   <u>integer</u> <u>procedure</u> QRISNGVALDECBID(D, B, M, N, U, V, EM);
      <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> D, B, U, V, EM;
      <u>code</u> 34271;

   HSHREABID(A, M, N, VAL, B, EM);
   PSTTFMMAT(A, N, V, B);  PRETFMMAT(A, M, N, VAL);
   QRISNGVALDEC ≔ QRISNGVALDECBID(VAL, B, M, N, A, V, EM)
<u>end</u> QRISNGVALDEC;
<u>comment</u> ================== 34345 ================= ;
<u>procedure</u> COMKWD(PR, PI, QR, QI, GR, GI, KR, KI);
   <u>value</u> PR, PI, QR, QI; <u>real</u> PR, PI, QR, QI, GR, GI, KR, KI;
<u>begin</u>
   <u>procedure</u> COMMUL (AR, AI, BR, BI, RR, RI);
      <u>code</u> 34341;
   <u>procedure</u> COMDIV(XR, XI, YR, YI, ZR, ZI);
      <u>code</u> 34342;
   <u>procedure</u> COMSQRT(AR, AI, PR, PI);
      <u>code</u> 34343;
   <u>if</u> QR = 0 ∧ QI = 0 <u>then</u>
   <u>begin</u> KR ≔ KI ≔ 0 ; GR ≔ PR × 2; GI ≔ PI × 2 <u>end</u> <u>else</u>
   <u>if</u> PR = 0 ∧ PI = 0 <u>then</u>
   <u>begin</u> COMSQRT(QR, QI, GR, GI); KR ≔ -GR; KI ≔ -GI <u>end</u> <u>else</u>
   <u>begin</u> <u>real</u> HR, HI;
      <u>if</u> ABS(PR) &gt; 1 ∨ ABS(PI) &gt; 1 <u>then</u> <u>begin</u>
         COMDIV(QR, QI, PR, PI, HR, HI);
         COMDIV(HR, HI, PR, PI, HR, HI);
         COMSQRT(1 + HR, HI, HR, HI);
         COMMUL(PR, PI, HR + 1, HI, GR, GI);
      <u>end</u> <u>else</u> <u>begin</u> COMSQRT(QR + (PR + PI) × (PR-PI), QI + PR × PI × 2, HR, HI);
         <u>if</u> PR × HR + PI × HI &gt; 0 <u>then</u>
         <u>begin</u> GR ≔ PR + HR; GI ≔ PI + HI <u>end</u> <u>else</u>
         <u>begin</u> GR ≔ PR - HR; GI ≔ PI - HI <u>end</u>;
      <u>end</u>;
      COMDIV(-QR, -QI, GR, GI, KR, KI);
   <u>end</u>
<u>end</u> COMKWD;
<u>comment</u> ================== 32010 ================= ;
<u>real</u> <u>procedure</u> EULER(AI, I, EPS, TIM);
   <u>value</u> EPS, TIM; <u>integer</u> I, TIM; <u>real</u> AI, EPS;
<u>begin</u> <u>integer</u> K, N, T; <u>real</u> MN, MP, DS, SUM; <u>array</u> M[0:15];
   N ≔ T ≔ 0; I ≔ 0; M[0] ≔ AI; SUM ≔ M[0] / 2;
   NEXT TERM: I ≔ I + 1; MN ≔ AI;
   <u>for</u> K ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> MP ≔ (MN + M[K]) / 2; M[K] ≔ MN; MN ≔ MP <u>end</u>;
   <u>if</u> ABS(MN) &lt; ABS(M[N]) ∧ N &lt; 15 <u>then</u>
   <u>begin</u> DS ≔ MN / 2; N ≔ N + 1; M[N] ≔ MN <u>end</u> <u>else</u> DS ≔ MN;
   SUM ≔ SUM + DS; T ≔ <u>if</u> ABS(DS) &lt; EPS <u>then</u> T + 1 <u>else</u> 0;
   <u>if</u> T &lt; TIM <u>then</u> <u>go</u> <u>to</u> NEXT TERM;
   EULER ≔ SUM
<u>end</u> EULER;
<u>comment</u> ================== 32020 ================= ;
<u>real</u> <u>procedure</u> SUMPOSSERIES(AI, I, MAXADDUP, MAXZERO, MAXRECURS,
  MACHEXP, TIM);
   <u>value</u> MAXADDUP, MAXZERO, MAXRECURS, MACHEXP, TIM;
   <u>real</u> AI, I, MAXZERO; <u>integer</u> MAXADDUP, MAXRECURS, MACHEXP, TIM;
<u>begin</u> <u>integer</u> RECURS, VL, VL2, VL4;
   <u>real</u> <u>procedure</u> EULER(AI, I, EPS, TIM); <u>code</u> 32010;

   <u>real</u> <u>procedure</u> SUMUP(AI, I); <u>real</u> AI, I;
   <u>begin</u> <u>integer</u> J; <u>real</u> SUM, NEXTTERM;
      I ≔ MAXADDUP + 1; J ≔ 1;
      CHECK ADD: <u>if</u> AI &LessSlantEqual; MAXZERO <u>then</u>
      <u>begin</u> <u>if</u> J &lt; TIM <u>then</u>
         <u>begin</u> J ≔ J + 1; I ≔ I + 1; <u>go</u> <u>to</u> CHECK ADD <u>end</u>
      <u>end</u> <u>else</u>
      <u>if</u> RECURS ≠ MAXRECURS <u>then</u> <u>go</u> <u>to</u> TRANSFORMSERIES;
      SUM ≔ 0; I ≔ 0; J ≔ 0;
      ADD LOOP: I ≔ I + 1; NEXTTERM ≔ AI;
      J ≔ <u>if</u> NEXTTERM &LessSlantEqual; MAXZERO <u>then</u> J + 1 <u>else</u> 0;
      SUM ≔ SUM + NEXTTERM;
      <u>if</u> J &lt; TIM <u>then</u> <u>go</u> <u>to</u> ADD LOOP;
      SUMUP ≔ SUM; <u>go</u> <u>to</u> GOTSUM;
      TRANSFORMSERIES:
      <u>begin</u> <u>Boolean</u> JODD; <u>integer</u> J2; <u>array</u> V[1:VL];

         <u>real</u> <u>procedure</u> BJK(J, K); <u>value</u> J, K; <u>real</u> K;
              <u>integer</u> J;
         <u>begin</u> <u>real</u> COEFF;
            <u>if</u> K &gt; MACHEXP <u>then</u> BJK ≔ 0 <u>else</u>
            <u>begin</u> COEFF ≔ 2 ⭡ (K - 1); I ≔ J × COEFF;
               BJK ≔ COEFF × AI
            <u>end</u>
         <u>end</u> BJK;
         <u>real</u> <u>procedure</u> VJ(J); <u>value</u> J; <u>integer</u> J;
         <u>begin</u> <u>real</u> TEMP, K;
            <u>if</u> JODD <u>then</u>
            <u>begin</u> JODD ≔ <u>false</u>; RECURS ≔ RECURS + 1;
               TEMP ≔ VJ ≔ SUMUP(BJK(J, K), K);
               RECURS ≔ RECURS - 1;
               <u>if</u> J &LessSlantEqual; VL <u>then</u> V[J] ≔ TEMP <u>else</u>
               <u>if</u> J &LessSlantEqual; VL2 <u>then</u> V[J - VL] ≔ TEMP
            <u>end</u> <u>else</u>
            <u>begin</u> JODD ≔ <u>true</u>; <u>if</u> J &gt; VL4 <u>then</u>
               <u>begin</u> RECURS ≔ RECURS + 1;
                  VJ ≔ - SUMUP(BJK(J, K), K); RECURS ≔ RECURS - 1
               <u>end</u> <u>else</u>
               <u>begin</u> J2 ≔ J2 + 1; I ≔ J2;
                  <u>if</u> J &gt; VL2 <u>then</u> VJ ≔ - (V[J2 - VL] - AI) / 2
                  <u>else</u>
                  <u>begin</u> TEMP ≔ V[ <u>if</u> J &LessSlantEqual; VL <u>then</u> J <u>else</u>
                       J - VL] ≔ (V[J2] - AI) / 2; VJ ≔ - TEMP
                  <u>end</u>
               <u>end</u>
            <u>end</u>
         <u>end</u> VJ;

         J2 ≔ 0;
         JODD ≔ <u>true</u>; SUMUP ≔ EULER(VJ(J + 1), J, MAXZERO, TIM)
      <u>end</u> TRANSFORMSERIES;
      GOTSUM:
   <u>end</u> SUMUP;

   RECURS ≔ 0; VL ≔ 1000; VL2 ≔ 2 × VL; VL4 ≔ 2 × VL2;
   SUMPOSSERIES ≔ SUMUP(AI, I)
<u>end</u> SUMPOSSERIES;
<u>comment</u> ================== 32070 ================= ;
<u>real</u> <u>procedure</u> QADRAT(X, A, B, FX, E);
   <u>value</u> A, B; <u>real</u> X, A, B, FX; <u>array</u> E;
<u>begin</u> <u>real</u> F0, F2, F3, F5, F6, F7, F9,
     F14, V, W, HMIN, HMAX, RE, AE;

   <u>real</u> <u>procedure</u> LINT(X0, XN, F0, F2, F3, F5, F6, F7, F9, F14);
      <u>real</u> X0, XN, F0, F2, F3, F5, F6, F7, F9, F14;
   <u>begin</u> <u>real</u> H, XM, F1, F4, F8, F10, F11, F12, F13;
      XM ≔ (X0 + XN) / 2; H ≔ (XN - X0) / 32; X ≔ XM + 4 × H;
      F8 ≔ FX; X ≔ XN - 4 × H; F11 ≔ FX; X ≔ XN - 2 × H; F12 ≔ FX;
      V ≔ 0·330580178199226 × F7 + 0·173485115707338 × (F6 + F8) +
        0·321105426559972 × (F5 + F9) + 0·135007708341042 × (F3 + F11)
        + 0·165714514228223 × (F2 + F12) + 0·393971460638127&#9192;-1 × (F0
        + F14); X ≔ X0 + H; F1 ≔ FX; X ≔ XN - H; F13 ≔ FX;
      W ≔ 0·260652434656970 × F7 + 0·239063286684765 × (F6 + F8) +
        0·263062635477467 × (F5 + F9) + 0·218681931383057 × (F3 + F11)
        + 0·275789764664284&#9192;-1 × (F2 + F12) + 0·105575010053846 × (F1
        + F13) + 0·157119426059518&#9192;-1 × (F0 + F14);
      <u>if</u> ABS(H) &lt; HMIN <u>then</u> E[3] ≔ E[3] + 1;
      <u>if</u> ABS(V - W) &lt; ABS(W) × RE + AE ∨ ABS(H) &lt; HMIN
        <u>then</u> LINT ≔ H × W <u>else</u>
      <u>begin</u> X ≔ X0 + 6 × H; F4 ≔ FX; X ≔ XN - 6 × H; F10 ≔ FX;
         V ≔ 0·245673430093324 × F7 + 0·255786258286921 × (F6 + F8) +
           0·228526063690406 × (F5 + F9) + 0·500557131525460&#9192;-1 × (F4 +
           F10) + 0·177946487736780 × (F3 + F11) + 0·584014599347449&#9192;-1× (F2 + F12) + 0·874830942871331&#9192;-1 × (F1 + F13) +
           0·189642078648079&#9192;-1 × (F0 + F14);
         LINT ≔ <u>if</u> ABS(V - W) &lt; ABS(V) × RE + AE <u>then</u> H × V
         <u>else</u>
           LINT(X0, XM, F0, F1, F2, F3, F4, F5, F6, F7) - LINT(XN,
           XM, F14, F13, F12, F11, F10, F9, F8, F7)
      <u>end</u>
   <u>end</u> LINT;

   HMAX ≔ (B - A) / 16; <u>if</u> HMAX = 0 <u>then</u>
   <u>begin</u> QADRAT ≔ 0; <u>goto</u> RETURN <u>end</u>;
   RE ≔ E[1]; AE ≔ 2 × E[2] / ABS(B - A); E[3] ≔ 0;
   HMIN ≔ ABS(B - A) × RE; X ≔ A; F0 ≔ FX;
   X ≔ A + HMAX; F2 ≔ FX; X ≔ A + 2 × HMAX; F3 ≔ FX;
   X ≔ A + 4 × HMAX; F5 ≔ FX; X ≔ A + 6 × HMAX; F6 ≔ FX;
   X ≔ A + 8 × HMAX; F7 ≔ FX; X ≔ B - 4 × HMAX; F9 ≔ FX; X ≔ B;
   F14 ≔ FX;
   QADRAT ≔ LINT(A, B, F0, F2, F3, F5, F6, F7, F9, F14) × 16;
   RETURN:
<u>end</u> QADRAT;
<u>comment</u> ================== 32051 ================= ;
<u>real</u> <u>procedure</u> INTEGRAL(X, A, B, FX, E, UA, UB);
   <u>value</u> A, B; <u>real</u> X, A, B, FX; <u>array</u> E; <u>Boolean</u> UA, UB;
<u>begin</u>
   <u>real</u> <u>procedure</u> TRANSF;
   <u>begin</u> Z ≔ 1 / X; X ≔ Z + B1; TRANSF ≔ FX × Z × Z <u>end</u>;
   <u>real</u> <u>procedure</u> QAD(FX); <u>real</u> FX;
   <u>begin</u> <u>real</u> T, V, SUM, HMIN;
      <u>procedure</u> INT;
      <u>begin</u> <u>real</u> X3, X4, F3, F4, H;
         X4 ≔ X2; X2 ≔ X1; F4 ≔ F2; F2 ≔ F1;
         ANEW: X ≔ X1 ≔ (X0 + X2) × ·5; F1 ≔ FX;
         X ≔ X3 ≔ (X2 + X4) × ·5; F3 ≔ FX; H ≔ X4 - X0;
         V ≔ (4 × (F1 + F3) + 2  × F2 + F0 + F4) × 15;
         T ≔ 6 × F2 -4  × (F1 + F3) + F0 + F4;
         <u>if</u> ABS(T) &lt; ABS(V) × RE + AE <u>then</u>
           SUM ≔ SUM + (V - T) × H <u>else</u>
         <u>if</u> ABS(H) &lt; HMIN <u>then</u> E[3] ≔ E[3] + 1
         <u>else</u>
         <u>begin</u> INT; X2 ≔ X3; F2 ≔ F3; <u>goto</u> ANEW <u>end</u>;
         X0 ≔ X4; F0 ≔ F4
      <u>end</u> INT;

      HMIN ≔ ABS(X0 - X2) × RE; X ≔ X1 ≔ (X0 + X2) × ·5;
      F1 ≔ FX; SUM ≔ 0; INT; QAD ≔ SUM / 180
   <u>end</u> QAD;
   <u>real</u> X0, X1, X2, F0, F1, F2, RE, AE, B1, Z;
   RE ≔ E[1]; <u>if</u> UB <u>then</u> AE ≔ E[2] × 180 / ABS(B - A)
   <u>else</u> AE ≔ E[2] × 90 / ABS(B - A); <u>if</u> UA <u>then</u>
   <u>begin</u> E[3] ≔ E[4] ≔ 0; X ≔ X0 ≔ A; F0 ≔ FX <u>end</u>
   <u>else</u>
   <u>begin</u> X ≔ X0 ≔ A ≔ E[5]; F0 ≔ E[6] <u>end</u>;
   E[5] ≔ X ≔ X2 ≔ B; E[6] ≔ F2 ≔ FX; E[4] ≔ E[4] + QAD(FX);
   <u>if</u>  ¬UB <u>then</u>
   <u>begin</u> <u>if</u> A &lt; B <u>then</u>
      <u>begin</u> B1 ≔ B -1 ; X0 ≔ 1 <u>end</u>
      <u>else</u>
      <u>begin</u> B1 ≔ B + 1 ; X0 ≔ -1  <u>end</u>;
      F0 ≔ E[6]; E[5] ≔ X2 ≔ 0; E[6] ≔ F2 ≔ 0;
      AE ≔ E[2] × 90;
      E[4] ≔ E[4] - QAD(TRANSF)
   <u>end</u>;
   INTEGRAL ≔ E[4]
<u>end</u> INTEGRAL;
<u>comment</u> ================== 34210 ================= ;
<u>procedure</u> LINEMIN(N, X, D, ND, ALFA, G, FUNCT, F0, F1, DF0, DF1,
  EVLMAX, STRONGSEARCH, IN); <u>value</u> N, ND, F0, DF0, STRONGSEARCH;
   <u>integer</u> N, EVLMAX; <u>Boolean</u> STRONGSEARCH;
     <u>real</u> ND, ALFA, F0, F1, DF0, DF1;
     <u>array</u> X, D, G, IN;
     <u>real</u> <u>procedure</u> FUNCT;
<u>begin</u> <u>integer</u> I, EVL;
   <u>Boolean</u> NOTININT;
   <u>real</u> F, OLDF, DF, OLDDF, MU, ALFA0, Q, W, Y, Z, RELTOL, ABSTOL
     , EPS, AID;
   <u>array</u> X0[1:N];
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B); <u>code</u> 31030;

   RELTOL ≔ IN[1]; ABSTOL ≔ IN[2]; MU ≔ IN[3]; EVL ≔ 0;
   ALFA0 ≔ 0; OLDF ≔ F0; OLDDF ≔ DF0; Y ≔ ALFA; NOTININT ≔ <u>true</u>;
   DUPVEC(1, N, 0, X0, X);
   EPS ≔ (SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL) / ND;
   Q ≔ (F1 - F0) / (ALFA × DF0);
   INT: <u>if</u> NOTININT <u>then</u> NOTININT ≔ DF1 &lt; 0 ∧ Q &gt; MU;
   AID ≔ ALFA; <u>if</u> DF1 &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> Z ≔ 3 × (OLDF - F1) / ALFA + OLDDF + DF1;
      W ≔ SQRT(Z ⭡ 2 - OLDDF × DF1);
      ALFA ≔ ALFA × (1 - (DF1 + W - Z) / (DF1 - OLDDF + W × 2));
      <u>if</u> ALFA &lt; EPS <u>then</u> ALFA ≔ EPS <u>else</u>
      <u>if</u> AID - ALFA &lt; EPS <u>then</u> ALFA ≔ AID - EPS
   <u>end</u> CUBIC INTERPOLATION
     <u>else</u> <u>if</u> NOTININT <u>then</u>
   <u>begin</u> ALFA0 ≔ ALFA ≔ Y; OLDDF ≔ DF1; OLDF ≔ F1 <u>end</u>
   <u>else</u> ALFA ≔ 0·5 × ALFA; Y ≔ ALFA + ALFA0;
   DUPVEC(1, N, 0, X, X0); ELMVEC(1, N, 0, X, D, Y);
   EPS ≔ (SQRT(VECVEC(1, N, 0, X, X)) × RELTOL + ABSTOL) / ND;
   F ≔ FUNCT(N, X, G); EVL ≔ EVL + 1 ; DF ≔ VECVEC(1, N, 0, D, G);
   Q ≔ (F - F0) / (Y × DF0);
   <u>if</u> (<u>if</u> NOTININT ∨ STRONGSEARCH <u>then</u> <u>true</u> <u>else</u>
     Q &lt; MU ∨ Q &gt; 1 - MU) ∧ EVL &lt; EVLMAX <u>then</u>
   <u>begin</u> <u>if</u> NOTININT ∨ DF &gt; 0 ∨ Q &lt; MU <u>then</u>
      <u>begin</u> DF1 ≔ DF; F1 ≔ F <u>end</u>
      <u>else</u>
      <u>begin</u> ALFA0 ≔ Y; ALFA ≔ AID - ALFA; OLDDF ≔ DF; OLDF ≔ F
      <u>end</u>;
      <u>if</u> ALFA &gt; EPS × 2 <u>then</u> <u>goto</u> INT
   <u>end</u>;
   ALFA ≔ Y; EVLMAX ≔ EVL; DF1 ≔ DF; F1 ≔ F
<u>end</u> LINEMIN;
<u>comment</u> ================== 34211 ================= ;
<u>procedure</u> RNK1UPD(H, N, V, C); <u>value</u> N, C; <u>integer</u> N;
     <u>real</u> C; <u>array</u> H, V;
<u>begin</u> <u>integer</u> J, K;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   K ≔ 0;
   <u>for</u> J ≔ 1, J + K <u>while</u> K &lt; N <u>do</u>
      <u>begin</u> K ≔ K + 1 ;
         ELMVEC(J, J + K - 1, 1 - J, H, V, V[K] × C)
      <u>end</u>
<u>end</u> RNK1UPD;
<u>comment</u> ================== 34212 ================= ;
<u>procedure</u> DAVUPD(H, N, V, W, C1, C2); <u>value</u> N, C1, C2;
   <u>integer</u> N; <u>real</u> C1, C2; <u>array</u> H, V, W;
<u>begin</u> <u>integer</u> I, J, K;
   <u>real</u> VK, WK;
   K ≔ 0;
   <u>for</u> J ≔ 1, J + K <u>while</u> K &lt; N <u>do</u>
      <u>begin</u> K ≔ K + 1 ; VK ≔ V[K] × C1; WK ≔ W[K] × C2;
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> K -1  <u>do</u>
              H[I + J] ≔ H[I + J] + V[I + 1] × VK - W[I + 1] × WK
      <u>end</u>
<u>end</u> DAVUPD;
<u>comment</u> ================== 34213 ================= ;
<u>procedure</u> FLEUPD(H, N, V, W, C1, C2); <u>value</u> N, C1, C2;
   <u>integer</u> N; <u>real</u> C1, C2; <u>array</u> H, V, W;
<u>begin</u> <u>integer</u> I, J, K;
   <u>real</u> VK, WK;
   K ≔ 0; <u>for</u> J ≔ 1, J + K <u>while</u> K &lt; N <u>do</u>
      <u>begin</u> K ≔ K + 1; VK ≔ - W[K] × C1 + V[K] × C2; WK ≔ V[K] × C1;
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> K - 1  <u>do</u>
              H[I + J] ≔ H[I + J] + V[I + 1] × VK -W[I + 1] × WK
      <u>end</u>
<u>end</u> FLEUPD;
<u>comment</u> ================== 33010 ================= ;
<u>procedure</u> RK1(X, A, B, Y, YA, FXY, E, D, FI);
   <u>value</u> B, FI; <u>real</u> X, A, B, Y, YA, FXY; <u>Boolean</u> FI;
     <u>array</u> E, D;
<u>begin</u> <u>real</u> E1, E2, XL, YL, H, INT, HMIN, ABSH, K0, K1,
     K2, K3, K4, K5, DISCR, TOL, MU, MU1, FH, HL;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ A; D[4] ≔ YA <u>end</u>;
   D[1] ≔ 0; XL ≔ D[3]; YL ≔ D[4];
   <u>if</u> FI <u>then</u> D[2] ≔ B - D[3]; ABSH ≔ H ≔ ABS(D[2]);
   <u>if</u> B - XL &lt; 0 <u>then</u> H ≔ - H; INT ≔ ABS(B - XL);
   HMIN ≔ INT × E[1] + E[2]; E1 ≔ E[1] / INT;
   E2 ≔ E[2] / INT; FIRST ≔ <u>true</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN; ABSH ≔ HMIN
   <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; B - XL ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> D[2] ≔ H; LAST ≔ <u>true</u>; H ≔ B - XL;
      ABSH ≔ ABS(H)
   <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: X ≔ XL; Y ≔ YL; K0 ≔ FXY × H;
   X ≔ XL + H / 4·5; Y ≔ YL + K0 / 4·5;
   K1 ≔ FXY × H; X ≔ XL + H / 3;
   Y ≔ YL + (K0 + K1 × 3) / 12; K2 ≔ FXY × H;
   X ≔ XL + H × ·5; Y ≔ YL + (K0 + K2 × 3) / 8;
   K3 ≔ FXY × H; X ≔ XL + H × ·8;
   Y ≔ YL + (K0 × 53 - K1 × 135 + K2 × 126 + K3 × 56)
     / 125; K4 ≔ FXY × H; X ≔ <u>if</u> LAST <u>then</u> B <u>else</u> XL + H;
   Y ≔ YL + (K0 × 133 - K1 × 378 + K2 × 276 + K3 × 112
     + K4 × 25) / 168; K5 ≔ FXY × H;
   DISCR ≔ ABS(K0 × 21 - K2 × 162 + K3 × 224 - K4 × 125
     + K5 × 42) / 14; TOL ≔ ABS(K0) × E1 + ABSH × E2;
   REJECT ≔ DISCR &gt; TOL; MU ≔ TOL / (TOL + DISCR) + ·45;
   <u>if</u> REJECT <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> D[1] ≔ D[1] + 1; Y ≔ YL; FIRST ≔ <u>true</u>;
         <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FH ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FH × H;
   ACC: MU1 ≔ MU;
   Y ≔ YL + ( - K0 × 63 + K1 × 189 - K2 × 36 - K3 × 112
     + K4 × 50) / 28; K5 ≔ FXY × HL;
   Y ≔ YL + (K0 × 35 + K2 × 162 + K4 × 125 + K5 × 14)
     / 336;

   NEXT: <u>if</u> B ≠ X <u>then</u>
   <u>begin</u> XL ≔ X; YL ≔ Y; <u>goto</u> TEST <u>end</u>;
   <u>if</u> ¬LAST <u>then</u> D[2] ≔ H; D[3] ≔ X; D[4] ≔ Y
<u>end</u> RK1;
<u>comment</u> ================== 33033 ================= ;
<u>procedure</u> RKE (X, XE, N, Y, DER, DATA, FI, OUT);
   <u>value</u>  FI, N; <u>integer</u> N; <u>real</u> X, XE;
     <u>Boolean</u> FI; <u>array</u> Y, DATA;
     <u>procedure</u> DER, OUT;
<u>begin</u> <u>integer</u> J;
   <u>real</u> XT, H, HMIN, INT, HL, HT, ABSH, FHM, DISCR, TOL, MU,
     MU1, FH, E1, E2;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>array</u> K0, K1, K2, K3, K4[1:N];
   <u>if</u> FI <u>then</u>
   <u>begin</u> DATA[3] ≔ XE - X; DATA[4] ≔ DATA[5] ≔ DATA[6] ≔ 0 <u>end</u>;
   ABSH ≔ H ≔ ABS(DATA[3]);
   <u>if</u> XE &lt; X <u>then</u> H ≔ - H; INT ≔ ABS(XE - X);
   HMIN ≔ INT × DATA[1] + DATA[2];
   E1 ≔ 12 × DATA[1] / INT; E2 ≔ 12 × DATA[2] / INT;
   FIRST ≔ <u>true</u>; REJECT ≔ <u>false</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ SIGN (XE - X) × HMIN; ABSH ≔ HMIN <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; XE - X ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; H ≔ XE - X; ABSH ≔ ABS(H) <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: <u>if</u> ¬REJECT <u>then</u>
   <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K0[J] ≔ Y[J];
      DER(X, K0)
   <u>end</u>;
   HT ≔ ·184262134833347 × H; XT ≔ X + HT;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K1[J] ≔ K0[J] × HT + Y[J];
   DER(XT, K1);
   HT ≔ ·690983005625053&#9192;-1 × H; XT ≔ 4 × HT + X;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K2[J] ≔         (3 × K1[J] + K0[J]) × HT + Y[J];
   DER(XT, K2);
   XT ≔ ·5 × H + X; HT ≔ ·1875 × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K3[J] ≔ ((1·74535599249993× K2[J] - K1[J]) × 2·23606797749979 + K0[J]) × HT + Y[J];
   DER(XT, K3);
   XT ≔ ·723606797749979 × H + X; HT ≔ ·4 × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K4[J] ≔ (((·517595468166681× K0[J] - K1[J]) × ·927050983124840 + K2[J]) × 1·46352549156242
        + K3[J]) × HT + Y[J];
   DER(XT, K4);
   XT ≔ <u>if</u> LAST <u>then</u> XE <u>else</u> X + H; HT ≔ 2 × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K1[J] ≔ ((((2 × K4[J] +
        K2[J]) × ·412022659166595 + K1[J]) × 2·23606797749979 -
        K0[J]) × ·375 - K3[J]) × HT + Y[J];
   DER(XT, K1);
   REJECT ≔ <u>false</u>; FHM ≔ 0;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> DISCR ≔ ABS((1·6 × K3[J] - K2[J] - K4[J]) × 5 +
           K0[J] + K1[J]);
         TOL ≔ ABS(K0[J]) × E1 + E2;
         REJECT ≔ DISCR &gt; TOL ∨ REJECT;
         FH ≔ DISCR / TOL; <u>if</u> FH &gt; FHM <u>then</u> FHM ≔ FH
      <u>end</u>;
   MU ≔ 1 / (1 + FHM) + ·45; <u>if</u> REJECT <u>then</u>
   <u>begin</u> DATA[5] ≔ DATA[5] + 1; <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> DATA[6] ≔ DATA[6] + 1; HL ≔ H; REJECT ≔ <u>false</u>;
         FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FH ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FH × H;
   ACC: MU1 ≔ MU; HT ≔ HL / 12;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[J] ≔         ((K2[J] + K4[J]) × 5 + K0[J] + K1[J]) × HT + Y[J];
   NEXT: DATA[3] ≔ HL; DATA[4] ≔ DATA[4] + 1; X ≔ XT; OUT;
   <u>if</u> X ≠ XE <u>then</u> <u>goto</u> TEST
<u>end</u> RKE;
<u>comment</u> ================== 33016 ================= ;
<u>procedure</u> RK4A(X, XA, B, Y, YA, FXY, E, D, FI, XDIR,
  POS); <u>value</u> FI, XDIR, POS; <u>Boolean</u> FI, XDIR, POS;
     <u>real</u> X, XA, B, Y, YA, FXY; <u>array</u> E, D;
<u>begin</u> <u>integer</u> I;
   <u>Boolean</u> IV, FIRST, FIR, REJ;
   <u>real</u> K0, K1, K2, K3, K4, K5, FHM, ABSH, DISCR, S, XL,
     COND0, S1, COND1, YL, HMIN, H, ZL, TOL, HL, MU, MU1;
   <u>array</u> E1[1:2];

   <u>Boolean</u> <u>procedure</u> ZEROIN(X, Y, FX, EPS) ; <u>real</u> X, Y, FX, EPS ;
      <u>code</u>            34150 ;

   <u>procedure</u> RKSTEP(X, XL, H, Y, YL, ZL, FXY, D);
      <u>value</u> XL, YL, ZL, H; <u>real</u> X, XL, H, Y, YL, ZL, FXY;
        <u>integer</u> D;
   <u>begin</u> <u>if</u> D = 2 <u>then</u> <u>goto</u> INTEGRATE; <u>if</u> D = 3 <u>then</u>
      <u>begin</u> X ≔ XL; Y ≔ YL; K0 ≔ FXY × H <u>end</u>
        <u>else</u> <u>if</u> D = 1 <u>then</u> K0 ≔ ZL × H <u>else</u> K0 ≔ K0 × MU;
      X ≔ XL + H / 4·5; Y ≔ YL + K0 / 4·5; K1 ≔ FXY × H;
      X ≔ XL + H / 3; Y ≔ YL + (K0 + K1 × 3) / 12;
      K2 ≔ FXY × H; X ≔ XL + H × ·5;
      Y ≔ YL + (K0 + K2 × 3) / 8; K3 ≔ H × FXY;
      X ≔ XL + H × ·8;
      Y ≔ YL + (K0 × 53 - K1 × 135 + K2 × 126 + K3 ×
        56) / 125; K4 ≔ FXY × H; <u>if</u> D &LessSlantEqual; 1 <u>then</u>
      <u>begin</u> X ≔ XL + H;
         Y ≔ YL + (K0 × 133 - K1 × 378 + K2 × 276 + K3× 112 + K4 × 25) / 168; K5 ≔ FXY × H;
         DISCR ≔ ABS(K0 × 21 - K2 × 162 + K3 × 224 - K4× 125 + K5 × 42) / 14; <u>goto</u> END
      <u>end</u>;
      INTEGRATE: X ≔ XL + H;
      Y ≔ YL + ( - K0 × 63 + K1 × 189 - K2 × 36 - K3 ×
        112 + K4 × 50) / 28; K5 ≔ FXY × H;
      Y ≔ YL + (K0 × 35 + K2 × 162 + K4 × 125 + K5 ×
        14) / 336;
      END:
   <u>end</u> RKSTEP;
   <u>real</u> <u>procedure</u> FZERO;
   <u>begin</u> <u>if</u> IV <u>then</u>
      <u>begin</u> <u>if</u> S = XL <u>then</u> FZERO ≔ COND0 <u>else</u> <u>if</u> S = S1
           <u>then</u> FZERO ≔ COND1 <u>else</u>
         <u>begin</u> RKSTEP(X, XL, S - XL, Y, YL, ZL, FXY, 3);
            FZERO ≔ B
         <u>end</u>
      <u>end</u>
      <u>else</u>
      <u>begin</u> <u>if</u> S = YL <u>then</u> FZERO ≔ COND0 <u>else</u> <u>if</u> S = S1
           <u>then</u> FZERO ≔ COND1 <u>else</u>
         <u>begin</u> RKSTEP(Y, YL, S - YL, X, XL, ZL, 1 /
              FXY, 3); FZERO ≔ B
         <u>end</u>
      <u>end</u>
   <u>end</u> FZERO;

   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ XA; D[4] ≔ YA; D[0] ≔ 1 <u>end</u>;
   D[1] ≔ 0; X ≔ XL ≔ D[3]; Y ≔ YL ≔ D[4]; IV ≔ D[0] &gt; 0;
   FIRST ≔ FIR ≔ <u>true</u>; HMIN ≔ E[0] + E[1];
   H ≔ E[2] + E[3]; <u>if</u> H &lt; HMIN <u>then</u> HMIN ≔ H;
   CHANGE: ZL ≔ FXY; <u>if</u> ABS(ZL) &LessSlantEqual; 1 <u>then</u>
   <u>begin</u> <u>if</u> ¬IV <u>then</u>
      <u>begin</u> D[2] ≔ H ≔ H / ZL; D[0] ≔ 1;
         IV ≔ FIRST ≔ <u>true</u>
      <u>end</u>;
      <u>if</u> FIR <u>then</u> <u>goto</u> A; I ≔ 1; <u>goto</u> AGAIN
   <u>end</u>
   <u>else</u>
   <u>begin</u> <u>if</u> IV <u>then</u>
      <u>begin</u> <u>if</u> ¬FIR <u>then</u> D[2] ≔ H ≔ H × ZL; D[0] ≔ - 1;
         IV ≔ <u>false</u>; FIRST ≔ <u>true</u>
      <u>end</u>;
      <u>if</u> FIR <u>then</u>
      <u>begin</u> H ≔ E[0] + E[1];
         A: <u>if</u> (<u>if</u> FI <u>then</u> (<u>if</u> IV ≡ XDIR <u>then</u> H <u>else</u>
           H × ZL) &lt; 0 ≡ POS <u>else</u> H × D[2] &lt; 0) <u>then</u> H ≔ - H
      <u>end</u>;
      I ≔ 1
   <u>end</u>;
   AGAIN: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ SIGN(H) × HMIN; ABSH ≔ HMIN <u>end</u>;
   <u>if</u> IV <u>then</u>
   <u>begin</u> RKSTEP(X, XL, H, Y, YL, ZL, FXY, I);
      TOL ≔ E[2] × ABS(K0) + E[3] × ABSH
   <u>end</u>
   <u>else</u>
   <u>begin</u> RKSTEP(Y, YL, H, X, XL, 1 / ZL, 1 / FXY, I);
      TOL ≔ E[0] × ABS(K0) + E[1] × ABSH
   <u>end</u>;
   REJ ≔ DISCR &gt; TOL; MU ≔ TOL / (TOL + DISCR) + ·45;
   <u>if</u> REJ <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> <u>if</u> IV <u>then</u>
         <u>begin</u> X ≔ XL + H; Y ≔ YL + K0 <u>end</u>
         <u>else</u>
         <u>begin</u> X ≔ XL + K0; Y ≔ YL + H <u>end</u>;
         D[1] ≔ D[1] + 1; FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ H × MU; I ≔ 0; <u>goto</u> AGAIN
   <u>end</u> REJ;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ FIR; HL ≔ H; H ≔ MU × H; <u>goto</u> ACCEPT
   <u>end</u>;
   FHM ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FHM × H;
   ACCEPT: <u>if</u> IV <u>then</u> RKSTEP(X, XL, HL, Y, YL, ZL, FXY,
     2) <u>else</u> RKSTEP(Y, YL, HL, X, XL, ZL, 1 / FXY, 2);
   MU1 ≔ MU;
   NEXT: <u>if</u> FIR <u>then</u>
   <u>begin</u> FIR ≔ <u>false</u>; COND0 ≔ B;
      <u>if</u> ¬(FI ∨ REJ) <u>then</u> H ≔ D[2]
   <u>end</u>
   <u>else</u>
   <u>begin</u> D[2] ≔ H; COND1 ≔ B;
      <u>if</u> COND0 × COND1 &LessSlantEqual; 0 <u>then</u> <u>goto</u> ZERO;
      COND0 ≔ COND1
   <u>end</u>;
   D[3] ≔ XL ≔ X; D[4] ≔ YL ≔ Y; <u>goto</u> CHANGE;
   ZERO: E1[1] ≔ E[4]; E1[2] ≔ E[5];
   S1 ≔ <u>if</u> IV <u>then</u> X <u>else</u> Y;
   S ≔ <u>if</u> IV <u>then</u> XL <u>else</u> YL ;
   ZEROIN(S, S1, FZERO, ABS(E1[1] × S) + ABS(E1[2])) ;
   S1 ≔ <u>if</u> IV <u>then</u> X <u>else</u> Y ;
   <u>if</u> IV <u>then</u> RKSTEP(X, XL, S - XL, Y, YL, ZL, FXY, 3)
   <u>else</u> RKSTEP(Y, YL, S - YL, X, XL, ZL, 1 / FXY,
     3); D[3] ≔ X; D[4] ≔ Y
<u>end</u> RK4A;
<u>comment</u> ================== 33017 ================= ;
<u>procedure</u> RK4NA(X, XA, B, FXJ, J, E, D, FI, N, L, POS);
   <u>value</u> FI, N, L, POS; <u>integer</u> J, N, L; <u>Boolean</u> FI, POS;
     <u>real</u> B, FXJ; <u>array</u> X, XA, E, D;
<u>begin</u> <u>integer</u> I, IV, IV0;
   <u>Boolean</u> FIR, FIRST, REJ;
   <u>real</u> H, COND0, COND1, FHM, ABSH, TOL, FH, MAX, X0,
     X1, S, HMIN, HL, MU, MU1;
   <u>array</u> XL, DISCR, Y[0:N], K[0:5, 0:N], E1[1:2];

   <u>Boolean</u> <u>procedure</u> ZEROIN(X, Y, FX, EPS) ; <u>real</u> X, Y, FX, EPS ;
      <u>code</u>            34150 ;

   <u>procedure</u> RKSTEP(H, D); <u>value</u> H, D; <u>integer</u> D; <u>real</u> H;
   <u>begin</u> <u>integer</u> I;
      <u>procedure</u> F(T); <u>value</u> T; <u>integer</u> T;
      <u>begin</u> <u>integer</u> I;
         <u>real</u> P;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[J] ≔ FXJ;
         P ≔ H / Y[IV];
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>if</u> I ≠ IV <u>then</u> K[T, I] ≔ Y[I] × P <u>end</u>
      <u>end</u> F;

      <u>if</u> D = 2 <u>then</u> <u>goto</u> INTEGRATE; <u>if</u> D = 3 <u>then</u>
      <u>begin</u> <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I];
         F(0)
      <u>end</u>
        <u>else</u> <u>if</u> D = 1 <u>then</u>
      <u>begin</u> <u>real</u> P;
         P ≔ H / Y[IV];
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>if</u> I ≠ IV <u>then</u> K[0, I] ≔ P × Y[I] <u>end</u>
      <u>end</u>
      <u>else</u>
        <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>if</u> I ≠ IV <u>then</u> K[0, I] ≔ K[0, I] × MU <u>end</u>;
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] + (<u>if</u> I= IV <u>then</u> H <u>else</u> K[0, I]) / 4·5; F(1);
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] + (<u>if</u> I= IV <u>then</u> H × 4 <u>else</u> (K[0, I] + K[1, I] × 3)) / 12;
      F(2);
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] + (<u>if</u> I= IV <u>then</u> H × ·5 <u>else</u> (K[0, I] + K[2, I] × 3) / 8);
      F(3);
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] + (<u>if</u> I= IV <u>then</u> H × ·8 <u>else</u> (K[0, I] × 53 - K[1, I] × 135
           + K[2, I] × 126 + K[3, I] × 56) / 125); F(4);
      <u>if</u> D &LessSlantEqual; 1 <u>then</u>
      <u>begin</u> <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] +
              (<u>if</u> I = IV <u>then</u> H <u>else</u> (K[0, I] × 133 -
              K[1, I] × 378 + K[2, I] × 276 + K[3, I] × 112 +
              K[4, I] × 25) / 168); F(5);
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>if</u> I ≠ IV <u>then</u> DISCR[I] ≔ ABS(K[0, I] × 21
                 - K[2, I] × 162 + K[3, I] × 224 - K[4, I] ×
                 125 + K[5, I] × 42) / 14
            <u>end</u>;
         <u>goto</u> END
      <u>end</u>;
      INTEGRATE: <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I]
           + (<u>if</u> I = IV <u>then</u> H <u>else</u> ( - K[0, I] × 63 + K[1, I]× 189 - K[2, I] × 36 - K[3, I] × 112 + K[4, I] × 50)
           / 28); F(5);
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>if</u> I ≠ IV <u>then</u> X[I] ≔ XL[I] + (K[0, I] × 35
              + K[2, I] × 162 + K[4, I] × 125 + K[5, I] × 14) / 336
         <u>end</u> ;
      END:
   <u>end</u> RKSTEP ;
   <u>real</u> <u>procedure</u> FZERO;
   <u>begin</u> <u>if</u> S = X0 <u>then</u> FZERO ≔ COND0 <u>else</u> <u>if</u> S = X1
        <u>then</u> FZERO ≔ COND1 <u>else</u>
      <u>begin</u> RKSTEP(S - XL[IV], 3); FZERO ≔ B <u>end</u>
   <u>end</u> FZERO;

   <u>if</u> FI <u>then</u>
   <u>begin</u> <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> D[I + 3] ≔ XA[I];
      D[0] ≔ D[2] ≔ 0
   <u>end</u>;
   D[1] ≔ 0;
   <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> X[I] ≔ XL[I] ≔ D[I + 3];
   IV ≔ D[0]; H ≔ D[2]; FIRST ≔ FIR ≔ <u>true</u>; Y[0] ≔ 1;
   <u>goto</u> CHANGE;
   AGAIN: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN;
      ABSH ≔ ABS(H)
   <u>end</u>;
   RKSTEP(H, I); REJ ≔ <u>false</u>; FHM ≔ 0;
   <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> I ≠ IV <u>then</u>
         <u>begin</u> TOL ≔ E[2 × I] × ABS(K[0, I]) + E[2 × I + 1]× ABSH; REJ ≔ TOL &lt; DISCR[I] ∨ REJ;
            FH ≔ DISCR[I] / TOL; <u>if</u> FH &gt; FHM <u>then</u> FHM ≔ FH
         <u>end</u>
      <u>end</u>;
   MU ≔ 1 / (1 + FHM) + ·45; <u>if</u> REJ <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>if</u> I ≠ IV <u>then</u> X[I] ≔ XL[I] + K[0, I]
               <u>else</u> X[I] ≔ XL[I] + H
            <u>end</u>;
         D[1] ≔ D[1] + 1; FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ H × MU; I ≔ 0; <u>goto</u> AGAIN
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ FIR; HL ≔ H; H ≔ MU × H; <u>goto</u> ACCEPT
   <u>end</u>;
   FH ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FH × H;
   ACCEPT: RKSTEP(HL, 2); MU1 ≔ MU;
   NEXT: <u>if</u> FIR <u>then</u>
   <u>begin</u> FIR ≔ <u>false</u>; COND0 ≔ B;
      <u>if</u> ¬(FI ∨ REJ) <u>then</u> H ≔ D[2]
   <u>end</u>
   <u>else</u>
   <u>begin</u> D[2] ≔ H; COND1 ≔ B;
      <u>if</u> COND0 × COND1 &LessSlantEqual; 0 <u>then</u> <u>goto</u> ZERO;
      COND0 ≔ COND1
   <u>end</u>;
   <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> D[I + 3] ≔ XL[I] ≔ X[I];
   CHANGE: IV0 ≔ IV;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[J] ≔ FXJ;
   MAX ≔ ABS(Y[IV]);
   <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> <u>if</u> ABS(Y[I]) &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ ABS(Y[I]); IV ≔ I <u>end</u>
      <u>end</u>;
   <u>if</u> IV0 ≠ IV <u>then</u>
   <u>begin</u> FIRST ≔ <u>true</u>; D[0] ≔ IV;
      D[2] ≔ H ≔ Y[IV] / Y[IV0] × H
   <u>end</u>;
   X0 ≔ XL[IV]; <u>if</u> FIR <u>then</u>
   <u>begin</u> HMIN ≔ E[0] + E[1];
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> H ≔ E[2 × I] + E[2 × I + 1];
            <u>if</u> H &lt; HMIN <u>then</u> HMIN ≔ H
         <u>end</u>;
      H ≔ E[2 × IV] + E[2 × IV + 1];
      <u>if</u> (FI ∧ (Y[L]/Y[IV] × H &lt; 0 ≡ POS)) ∨
        ( ¬FI ∧ D[2] × H &lt; 0) <u>then</u> H ≔ -H
   <u>end</u>;
   I ≔ 1; <u>goto</u> AGAIN;
   ZERO: E1[1] ≔ E[2 × N + 2]; E1[2] ≔ E[2 × N + 3];
   X1 ≔ X[IV] ; S ≔ X0 ;
   ZEROIN(S, X1, FZERO, ABS(E1[1] × S) + ABS(E1[2])) ; X0 ≔ S ; X1 ≔ X[IV];
   RKSTEP(X0 - XL[IV], 3);
   <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u> D[I + 3] ≔ X[I]
<u>end</u> RK4NA;
<u>comment</u> ================== 33080 ================= ;
<u>Boolean</u> <u>procedure</u> MULTISTEP(X, XEND, Y, HMIN, HMAX, YMAX, EPS,
  FIRST, SAVE, DERIV, AVAILABLE, JACOBIAN, STIFF, N, OUT);
   <u>value</u> HMIN, HMAX, EPS, XEND, N, STIFF;
   <u>Boolean</u> FIRST, AVAILABLE, STIFF;
     <u>integer</u> N;
     <u>real</u> X, XEND, HMIN, HMAX, EPS;
     <u>array</u> Y, YMAX, SAVE, JACOBIAN;
     <u>procedure</u> DERIV, OUT;
<u>begin</u> <u>own</u> <u>Boolean</u> ADAMS, WITH JACOBIAN;
   <u>own</u> <u>integer</u> M, SAME, KOLD;
   <u>own</u> <u>real</u> XOLD, HOLD, A0, TOLUP, TOL, TOLDWN, TOLCONV;
   <u>Boolean</u> EVALUATE, EVALUATED, DECOMPOSE, DECOMPOSED, CONV;
   <u>integer</u> I, J, L, K, KNEW, FAILS;
   <u>real</u> H, CH, CHNEW, ERROR, DFI, C;
   <u>array</u> A[0:5], DELTA, LAST DELTA, DF[1:N], JAC[1:N, 1:N], AUX[1:3];
   <u>integer</u> <u>array</u> P[1:N];

   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;

   <u>real</u> <u>procedure</u> NORM2(AI); <u>real</u> AI;
   <u>begin</u> <u>real</u> S, A; S ≔ 1·0&#9192;-100;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> A ≔ AI/YMAX[I]; S ≔ S + A × A <u>end</u>;
      NORM2 ≔ S
   <u>end</u> NORM2;

   <u>procedure</u> RESET;
   <u>begin</u> <u>if</u> CH &lt; HMIN/HOLD <u>then</u> CH ≔ HMIN/HOLD <u>else</u>
      <u>if</u> CH &gt; HMAX/HOLD <u>then</u> CH ≔ HMAX/HOLD;
      X ≔ XOLD; H ≔ HOLD × CH; C ≔ 1;
      <u>for</u> J ≔ 0 <u>step</u> M <u>until</u> K × M <u>do</u>
         <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 Y[J + I] ≔ SAVE[J + I] × C;
            C ≔ C × CH
         <u>end</u>;
      DECOMPOSED ≔ <u>false</u>
   <u>end</u> RESET;

   <u>procedure</u> METHOD;
   <u>begin</u> I ≔ -39;
      <u>if</u> ADAMS <u>then</u>
      <u>begin</u> <u>for</u> C ≔ 1, 1, 144, 4, 0, ·5, 1, ·5, 576, 144, 1, 5/12, 1,·75, 1/6, 1436, 576, 4, ·375, 1, 11/12, 1/3, 1/24,
           2844, 1436, 1, 251/720, 1, 25/24, 35/72,
           5/48, 1/120, 0, 2844, 0·1
           <u>do</u> <u>begin</u> I ≔ I + 1; SAVE[I] ≔ C <u>end</u>
      <u>end</u> <u>else</u>

      <u>begin</u> <u>for</u> C ≔ 1, 1, 9, 4, 0, 2/3, 1, 1/3, 36, 20·25, 1, 6/11,
           1, 6/11, 1/11, 84·028, 53·778, 0·25, ·48, 1, ·7, ·2, ·02,
           156·25, 108·51, ·027778, 120/274, 1, 225/274,
           85/274, 15/274, 1/274, 0, 187·69, ·0047361
           <u>do</u> <u>begin</u> I ≔ I + 1; SAVE[I] ≔ C <u>end</u>
      <u>end</u>
   <u>end</u> METHOD;

   <u>procedure</u> ORDER;
   <u>begin</u> C ≔ EPS × EPS; J ≔ (K-1) × (K + 8)/2 - 38;
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> K <u>do</u> A[I] ≔ SAVE[I + J];
      TOLUP  ≔ C × SAVE[J + K + 1];
      TOL    ≔ C × SAVE[J + K + 2];
      TOLDWN ≔ C × SAVE[J + K + 3];
      TOLCONV ≔ EPS/(2 × N × (K + 2));
      A0 ≔ A[0];  DECOMPOSE ≔ <u>true</u>;
   <u>end</u> ORDER;

   <u>procedure</u> EVALUATE JACOBIAN;
   <u>begin</u> EVALUATE ≔ <u>false</u>;
      DECOMPOSE ≔ EVALUATED ≔ <u>true</u>;
      <u>if</u> AVAILABLE <u>then</u> <u>else</u>
      <u>begin</u> <u>real</u> D; <u>array</u> FIXY, FIXDY, DY[1:N];
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              FIXY[I] ≔ Y[I];
         DERIV(FIXDY);
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> D ≔ <u>if</u> EPS &gt; ABS(FIXY[J])
                 <u>then</u> EPS × EPS
               <u>else</u> EPS × ABS(FIXY[J]);
               Y[J] ≔ Y[J] + D; DERIV(DY);
               <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    JACOBIAN[I, J] ≔ (DY[I]-FIXDY[I])/D;
               Y[J] ≔ FIXY[J]
            <u>end</u>
      <u>end</u>
   <u>end</u> EVALUATE JACOBIAN;

   <u>procedure</u> DECOMPOSE JACOBIAN;
   <u>begin</u> DECOMPOSE ≔ <u>false</u>;
      DECOMPOSED ≔ <u>true</u>; C ≔ -A0 × H;
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 JAC[I, J] ≔ JACOBIAN[I, J] × C;
            JAC[J, J] ≔ JAC[J, J] + 1
         <u>end</u>;
      AUX[2] ≔ 1·0&#9192;-12;
      DEC(JAC, N, AUX, P)
   <u>end</u> DECOMPOSE JACOBIAN;

   <u>procedure</u> CALCULATE STEP AND ORDER;
   <u>begin</u> <u>real</u> A1, A2, A3;
      A1 ≔ <u>if</u> K &LessSlantEqual; 1 <u>then</u> 0 <u>else</u>
        0·75 × (TOLDWN/NORM2(Y[K × M + I])) ⭡ (0·5/K);
      A2 ≔ 0·80 × (TOL/ERROR) ⭡ (0·5/(K + 1));
      A3 ≔ <u>if</u> K &GreaterSlantEqual; 5 ∨ FAILS ≠ 0
        <u>then</u> 0 <u>else</u>
        0·70 × (TOLUP/NORM2(DELTA[I] - LAST DELTA[I])) ⭡
        (0·5/(K + 2));

      <u>if</u> A1 &gt; A2 ∧ A1 &gt; A3 <u>then</u>
      <u>begin</u> KNEW ≔ K-1; CHNEW ≔ A1 <u>end</u> <u>else</u>
      <u>if</u> A2 &gt; A3 <u>then</u>
      <u>begin</u> KNEW ≔ K  ; CHNEW ≔ A2 <u>end</u> <u>else</u>
      <u>begin</u> KNEW ≔ K + 1; CHNEW ≔ A3 <u>end</u>
   <u>end</u> CALCULATE STEP AND ORDER;

   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; M ≔ N;
      <u>for</u> I ≔ -1, -2, -3 <u>do</u> SAVE[I] ≔ 0;
      OUT(0, 0);
      ADAMS ≔ ¬STIFF; WITH JACOBIAN ≔ ¬ADAMS;
      <u>if</u> WITH JACOBIAN <u>then</u> EVALUATE JACOBIAN;
      METHOD;
      NEW START: K ≔ 1; SAME ≔ 2; ORDER; DERIV(DF);
      H ≔ <u>if</u> ¬WITH JACOBIAN <u>then</u> HMIN <u>else</u>
        SQRT(2 × EPS/SQRT(NORM2 (MATVEC(1, N, I, JACOBIAN, DF))));
      <u>if</u> H &gt; HMAX <u>then</u> H ≔ HMAX <u>else</u>
      <u>if</u> H &lt; HMIN <u>then</u> H ≔ HMIN;
      XOLD ≔ X; HOLD ≔ H; KOLD ≔ K; CH ≔ 1;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> SAVE[I] ≔ Y[I]; SAVE[M + I] ≔ Y[M + I] ≔ DF[I] × H
         <u>end</u>;
      OUT(0, 0)
   <u>end</u> <u>else</u>
   <u>begin</u> WITH JACOBIAN ≔ ¬ADAMS; CH ≔ 1;
      K ≔ KOLD; RESET; ORDER;
      DECOMPOSE ≔ WITH JACOBIAN
   <u>end</u>;
   FAILS ≔ 0;
   <u>for</u> L ≔ 0 <u>while</u> X &lt; XEND <u>do</u>
      <u>begin</u> <u>if</u> X + H &LessSlantEqual; XEND <u>then</u> X ≔ X + H <u>else</u>
         <u>begin</u> H ≔ XEND-X; X ≔ XEND; CH ≔ H/HOLD; C ≔ 1;
            <u>for</u> J ≔ M <u>step</u> M <u>until</u> K × M <u>do</u>
               <u>begin</u> C ≔ C × CH;
                  <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> J + N <u>do</u>
                       Y[I] ≔ Y[I] × C
               <u>end</u>;
            SAME ≔ <u>if</u> SAME &lt; 3 <u>then</u> 3 <u>else</u> SAME + 1;
         <u>end</u>;

         <u>comment</u> PREDICTION;
         <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>for</u> I ≔ L <u>step</u> M <u>until</u> (K-1) × M + L <u>do</u>
                    <u>for</u> J ≔ (K-1) × M + L <u>step</u> -M <u>until</u> I <u>do</u>
                       Y[J] ≔ Y[J] + Y[J + M];
               DELTA[L] ≔ 0
            <u>end</u>;  EVALUATED ≔ <u>false</u>;

         <u>comment</u> CORRECTION AND ESTIMATION LOCAL ERROR;
         <u>for</u> L ≔ 1, 2, 3 <u>do</u>
            <u>begin</u> DERIV(DF);
               <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    DF[I] ≔ DF[I] × H - Y[M + I];
               <u>if</u> WITH JACOBIAN <u>then</u>
               <u>begin</u> <u>if</u> EVALUATE <u>then</u> EVALUATE JACOBIAN;
                  <u>if</u> DECOMPOSE <u>then</u> DECOMPOSE JACOBIAN;
                  SOL(JAC, N, P, DF)
               <u>end</u>;

               CONV ≔ <u>true</u>;
               <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                  <u>begin</u> DFI ≔ DF[I];
                     Y[  I] ≔ Y[  I] + A0 × DFI;
                     Y[M + I] ≔ Y[M + I] +      DFI;
                     DELTA[I] ≔ DELTA[I] +  DFI;
                     CONV ≔ CONV ∧ ABS(DFI) &lt; TOLCONV × YMAX[I]
                  <u>end</u>;
               <u>if</u> CONV <u>then</u>
               <u>begin</u> ERROR ≔ NORM2(DELTA[I]);
                  <u>goto</u> CONVERGENCE
               <u>end</u>
            <u>end</u>;

         <u>comment</u> ACCEPTANCE OR REJECTION;
         <u>if</u> ¬CONV <u>then</u>
         <u>begin</u> <u>if</u> ¬WITH JACOBIAN <u>then</u>
            <u>begin</u> EVALUATE ≔ WITH JACOBIAN ≔ SAME &GreaterSlantEqual; K∨ H &lt; 1·1 × HMIN;
               <u>if</u> ¬WITH JACOBIAN <u>then</u> CH ≔ CH/4;
            <u>end</u> <u>else</u>
            <u>if</u> ¬DECOMPOSED <u>then</u> DECOMPOSE ≔ <u>true</u> <u>else</u>
            <u>if</u> ¬EVALUATED  <u>then</u> EVALUATE ≔ <u>true</u> <u>else</u>
            <u>if</u> H &gt; 1·1 × HMIN   <u>then</u> CH ≔ CH/4 <u>else</u>
            <u>if</u> ADAMS            <u>then</u> <u>goto</u> TRY CURTISS <u>else</u>
            <u>begin</u> SAVE[-1] ≔ 1; <u>goto</u> RETURN <u>end</u>;

            RESET
         <u>end</u> <u>else</u> CONVERGENCE:

         <u>if</u> ERROR &gt; TOL <u>then</u>
         <u>begin</u> FAILS ≔ FAILS + 1;
            <u>if</u> H &gt; 1·1 × HMIN <u>then</u>
            <u>begin</u> <u>if</u> FAILS &gt; 2 <u>then</u>
               <u>begin</u> <u>if</u> ADAMS <u>then</u>
                  <u>begin</u> ADAMS ≔ <u>false</u>; METHOD <u>end</u>;
                  KOLD ≔ 0; RESET; <u>goto</u> NEW START
               <u>end</u> <u>else</u>
               <u>begin</u> CALCULATE STEP AND ORDER;
                  <u>if</u> KNEW ≠ K <u>then</u>
                  <u>begin</u> K ≔ KNEW; ORDER <u>end</u>;
                  CH ≔ CH × CHNEW; RESET
               <u>end</u>
            <u>end</u> <u>else</u>
            <u>begin</u> <u>if</u> ADAMS <u>then</u> TRY CURTISS:
               <u>begin</u> ADAMS ≔ <u>false</u>; METHOD
               <u>end</u> <u>else</u>
               <u>if</u> K = 1 <u>then</u>
               <u>begin</u> <u>comment</u> VIOLATE EPS CRITERION;
                  C ≔ EPS × SQRT(ERROR/TOL);
                  <u>if</u> C &gt; SAVE[-3] <u>then</u> SAVE[-3] ≔ C;
                  SAVE[-2] ≔ SAVE[-2] + 1;
                  SAME ≔ 4; <u>goto</u> ERROR TEST OK
               <u>end</u>;
               K ≔ KOLD ≔ 1; RESET; ORDER; SAME ≔ 2
            <u>end</u>
         <u>end</u> <u>else</u> ERROR TEST OK:
         <u>begin</u>
            FAILS ≔ 0;
            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> C ≔ DELTA[I];
                  <u>for</u> L ≔ 2 <u>step</u> 1 <u>until</u> K <u>do</u>
                       Y[L × M + I] ≔ Y[L × M + I] + A[L] × C;
                  <u>if</u> ABS(Y[I]) &gt; YMAX[I] <u>then</u>
                    YMAX[I] ≔  ABS(Y[I])
               <u>end</u>;

            SAME ≔ SAME-1;
            <u>if</u> SAME = 1 <u>then</u>
            <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    LAST DELTA[I] ≔ DELTA[I]
            <u>end</u> <u>else</u>
            <u>if</u> SAME = 0 <u>then</u>
            <u>begin</u> CALCULATE STEP AND ORDER;
               <u>if</u> CHNEW &gt; 1·1 <u>then</u>
               <u>begin</u> DECOMPOSED ≔ <u>false</u>;
                  <u>if</u> K ≠ KNEW <u>then</u>
                  <u>begin</u> <u>if</u> KNEW &gt; K <u>then</u>
                     <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1
                          <u>until</u> N <u>do</u> Y[KNEW × M + I]
                             ≔ DELTA[I] × A[K]/KNEW
                     <u>end</u>;
                     K ≔ KNEW; ORDER
                  <u>end</u>;
                  SAME ≔ K + 1;
                  <u>if</u> CHNEW × H &gt; HMAX
                    <u>then</u> CHNEW ≔ HMAX/H;
                  H ≔ H × CHNEW; C ≔ 1;
                  <u>for</u> J ≔ M <u>step</u> M <u>until</u> K × M <u>do</u>
                     <u>begin</u> C ≔ C × CHNEW;
                        <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u>
                          J + N <u>do</u> Y[I] ≔ Y[I] × C
                     <u>end</u>
               <u>end</u>
               <u>else</u> SAME ≔ 10
            <u>end</u>;
            <u>if</u> X ≠ XEND <u>then</u>
            <u>begin</u> XOLD ≔ X; HOLD ≔ H; KOLD ≔ K; CH ≔ 1;
               <u>for</u> I ≔ K × M + N <u>step</u> -1 <u>until</u> 1 <u>do</u>
                    SAVE[I] ≔ Y[I];
               OUT(H, K)
            <u>end</u>
         <u>end</u> CORRECTION AND ESTIMATION LOCAL ERROR;
      <u>end</u> STEP;

   RETURN: SAVE[0] ≔ <u>if</u> ADAMS <u>then</u> 0 <u>else</u> 1;
   MULTISTEP ≔ SAVE[-1] = 0 ∧ SAVE[-2] = 0
<u>end</u> MULTISTEP;
<u>comment</u> ================== 33180 ================= ;
<u>procedure</u> DIFFSYS(X, XE, N, Y, DERIVATIVE, AETA, RETA, S, H0, OUTPUT);
   <u>value</u> N;
   <u>integer</u> N;
     <u>real</u> X, XE, AETA, RETA, H0;
     <u>array</u> Y, S;
     <u>procedure</u> DERIVATIVE, OUTPUT;
<u>begin</u> <u>real</u> A, B, B1, C, G, H, U, V, TA, FC; <u>integer</u> I, J, K, KK, JJ, L, M, R, SR;
   <u>array</u> YA, YL, YM, DY, DZ[1:N], DT[1:N, 0:6], D[0:6], YG, YH[0:7, 1:N];
   <u>Boolean</u> KONV, B0, BH, LAST;
   LAST ≔ <u>false</u>; H ≔ H0;
   NEXT: <u>if</u> H × 1·1 &GreaterSlantEqual; XE-X <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; H0 ≔ H; H ≔ XE-X + &#9192;-13 <u>end</u>;
   DERIVATIVE(X, Y, DZ); BH ≔ <u>false</u>;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> YA[I] ≔ Y[I];
   ANF: A ≔ H + X; FC ≔ 1·5; B0 ≔ <u>false</u>; M ≔ 1; R ≔ 2; SR ≔ 3; JJ ≔ -1;
   <u>for</u> J ≔ 0 <u>step</u> 1 <u>until</u> 9 <u>do</u>
      <u>begin</u> <u>if</u> B0 <u>then</u>
         <u>begin</u> D[1] ≔ 16/9; D[3] ≔ 64/9; D[5] ≔ 256/9 <u>end</u>
         <u>else</u> <u>begin</u> D[1] ≔ 9/4; D[3] ≔ 9; D[5] ≔ 36 <u>end</u>;
         KONV ≔ <u>true</u>;
         <u>if</u> J &gt; 6 <u>then</u> <u>begin</u> L ≔ 6; D[6] ≔ 64; FC ≔ ·6 × FC <u>end</u>
         <u>else</u> <u>begin</u> L ≔ J; D[L] ≔ M × M <u>end</u>;
         M ≔ M × 2; G ≔ H/M; B ≔ G × 2;
         <u>if</u> BH ∧ J &lt; 8 <u>then</u>
         <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> YM[I] ≔ YH[J, I]; YL[I] ≔ YG[J, I] <u>end</u>
         <u>end</u>
         <u>else</u>
         <u>begin</u>
            KK ≔ (M-2)/2; M ≔ M-1;
            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> YL[I] ≔ YA[I]; YM[I] ≔ YA[I] + G × DZ[I] <u>end</u>;
            <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
               <u>begin</u> DERIVATIVE(X + K × G, YM, DY);
                  <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                     <u>begin</u> U ≔ YL[I] + B × DY[I]; YL[I] ≔ YM[I]; YM[I] ≔ U;
                        U ≔ ABS(U); <u>if</u> U &gt; S[I] <u>then</u> S[I] ≔ U
                     <u>end</u>;
                  <u>if</u> K = KK ∧ K ≠ 2 <u>then</u>
                  <u>begin</u> JJ ≔ JJ + 1; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                        <u>begin</u> YH[JJ, I] ≔ YM[I]; YG[JJ, I] ≔ YL[I] <u>end</u>
                  <u>end</u>
               <u>end</u>
         <u>end</u>;
         DERIVATIVE(A, YM, DY);
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> V ≔ DT[I, 0]; TA ≔ C ≔ DT[I, 0] ≔ (YM[I] + YL[I] + G × DY[I])/2;
               <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> L <u>do</u>
                  <u>begin</u> B1 ≔ D[K] × V; B ≔ B1-C; U ≔ V;
                     <u>if</u> B ≠ 0 <u>then</u>
                     <u>begin</u> B ≔ (C-V)/B; U ≔ C × B; C ≔ B1 × B <u>end</u>;
                     V ≔ DT[I, K]; DT[I, K] ≔ U; TA ≔ U + TA
                  <u>end</u>;
               <u>if</u> ABS(Y[I]-TA) &gt; RETA × S[I] + AETA <u>then</u> KONV ≔ <u>false</u>;
               Y[I] ≔ TA
            <u>end</u>;
         <u>if</u> KONV <u>then</u> <u>goto</u> END;
         D[2] ≔ 4; D[4] ≔ 16; B0 ≔ ¬B0; M ≔ R; R ≔ SR; SR ≔ M × 2
      <u>end</u>;
   BH ≔ ¬BH; LAST ≔ <u>false</u>; H ≔ H/2; <u>goto</u> ANF;
   END: H ≔ FC × H; X ≔ A; OUTPUT; <u>if</u> ¬LAST <u>then</u> <u>goto</u> NEXT;
<u>end</u> DIFFSYS;
<u>comment</u> ================== 33061 ================= ;
<u>procedure</u> ARK (T, TE, M0, M, U, DERIVATIVE, DATA, OUT);
   <u>integer</u> M0, M;
     <u>real</u> T, TE;
     <u>array</u> U, DATA;
     <u>procedure</u> DERIVATIVE, OUT;

<u>begin</u> <u>integer</u> P, N, Q;
   <u>own</u> <u>real</u> EC0, EC1, EC2, TAU0, TAU1, TAU2, TAUS, T2;
   <u>real</u> THETANM1, TAU, BETAN, QINV, ETA;
   <u>array</u> MU, LAMBDA[1:DATA[1]], THETHA[0:DATA[1]], RO, R[M0:M];
   <u>Boolean</u> START, STEP1, LAST;

   <u>procedure</u> INIVEC(L, U, A, X);               <u>code</u> 31010;
   <u>procedure</u> MULVEC(L, U, SHIFT, A, B, X);     <u>code</u> 31020;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B);        <u>code</u> 31030;
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X);     <u>code</u> 34020;
   <u>procedure</u> DECSOL(A, N, AUX, B);             <u>code</u> 34301;

   <u>procedure</u> INITIALIZE;
   <u>begin</u> <u>integer</u> I, J, K, L, N1; <u>real</u> S, THETA0;
      <u>array</u> ALFA[1:8, 1:DATA[1] + 1], TH[1:8], AUX[1:3];

      <u>real</u> <u>procedure</u> LABDA(I, J); <u>value</u> I, J; <u>integer</u> I, J;
         LABDA ≔ <u>if</u> P &lt; 3 <u>then</u> (<u>if</u> J = I-1 <u>then</u> MUI(I) <u>else</u> 0)
         <u>else</u> <u>if</u> P = 3 <u>then</u> (<u>if</u> I = N <u>then</u> (<u>if</u> J = 0
           <u>then</u> ·25 <u>else</u> <u>if</u> J = N - 1 <u>then</u> ·75
         <u>else</u> 0) <u>else</u> <u>if</u> J = 0 <u>then</u> (<u>if</u> I = 1
           <u>then</u> MUI(1) <u>else</u> ·25) <u>else</u> <u>if</u> J = I - 1
           <u>then</u> LAMBDA[I] <u>else</u> 0) <u>else</u> 0;

      <u>real</u> <u>procedure</u> MUI(I); <u>value</u> I; <u>integer</u> I;
         MUI ≔ <u>if</u> I = N <u>then</u> 1 <u>else</u>
           <u>if</u> I &lt; 1 ∨ I &gt; N <u>then</u> 0 <u>else</u>
           <u>if</u> P &lt; 3 <u>then</u> LAMBDA[I] <u>else</u>
           <u>if</u> P = 3 <u>then</u> LAMBDA[I] + ·25 <u>else</u> 0;

      <u>real</u> <u>procedure</u> SUM(I, A, B, X);
         <u>value</u> B; <u>integer</u> I, A, B; <u>real</u> X;
      <u>begin</u> <u>real</u> S; S ≔ 0;
         <u>for</u> I ≔ A <u>step</u> 1 <u>until</u> B <u>do</u> S ≔ S + X;
         SUM ≔ S
      <u>end</u> SUM;
      N ≔ DATA[1]; P ≔ DATA[2]; EC1 ≔ EC2 ≔ 0;
      BETAN ≔ DATA[3];
      THETANM1 ≔ <u>if</u> P = 3 <u>then</u> ·75 <u>else</u> 1;
      THETA0 ≔ 1 - THETANM1; S ≔ 1;
      <u>for</u> J ≔ N - 1 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
         <u>begin</u> S ≔ - S × THETA0 + DATA[N + 10 - J];
            MU[J] ≔ DATA[N + 11 - J] / S;
            LAMBDA[J] ≔ MU[J] - THETA0
         <u>end</u>;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> 8 <u>do</u>
           <u>for</u> J ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
              ALFA[I, J + 1] ≔ <u>if</u> I = 1 <u>then</u> 1 <u>else</u>
              <u>if</u> J = 0 <u>then</u> 0 <u>else</u> <u>if</u> I = 2 ∨ I = 4 ∨ I = 8 <u>then</u>
              MUI(J) ⭡ ENTIER((I + 2) / 3) <u>else</u>
              <u>if</u> (I = 3 ∨ I = 6) ∧ J &gt; 1 <u>then</u> SUM(L, 1, J-1,
              LABDA(J, L) × MUI(L) ⭡ ENTIER(I / 3)) <u>else</u>
              <u>if</u> I = 5 ∧ J &gt; 2 <u>then</u> SUM(L, 2, J - 1, LABDA(J, L) ×
              SUM(K, 1, L - 1, LABDA(L, K) × MUI(K))) <u>else</u>
              <u>if</u> I = 7 ∧ J &gt; 1 <u>then</u> SUM(L, 1, J - 1, LABDA(J, L) ×
              MUI(L)) × MUI(J) <u>else</u> 0;
      N1 ≔ <u>if</u> N &lt; 4 <u>then</u> N + 1 <u>else</u> <u>if</u> N &lt; 7 <u>then</u> 4
      <u>else</u> 8;
      I ≔ 1;
      <u>for</u> S ≔ 1, ·5, 1 / 6, 1 / 3, 1 / 24, 1 / 12, ·125, ·25 <u>do</u>
         <u>begin</u> TH[I] ≔ S; I ≔ I + 1 <u>end</u>;
      <u>if</u> P = 3 ∧ N &lt; 7 <u>then</u> TH[1] ≔ TH[2] ≔ 0;
      AUX[2] ≔ &#9192;-14; DECSOL(ALFA, N1, AUX, TH);
      INIVEC(0, N, THETHA, 0);
      DUPVEC(0, N1 - 1, 1, THETHA, TH);
      <u>if</u> ¬(P = 3 ∧ N &lt; 7) <u>then</u>
      <u>begin</u> THETHA[0] ≔ THETHA[0] - THETA0;
         THETHA[N - 1] ≔ THETHA[N - 1] - THETANM1; Q ≔ P + 1
      <u>end</u> <u>else</u> Q ≔ 3;
      QINV ≔ 1 / Q;
      START ≔ DATA[8] = 0; DATA[10] ≔ 0; LAST ≔ <u>false</u>;
      DUPVEC(M0, M, 0, R, U); DERIVATIVE(T, R)
   <u>end</u> INITIALIZE;
   <u>procedure</u> LOCAL ERROR CONSTRUCTION(I); <u>value</u> I; <u>integer</u> I;
   <u>begin</u> <u>if</u> THETHA[I] ≠ 0 <u>then</u>
        ELMVEC(M0, M, 0, RO, R, THETHA[I]);
      <u>if</u> I = N <u>then</u>
      <u>begin</u> DATA[9] ≔ SQRT(VECVEC(M0, M, 0, RO, RO)) × TAU;
         EC0 ≔ EC1; EC1 ≔ EC2; EC2 ≔ DATA[9] / TAU ⭡ Q
      <u>end</u>
   <u>end</u> LEC;

   <u>procedure</u> STEPSIZE;
   <u>begin</u> <u>real</u> TAUACC, TAUSTAB, AA, BB, CC, EC;
      ETA ≔ SQRT(VECVEC(M0, M, 0, U, U)) × DATA[7] + DATA[6];
      <u>if</u> ETA &gt; 0 <u>then</u>
      <u>begin</u> <u>if</u> START <u>then</u>
         <u>begin</u> <u>if</u> DATA[8] = 0 <u>then</u>
            <u>begin</u> TAUACC ≔ DATA[5];
               STEP1 ≔ <u>true</u>
            <u>end</u> <u>else</u> <u>if</u> STEP1 <u>then</u>
            <u>begin</u> TAUACC ≔ (ETA / EC2) ⭡ QINV;
               <u>if</u> TAUACC &gt; 10 × TAU2 <u>then</u>
                 TAUACC ≔ 10 × TAU2 <u>else</u> STEP1 ≔ <u>false</u>
            <u>end</u> <u>else</u>
            <u>begin</u> BB ≔ (EC2 - EC1) / TAU1; CC ≔ - BB × T2 + EC2;
               EC ≔ BB × T + CC;
               TAUACC ≔ <u>if</u> EC &lt; 0 <u>then</u> TAU2 <u>else</u>
                 (ETA / EC) ⭡ QINV;
               START ≔ <u>false</u>
            <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> AA ≔ ((EC0 - EC1) / TAU0 + (EC2 - EC1) / TAU1)
              / (TAU1 + TAU0);
            BB ≔ (EC2 - EC1) / TAU1 - (2 × T2 - TAU1) × AA;
            CC ≔ - (AA × T2 + BB) × T2 + EC2;
            EC ≔ (AA × T + BB) × T + CC;
            TAUACC ≔ <u>if</u> EC &lt; 0 <u>then</u>
              TAUS <u>else</u> (ETA / EC) ⭡ QINV;
            <u>if</u> TAUACC &gt; 2 × TAUS <u>then</u> TAUACC ≔ 2 × TAUS;
            <u>if</u> TAUACC &lt; TAUS / 2 <u>then</u> TAUACC ≔ TAUS / 2
         <u>end</u>
      <u>end</u> <u>else</u> TAUACC ≔ DATA[5];
      <u>if</u> TAUACC &lt; DATA[5] <u>then</u> TAUACC ≔ DATA[5];
      TAUSTAB ≔ BETAN / DATA[4]; <u>if</u> TAUSTAB &lt; DATA[5] <u>then</u>
      <u>begin</u> DATA[10] ≔ 1; <u>goto</u> ENDARK <u>end</u>;
      TAU ≔ <u>if</u> TAUACC &gt; TAUSTAB <u>then</u> TAUSTAB <u>else</u> TAUACC;
      TAUS ≔ TAU; <u>if</u> TAU &GreaterSlantEqual; TE - T <u>then</u>
      <u>begin</u> TAU ≔ TE - T; LAST ≔ <u>true</u> <u>end</u>;
      TAU0 ≔ TAU1; TAU1 ≔ TAU2; TAU2 ≔ TAU
   <u>end</u> STEPSIZE;
   <u>procedure</u> DIFFERENCE SCHEME;
   <u>begin</u> <u>integer</u> I, J;
      <u>real</u> MT, LT;
      MULVEC(M0, M, 0, RO, R, THETHA[0]);
      <u>if</u> P = 3 <u>then</u> ELMVEC(M0, M, 0, U, R, ·25 × TAU);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
         <u>begin</u> MT ≔ MU[I] × TAU; LT ≔ LAMBDA[I] × TAU;
            <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u>
                 R[J] ≔ LT × R[J] + U[J];
            DERIVATIVE(T + MT, R); LOCAL ERROR CONSTRUCTION(I)
         <u>end</u>;
      ELMVEC(M0, M, 0, U, R, THETANM1 × TAU);
      DUPVEC(M0, M, 0, R, U); DERIVATIVE(T + TAU, R);
      LOCAL ERROR CONSTRUCTION(N); T2 ≔ T;
      <u>if</u> LAST <u>then</u>
      <u>begin</u> LAST ≔ <u>false</u>; T ≔ TE <u>end</u> <u>else</u> T ≔ T + TAU;
      DATA[8] ≔ DATA[8] + 1
   <u>end</u> DIFSCH;

   INITIALIZE;

   NEXT STEP:
   STEPSIZE; DIFFERENCE SCHEME; OUT;
   <u>if</u> T ≠ TE <u>then</u> <u>goto</u> NEXT STEP;

   ENDARK:
<u>end</u> ARK;
<u>comment</u> ================== 33070 ================= ;
<u>procedure</u> EFRK(T, TE, M0, M, U, SIGMA, PHI, DIAMETER, DERIVATIVE, K, STEP, R, L,
  BETA, THIRDORDER, TOL, OUTPUT);
   <u>value</u> R, L;
   <u>integer</u> M0, M, K, R, L;
     <u>real</u> T, TE, SIGMA, PHI, DIAMETER, STEP, TOL;
     <u>array</u> U, BETA;
     <u>Boolean</u> THIRDORDER;
     <u>procedure</u> DERIVATIVE, OUTPUT;
<u>begin</u> <u>integer</u> N;
   <u>real</u> THETA0, THETANM1, H, B, B0, PHI0, PHIL, PI, COSPHI, SINPHI, EPS, BETAR;
   <u>Boolean</u> FIRST, LAST, COMPLEX, CHANGE;
   <u>integer</u> <u>array</u> P[1:L];
   <u>real</u> <u>array</u> MU, LABDA[0:R + L-1], PT[0:R], FAC, BETAC[0:L-1], RL[M0:M],
     A[1:L, 1:L], AUX[0:3];
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;

   <u>procedure</u> FORM CONSTANTS;
   <u>begin</u> <u>integer</u> I;
      FIRST ≔ <u>false</u>;
      FAC[0] ≔ 1;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L-1 <u>do</u> FAC[I] ≔ I × FAC[I-1];
      PT[R] ≔ L × FAC[L-1];
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> R <u>do</u>
           PT[R-I] ≔ PT[R-I + 1] × (L + I)/I
   <u>end</u> FORM CONSTANTS;

   <u>procedure</u> FORM BETA;
   <u>begin</u> <u>integer</u> I, J; <u>real</u> BB, C, D;
      <u>if</u> FIRST <u>then</u> FORM CONSTANTS;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> C ≔ 1-EXP(-B);
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> R <u>do</u> C ≔ BETA[J]-C/B;
         BETA[R + 1] ≔ C/B
      <u>end</u> <u>else</u>
      <u>if</u> B &gt; 40 <u>then</u>
      <u>begin</u> <u>for</u> I ≔ R + 1 <u>step</u> 1 <u>until</u> R + L <u>do</u>
            <u>begin</u> C ≔ 0;
               <u>for</u> J ≔ 0 <u>step</u> 1 <u>until</u> R <u>do</u>
                    C ≔ BETA[J] × PT[J]/(I-J)-C/B;
               BETA[I] ≔ C/B/FAC[L + R-I]/FAC[I-R-1]
            <u>end</u>;
      <u>end</u> <u>else</u>
      <u>begin</u> D ≔ C ≔ EXP(-B); BETAC[L-1] ≔ D/FAC[L-1];
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L-1 <u>do</u>
            <u>begin</u> C ≔ B × C/I; D ≔ D + C; BETAC[L-1-I] ≔ D/FAC[L-1-I] <u>end</u>;
         BB ≔ 1;
         <u>for</u> I ≔ R + 1 <u>step</u> 1 <u>until</u> R + L <u>do</u>
            <u>begin</u> C ≔ 0;
               <u>for</u> J ≔ 0 <u>step</u> 1 <u>until</u> R <u>do</u>
                    C ≔ (BETA[J]-(<u>if</u> J &lt; L <u>then</u> BETAC[J] <u>else</u> 0)) ×
                    PT[J]/(I-J)-C/B;
               BETA[I] ≔ C/B/FAC[L + R-I]/FAC[I-R-1] +
                 (<u>if</u> I &lt; L <u>then</u> BB × BETAC[I] <u>else</u> 0);
               BB ≔ BB × B
            <u>end</u>
      <u>end</u>
   <u>end</u> FORM BETA;

   <u>procedure</u> SOLUTION OF COMPLEX EQUATIONS;
   <u>begin</u> <u>integer</u> I, J, C1, C3;
      <u>real</u> C2, E, B1, ZI, COSIPHI, SINIPHI, COSPHIL;
      <u>real</u> <u>array</u> D[1:L];

      <u>procedure</u> ELEMENTS OF MATRIX;
      <u>begin</u> PHIL ≔ PHI0;
         COSPHI ≔ COS(PHIL); SINPHI ≔ SIN(PHIL);
         COSIPHI ≔ 1; SINIPHI ≔ 0;
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> L-1 <u>do</u>
            <u>begin</u> C1 ≔ R + 1 + I; C2 ≔ 1;
               <u>for</u> J ≔ L-1 <u>step</u> -2 <u>until</u> 1 <u>do</u>
                  <u>begin</u> A[J, L-I] ≔ C2 × COSIPHI;
                     A[J + 1, L-I] ≔ C2 × SINIPHI;
                     C2 ≔ C1 × C2; C1 ≔ C1-1
                  <u>end</u>;
               COSPHIL ≔ COSIPHI × COSPHI-SINIPHI × SINPHI;
               SINIPHI ≔ COSIPHI × SINPHI + SINIPHI × COSPHI;
               COSIPHI ≔ COSPHIL
            <u>end</u>;
         AUX[2] ≔ 0; DEC(A, L, AUX, P)
      <u>end</u> EL OF MAT;

      <u>procedure</u> RIGHTHANDSIDE;
      <u>begin</u> E ≔ EXP(B × COSPHI);
         B1 ≔ B × SINPHI-(R + 1) × PHIL;
         COSIPHI ≔ E × COS(B1); SINIPHI ≔ E × SIN(B1);
         B1 ≔ 1/B; ZI ≔ B1⭡R;
         <u>for</u> J ≔ L <u>step</u> -2 <u>until</u> 2 <u>do</u>
            <u>begin</u> D[J] ≔ ZI × SINIPHI;
               D[J-1] ≔ ZI × COSIPHI;
               COSPHIL ≔ COSIPHI × COSPHI-SINIPHI × SINPHI;
               SINIPHI ≔ COSIPHI × SINPHI + SINIPHI × COSPHI;
               COSIPHI ≔ COSPHIL;
               ZI ≔ ZI × B
            <u>end</u>;
         COSIPHI ≔ ZI ≔ 1; SINIPHI ≔ 0;
         <u>for</u> I ≔ R <u>step</u> -1 <u>until</u> 0 <u>do</u>
            <u>begin</u> C1 ≔ I; C2 ≔ BETA[I];
               C3 ≔ <u>if</u> 2 × I &gt; L-2 <u>then</u> 2 <u>else</u> L-2 × I;
               COSPHIL ≔ COSIPHI × COSPHI-SINIPHI × SINPHI;
               SINIPHI ≔ COSIPHI × SINPHI + SINIPHI × COSPHI;
               COSIPHI ≔ COSPHIL;
               <u>for</u> J ≔ L <u>step</u> -2 <u>until</u> C3 <u>do</u>
                  <u>begin</u> D[J] ≔ D[J] + ZI × C2 × SINIPHI;
                     D[J-1] ≔ D[J-1]-ZI × C2 × COSIPHI;
                     C2 ≔ C2 × C1; C1 ≔ C1-1
                  <u>end</u>;
               ZI ≔ ZI × B1
            <u>end</u>
      <u>end</u> RIGHT HAND SIDE;

      <u>if</u> PHI0 ≠ PHIL <u>then</u> ELEMENTS OF MATRIX;
      RIGHTHANDSIDE;
      SOL(A, L, P, D);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L <u>do</u> BETA[R + I] ≔ D[L + 1-I] × B1
   <u>end</u> SOLOFCOMEQ;

   <u>procedure</u> COEFFICIENT;
   <u>begin</u> <u>integer</u> J, K; <u>real</u> C;
      B0 ≔ B; PHI0 ≔ PHI;
      <u>if</u> B &GreaterSlantEqual; 1 <u>then</u>
      <u>begin</u> <u>if</u> COMPLEX <u>then</u> SOLUTION OF COMPLEX EQUATIONS
         <u>else</u> FORM BETA
      <u>end</u>;
      LABDA[0] ≔ MU[0] ≔ 0;
      <u>if</u> THIRDORDER <u>then</u>
      <u>begin</u> THETA0 ≔ ·25; THETANM1 ≔ ·75;
         <u>if</u> B &lt; 1 <u>then</u>
         <u>begin</u> C ≔ MU[N-1] ≔ 2/3; LABDA[N-1] ≔ 5/12;
            <u>for</u> J ≔ N-2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
               <u>begin</u> C ≔ MU[J] ≔ C/(C-·25)/(N-J + 1);
                  LABDA[J] ≔ C-·25
               <u>end</u>
         <u>end</u> <u>else</u>
         <u>begin</u> C ≔ MU[N-1] ≔ BETA[2] × 4/3; LABDA[N-1] ≔ C-·25;
            <u>for</u> J ≔ N-2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
               <u>begin</u> C ≔ MU[J] ≔ C/(C-·25) × BETA[N-J + 1]/BETA[N-J]/
                    (<u>if</u> J &lt; L <u>then</u> B <u>else</u> 1);
                  LABDA[J] ≔ C-·25
               <u>end</u>
         <u>end</u>
      <u>end</u> <u>else</u>
      <u>begin</u> THETA0 ≔ 0; THETANM1 ≔ 1;
         <u>if</u> B &lt; 1 <u>then</u>
         <u>begin</u> <u>for</u> J ≔ N-1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
                 MU[J] ≔ LABDA[J] ≔ 1/(N-J + 1)
         <u>end</u> <u>else</u>
         <u>begin</u> LABDA[N-1] ≔ MU[N-1] ≔ BETA[2];
            <u>for</u> J ≔ N-2 <u>step</u> -1 <u>until</u> 1 <u>do</u>
                 MU[J] ≔ LABDA[J] ≔ BETA[N-J + 1]/BETA[N-J]/
                 (<u>if</u> J &lt; L <u>then</u> B <u>else</u> 1)
         <u>end</u>
      <u>end</u>
   <u>end</u> COEFFICIENT;

   <u>procedure</u> STEPSIZE;
   <u>begin</u> <u>real</u> D, HSTAB, HSTABINT;
      H ≔ STEP;
      D ≔ ABS(SIGMA × SIN(PHI));
      COMPLEX ≔ L÷2 × 2 = L ∧ 2 × D &gt; DIAMETER;
      <u>if</u> DIAMETER &gt; 0 <u>then</u>
        HSTAB ≔ (SIGMA⭡2/(DIAMETER × (DIAMETER × ·25 + D)))⭡(L × ·5/R)/
        BETAR/SIGMA
      <u>else</u> HSTAB ≔ H;
      D ≔ <u>if</u> THIRDORDER <u>then</u> (2 × TOL/EPS/BETA[R])⭡(1/(N-1)) ×
        4⭡((L-1)/(N-1)) <u>else</u> (TOL/EPS)⭡(1/R)/BETAR;
      HSTABINT ≔ ABS(D/SIGMA);
      <u>if</u> H &gt; HSTAB <u>then</u> H ≔ HSTAB;
      <u>if</u> H &gt; HSTABINT <u>then</u> H ≔ HSTABINT;
      <u>if</u> T + H &gt; TE × (1-K × EPS) <u>then</u>
      <u>begin</u> LAST ≔ <u>true</u>; H ≔ TE-T <u>end</u>;
      B ≔ H × SIGMA; D ≔ DIAMETER × ·1 × H; D ≔ D × D;
      <u>if</u> H &lt; T × EPS  <u>then</u> <u>goto</u> ENDOFEFRK;
      CHANGE ≔ B0 = -1 ∨ ((B-B0) × (B-B0) + B × B0 × (PHI-PHI0) × (PHI-PHI0) &gt; D)
   <u>end</u> STEPSIZE;

   <u>procedure</u> DIFFERENCESCHEME ;
   <u>begin</u> <u>integer</u> I, J; <u>real</u> MT, LT, THT;
      I ≔ -1;
      NEXTTERM:
      I ≔ I + 1; MT ≔ MU[I] × H; LT ≔ LABDA[I] × H;
      <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u> RL[J] ≔ U[J] + LT × RL[J];
      DERIVATIVE(T + MT, RL);
      <u>if</u> I = 0 ∨ I = N-1 <u>then</u>
      <u>begin</u> THT ≔ <u>if</u> I = 0 <u>then</u> THETA0 × H <u>else</u> THETANM1 × H;
         ELMVEC(M0, M, 0, U, RL, THT)
      <u>end</u>;
      <u>if</u> I &lt; N-1 <u>then</u> <u>goto</u> NEXTTERM;
      T ≔ T + H
   <u>end</u> DIFFERENCE SCHEME;

   N ≔ R + L; FIRST ≔ <u>true</u>; B0 ≔ -1; BETAR ≔ BETA[R]⭡(1/R);
   LAST ≔ <u>false</u>; EPS ≔ 2⭡(-48); PI ≔ PHI0 ≔ PHIL ≔ 4 × ARCTAN(1);
   NEXTLEVEL:
   STEPSIZE;
   <u>if</u> CHANGE <u>then</u> COEFFICIENT;
   K ≔ K + 1;
   DIFFERENCE SCHEME;
   OUTPUT;
   <u>if</u> ¬LAST <u>then</u> <u>goto</u> NEXTLEVEL;
   ENDOFEFRK:
<u>end</u> EXPONENTIALLY FITTED RUNGE KUTTA;
<u>comment</u> ================== 33160 ================= ;
<u>procedure</u> EFSIRK(X, XE, M, Y, DELTA, DERIVATIVE, JACOBIAN, J,
  N, AETA, RETA, HMIN, HMAX, LINEAR, OUTPUT);
   <u>value</u> M; <u>integer</u> M, N;
     <u>real</u> X, XE, DELTA, AETA, RETA, HMIN, HMAX;
     <u>procedure</u> DERIVATIVE, JACOBIAN, OUTPUT;
     <u>Boolean</u> LINEAR;
     <u>array</u> Y, J;

<u>begin</u> <u>integer</u> K, L;
   <u>real</u> STEP, H, MU0, MU1, MU2, THETA0, THETA1, NU1, NU2,
     NU3, YK, FK, C1, C2, D;
   <u>array</u> F, K0, LABDA[1 : M], J1[1 : M, 1 : M], AUX[1 : 7];
   <u>integer</u> <u>array</u> RI, CI[1 : M];
   <u>Boolean</u> LIN;
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> GSSELM(A, N, AUX, RI, CI); <u>code</u> 34231;
   <u>procedure</u> SOLELM(A, N, RI, CI, B); <u>code</u> 34061;

   <u>real</u> <u>procedure</u> STEPSIZE;
   <u>begin</u> <u>real</u> DISCR, ETA, S;
      <u>if</u> LINEAR <u>then</u> S ≔ H ≔ HMAX <u>else</u>
      <u>if</u> N = 1 ∨ HMIN = HMAX <u>then</u> S ≔ H ≔ HMIN <u>else</u>
      <u>begin</u> ETA ≔ AETA + RETA × SQRT(VECVEC(1, M, 0, Y, Y));
         C1 ≔ NU3 × STEP; <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
              LABDA[K] ≔ LABDA[K] + C1 × F[K] - Y[K];
         DISCR ≔ SQRT(VECVEC(1, M, 0, LABDA, LABDA));
         S ≔ H ≔ (ETA / (0·75 × (ETA + DISCR)) + 0·33) × H;
         <u>if</u> H &lt; HMIN <u>then</u> S ≔ H ≔ HMIN <u>else</u>
         <u>if</u> H &gt; HMAX <u>then</u> S ≔ H ≔ HMAX
      <u>end</u>;
      <u>if</u> X + S &gt; XE <u>then</u> S ≔ XE - X;
      LIN ≔ STEP = S ∧ LINEAR; STEPSIZE ≔ S
   <u>end</u> STEPSIZE;

   <u>procedure</u> COEFFICIENT;
   <u>begin</u> <u>real</u> Z1, E, ALPHA1, A, B;
      <u>own</u> <u>real</u> Z2;
      Z1 ≔ STEP × DELTA; <u>if</u> N = 1 <u>then</u> Z2 ≔ Z1 + Z1;
      <u>if</u> ABS(Z2 - Z1) &gt; &#9192;-6 × ABS(Z1) ∨ Z2 &gt; - 1 <u>then</u>
      <u>begin</u> A ≔ Z1 × Z1 + 12; B ≔ 6 × Z1;
         <u>if</u> ABS(Z1) &lt; 0·1 <u>then</u>
           ALPHA1 ≔ (Z1 × Z1 / 140 - 1) × Z1 / 30 <u>else</u>
         <u>if</u> Z1 &lt; - &#9192;14 <u>then</u> ALPHA1 ≔ 1 / 3 <u>else</u>
         <u>if</u> Z1 &lt; - 33 <u>then</u>
           ALPHA1 ≔ (A + B) / (3 × Z1 × (2 + Z1)) <u>else</u>
         <u>begin</u> E ≔ <u>if</u> Z1 &lt; 230 <u>then</u> EXP(Z1) <u>else</u> &#9192;100;
            ALPHA1 ≔ ((A - B) × E - A - B) /
              (((2 - Z1) × E - 2 - Z1) × 3 × Z1)
         <u>end</u>;
         MU2 ≔ (1 / 3 + ALPHA1) × 0·25;
         MU1 ≔ - (1 + ALPHA1) × 0·5;
         MU0 ≔ (6 × MU1 + 2) / 9; THETA0 ≔ 0·25;
         THETA1 ≔ 0·75; A ≔ 3 × ALPHA1;
         NU3 ≔ (1 + A) / (5 - A) × 0·5; A ≔ NU3 + NU3;
         NU1 ≔ 0·5 - A; NU2 ≔ (1 + A) × 0·75;
         Z2 ≔ Z1
      <u>end</u>
   <u>end</u> COEFFICIENT;

   <u>procedure</u> DIFFERENCE SCHEME;
   <u>begin</u> DERIVATIVE(F); STEP ≔ STEPSIZE;
      <u>if</u> ¬LINEAR ∨ N = 1 <u>then</u> JACOBIAN(J, Y);
      <u>if</u> ¬LIN <u>then</u>
      <u>begin</u> COEFFICIENT;
         C1 ≔ STEP × MU1; D ≔ STEP × STEP × MU2;
         <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
            <u>begin</u> <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
                    J1[K, L] ≔ D × MATMAT(1, M, K, L, J, J) +
                    C1 × J[K, L];
               J1[K, K] ≔ J1[K, K] + 1
            <u>end</u>;
         GSSELM(J1, M, AUX, RI, CI)
      <u>end</u>;
      C1 ≔ STEP × STEP × MU0; D ≔ STEP × 2 / 3;
      <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
         <u>begin</u> K0[K] ≔ FK ≔ F[K];
            LABDA[K] ≔ D × FK + C1 × MATVEC(1, M, K, J, F)
         <u>end</u>;
      SOLELM(J1, M, RI, CI, LABDA);
      <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> F[K] ≔ Y[K] + LABDA[K];
      DERIVATIVE(F);
      C1 ≔ THETA0 × STEP; C2 ≔ THETA1 × STEP; D ≔ NU1 × STEP;
      <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
         <u>begin</u> YK ≔ Y[K]; FK ≔ F[K];
            LABDA[K] ≔ YK + D × FK + NU2 × LABDA[K];
            Y[K] ≔ F[K] ≔ YK + C1 × K0[K] + C2 × FK
         <u>end</u>
   <u>end</u> DIFFERENCE SCHEME;

   AUX[2] ≔ &#9192;-14; AUX[4] ≔ 8;
   <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> F[K] ≔ Y[K];
   N ≔ 0; OUTPUT; STEP ≔ 0;
   NEXT STEP: N ≔ N + 1;
   DIFFERENCE SCHEME; X ≔ X + STEP; OUTPUT;
   <u>if</u> X &lt; XE <u>then</u> <u>goto</u> NEXT STEP
<u>end</u> EFSIRK;
<u>comment</u> ================== 33120 ================= ;
<u>procedure</u> EFERK(X, XE, M, Y, SIGMA, PHI, DERIVATIVE, J, JACOBIAN,
  K, L, AUT, AETA, RETA, HMIN, HMAX, LINEAR, OUTPUT);
   <u>value</u> L; <u>integer</u> M, K, L;
     <u>real</u> X, XE, SIGMA, PHI, AETA, RETA, HMIN, HMAX; <u>array</u> Y, J;
     <u>Boolean</u> AUT, LINEAR; <u>procedure</u> DERIVATIVE, JACOBIAN, OUTPUT;
<u>begin</u> <u>integer</u> M1, I;
   <u>real</u> H, B, B0, PHI0, COSPHI, SINPHI, ETA, DISCR, FAC, PI;
   <u>Boolean</u> CHANGE, LAST;
   <u>integer</u> <u>array</u> P[1:L];
   <u>real</u> <u>array</u> BETA, BETHA[0:L], BETAC[0:L + 3], K0, D, D1, D2[1:M],
     A[1:L, 1:L], AUX[1:3];
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;
   <u>real</u> <u>procedure</u> SUM(I, L, U, T); <u>value</u> L, U; <u>integer</u> I, L, U;
        <u>real</u> T;
   <u>begin</u> <u>real</u> S; S ≔ 0;
      <u>for</u> I ≔ L <u>step</u> 1 <u>until</u> U <u>do</u> S ≔ S + T;
      SUM ≔ S
   <u>end</u>;
   <u>procedure</u> FORMBETA;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> BETHA[1] ≔ (·5-(1-(1-EXP(-B))/B)/B)/B;
         BETA[1] ≔ (1/6-BETHA[1])/B
      <u>end</u> <u>else</u>
      <u>if</u> L = 2 <u>then</u>
      <u>begin</u> <u>real</u> E, EMIN1; E ≔ EXP(-B); EMIN1 ≔ E-1;
         BETHA[1] ≔ (1-(3 + E + 4 × EMIN1/B)/B)/B;
         BETHA[2] ≔ (·5-(2 + E + 3 × EMIN1/B)/B)/B/B;
         BETA[2] ≔ (1/6-BETHA[1])/B/B;
         BETA[1] ≔ (1/3-(1·5-(4 + E + 5 × EMIN1/B)/B)/B)/B
      <u>end</u> <u>else</u>
      <u>begin</u> <u>real</u> B0, B1, B2, A0, A1, A2, A3, C, D;
         BETAC[L-1] ≔ C ≔ D ≔ EXP(-B)/FAC;
         <u>for</u> I ≔ L-1 <u>step</u> -1 <u>until</u> 1 <u>do</u>
            <u>begin</u> C ≔ I × B × C/(L-I); BETAC[I-1] ≔ D ≔ D × I + C <u>end</u>;
         B2 ≔ ·5-BETAC[2];
         B1 ≔ (1-BETAC[1]) × (L + 1)/B;
         B0 ≔ (1-BETAC[0]) × (L + 2) × (L + 1) × ·5/B/B;
         A3 ≔ 1/6-BETAC[3];
         A2 ≔ B2 × (L + 1)/B;
         A1 ≔ B1 × (L + 2) × ·5/B;
         A0 ≔ B0 × (L + 3)/3/B;
         D ≔ L/B;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L <u>do</u>
            <u>begin</u> BETA[I] ≔ (A3/I-A2/(I + 1) + A1/(I + 2)-A0/(I + 3)) × D + BETAC[I + 3];
               BETHA[I] ≔ (B2/I-B1/(I + 1) + B0/(I + 2)) × D + BETAC[I + 2];
               D ≔ D × (L-I)/I/B;
            <u>end</u>
      <u>end</u> FORMBETA;

   <u>procedure</u> SOLUTIONOFCOMPLEXEQUATIONS;
      <u>if</u> L = 2 <u>then</u>
      <u>begin</u> <u>real</u> COS2PHI, COSA, SINA, E, ZI;
         PHI0 ≔ PHI; COSPHI ≔ COS(PHI0); SINPHI ≔ SIN(PHI0);
         E ≔ EXP(B × COSPHI); ZI ≔ B × SINPHI-3 × PHI0;
         SINA ≔ (<u>if</u> ABS(SINPHI) &lt; &#9192;-6 <u>then</u> -E × (B + 3)
         <u>else</u> E × SIN(ZI)/SINPHI);
         COS2PHI ≔ 2 × COSPHI × COSPHI-1;
         BETHA[2] ≔ (·5 + (2 × COSPHI + (1 + 2 × COS2PHI + SINA)/B)/B)/B/B;
         SINA ≔ (<u>if</u> ABS(SINPHI) &lt; &#9192;-6 <u>then</u> E × (B + 4)
         <u>else</u> SINA × COSPHI-E × COS(ZI));
         BETHA[1] ≔ -(COSPHI + (1 + 2 × COS2PHI + (4 × COSPHI × COS2PHI + SINA)
           /B)/B)/B;
         BETA[1] ≔ BETHA[2] + 2 × COSPHI × (BETHA[1]-1/6)/B;
         BETA[2] ≔ (1/6-BETHA[1])/B/B
      <u>end</u> <u>else</u>

      <u>begin</u> <u>integer</u> J, C1;
         <u>real</u> C2, E, ZI, COSIPHI, SINIPHI, COSPHIL;
         <u>real</u> <u>array</u> D[1:L];
         <u>procedure</u> ELEMENTS OF MATRIX;
         <u>begin</u> PHI0 ≔ PHI;
            COSPHI ≔ COS(PHI0); SINPHI ≔ SIN(PHI0);
            COSIPHI ≔ 1; SINIPHI ≔ 0;
            <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> L-1 <u>do</u>
               <u>begin</u> C1 ≔ 4 + I; C2 ≔ 1;
                  <u>for</u> J ≔ L-1 <u>step</u> -2 <u>until</u> 1 <u>do</u>
                     <u>begin</u>  A[J, L-I] ≔ C2 × COSIPHI;
                        A[J + 1, L-I] ≔ C2 × SINIPHI;
                        C2 ≔ C2 × C1; C1 ≔ C1-1
                     <u>end</u>;
                  COSPHIL ≔ COSIPHI × COSPHI-SINIPHI × SINPHI;
                  SINIPHI ≔ COSIPHI × SINPHI + SINIPHI × COSPHI;
                  COSIPHI ≔ COSPHIL
               <u>end</u>;
            AUX[2] ≔ 0; DEC(A, L, AUX, P)
         <u>end</u> EL OF MAT;
         <u>procedure</u> RIGHT HAND SIDE;
         <u>begin</u> E ≔ EXP(B × COSPHI);
            ZI ≔ B × SINPHI-4 × PHI0;
            COSIPHI ≔ E × COS(ZI); SINIPHI ≔ E × SIN(ZI);
            ZI ≔ 1/B/B/B;
            <u>for</u> J ≔ L <u>step</u> -2 <u>until</u> 2 <u>do</u>
               <u>begin</u> D[J] ≔ ZI × SINIPHI;
                  D[J-1] ≔ ZI × COSIPHI;
                  COSPHIL ≔ COSIPHI × COSPHI-SINIPHI × SINPHI;
                  SINIPHI ≔ COSIPHI × SINPHI + SINIPHI × COSPHI;
                  COSIPHI ≔ COSPHIL; ZI ≔ ZI × B
               <u>end</u>;
            SINIPHI ≔ 2 × SINPHI × COSPHI;
            COSIPHI ≔ 2 × COSPHI × COSPHI-1;
            COSPHIL ≔ COSPHI × (2 × COSIPHI-1);
            D[L] ≔ D[L] + SINPHI × (1/6 + (COSPHI + (1 + 2 × COSIPHI × (1 + 2 × COSPHI/B))
              /B)/B);
            D[L-1] ≔ D[L-1]-COSPHI/6-(·5 × COSIPHI + (COSPHIL + (2 × COSIPHI ×
              COSIPHI-1)/B)/B)/B;
            D[L-2] ≔ D[L-2] + SINPHI × (·5 + (2 × COSPHI + (2 × COSIPHI + 1)/B)/B);
            D[L-3] ≔ D[L-3]-·5 × COSPHI-(COSIPHI + COSPHIL/B)/B;
            <u>if</u> L &lt; 5 <u>then</u> <u>goto</u> END;
            D[L-4] ≔ D[L-4] + SINPHI + SINIPHI/B;
            D[L-5] ≔ D[L-5]-COSPHI-COSIPHI/B;
            <u>if</u> L &lt; 7 <u>then</u> <u>goto</u> END;
            D[L-6] ≔ D[L-6] + SINPHI;
            D[L-7] ≔ D[L-7]-COSPHI;
            END:
         <u>end</u> RHS;
         <u>if</u> PHI0 ≠ PHI <u>then</u> ELEMENTS OF MATRIX;
         RIGHT HAND SIDE;
         SOL(A, L, P, D);
         ZI ≔ 1/B;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L <u>do</u>
            <u>begin</u> BETA[I] ≔ D[L + 1-I] × ZI;
               BETHA[I] ≔ (I + 3) × BETA[I];
               ZI ≔ ZI/B
            <u>end</u>
      <u>end</u> SOLOFEQCOM;

   <u>procedure</u> COEFFICIENT;
   <u>begin</u> B0 ≔ B ≔ ABS(H × SIGMA);
      <u>if</u> B &GreaterSlantEqual; ·1 <u>then</u>
      <u>begin</u> <u>if</u> PHI ≠ PI ∧ L = 2 ∨ ABS(PHI-PI) &gt; ·01 <u>then</u>
           SOLUTION OF COMPLEX EQUATIONS <u>else</u> FORMBETA
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> L <u>do</u>
            <u>begin</u> BETHA[I] ≔ BETA[I-1];
               BETA[I] ≔ BETA[I-1]/(I + 3);
            <u>end</u>
      <u>end</u>
   <u>end</u> COEFFICIENT;

   <u>procedure</u> LOCAL ERROR BOUND;
      ETA ≔ AETA + RETA × SQRT(VECVEC(1, M1, 0, Y, Y));

   <u>procedure</u> STEPSIZE;
   <u>begin</u> LOCAL ERROR BOUND;
      <u>if</u> K = 0 <u>then</u>
      <u>begin</u> DISCR ≔ SQRT(VECVEC(1, M1, 0, D, D)); H ≔ ETA/DISCR
      <u>end</u> <u>else</u>
      <u>begin</u> DISCR ≔ H × SQRT(SUM(I, 1, M1, (D[I]-D2[I])⭡2))/ETA;
         H ≔ H × (<u>if</u> LINEAR <u>then</u> 4/(4 + DISCR) + ·5
         <u>else</u> 4/(3 + DISCR) + 1/3)
      <u>end</u>;
      <u>if</u> H &lt; HMIN <u>then</u> H ≔ HMIN;
      <u>if</u> H &gt; HMAX <u>then</u> H ≔ HMAX;
      B ≔ ABS(H × SIGMA);
      CHANGE ≔ ABS(1-B/B0) &gt; ·05 ∨ PHI ≠ PHI0;
      <u>if</u> 1·1 × H &GreaterSlantEqual; XE-X <u>then</u>
      <u>begin</u> CHANGE ≔ LAST ≔ <u>true</u>; H ≔ XE-X <u>end</u>;
      <u>if</u> ¬CHANGE <u>then</u> H ≔ H × B0/B
   <u>end</u> STEPSIZE;

   <u>procedure</u> DIFFERENCE SCHEME;
   <u>begin</u> <u>integer</u> K;
      <u>real</u> BETAI, BETHAI;
      <u>if</u> M1 &lt; M <u>then</u>
      <u>begin</u> D2[M] ≔ 1; K0[M] ≔ Y[M] + 2 × H/3; Y[M] ≔ Y[M] + ·25 × H <u>end</u>;
      <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M1 <u>do</u>
         <u>begin</u> K0[K] ≔ Y[K] + 2 × H/3 × D[K];
            Y[K] ≔ Y[K] + ·25 × H × D[K];
            D1[K] ≔ H × MATVEC(1, M, K, J, D);
            D2[K] ≔ D1[K] + D[K]
         <u>end</u>;
      <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> L <u>do</u>
         <u>begin</u> BETAI ≔ 4 × BETA[I]/3; BETHAI ≔ BETHA[I];
            <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M1 <u>do</u> D[K] ≔ H × D1[K];
            <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M1 <u>do</u>
               <u>begin</u> K0[K] ≔ K0[K] + BETAI × D[K];
                  D1[K] ≔ MATVEC(1, M1, K, J, D);
                  D2[K] ≔ D2[K] + BETHAI × D1[K]
               <u>end</u>
         <u>end</u>;
      DERIVATIVE(K0);
      <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> Y[K] ≔ Y[K] + ·75 × H × K0[K]
   <u>end</u> DIFF SCHEME;

   B0 ≔ PHI0 ≔ -1; PI ≔ 4 × ARCTAN(1);
   BETAC[L] ≔ BETAC[L + 1] ≔ BETAC[L + 2] ≔ BETAC[L + 3] ≔ 0;
   BETA[0] ≔ 1/6; BETHA[0] ≔ ·5;
   FAC ≔ 1; <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> L-1 <u>do</u> FAC ≔ I × FAC;
   M1 ≔ <u>if</u> AUT <u>then</u> M <u>else</u> M-1;
   K ≔ 0; LAST ≔ <u>false</u>;
   NEXT LEVEL:
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> D[I] ≔ Y[I];
   DERIVATIVE(D);
   <u>if</u> ¬LINEAR ∨ K = 0 <u>then</u> JACOBIAN(J, Y);
   STEPSIZE;
   <u>if</u> CHANGE <u>then</u> COEFFICIENT;
   OUTPUT;
   DIFFERENCE SCHEME;
   K ≔ K + 1;
   X ≔ X + H;
   <u>if</u> ¬LAST <u>then</u> <u>goto</u> NEXT LEVEL;
   END OF EFERK: OUTPUT;
<u>end</u> EFERK;
<u>comment</u> ================== 33131 ================= ;
<u>procedure</u> LINIGER2(X, XE, M, Y, SIGMA1, SIGMA2, F, EVALUATE, J,
  JACOBIAN, K, ITMAX, STEP, AETA, RETA, OUTPUT);
   <u>integer</u> M, K, ITMAX;
     <u>real</u> X, XE, SIGMA1, SIGMA2, STEP, AETA, RETA;
     <u>array</u> Y, J;
     <u>Boolean</u> <u>procedure</u> EVALUATE;
     <u>real</u> <u>procedure</u> F;
     <u>procedure</u> JACOBIAN, OUTPUT;

<u>begin</u> <u>integer</u> I;
   <u>real</u> H, HL, B1, B2, P, Q, C0, C1, C2, C3, C4;
   <u>Boolean</u> LAST;
   <u>integer</u> <u>array</u> PI[1:M];
   <u>real</u> <u>array</u> DY, YL, FL[1:M], A[1:M, 1:M], AUX[1:3];
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;

   <u>procedure</u> STEPSIZE;
   <u>begin</u> H ≔ STEP;
      <u>if</u> 1·1 × H &GreaterSlantEqual; XE-X <u>then</u>
      <u>begin</u> LAST ≔ <u>true</u>; H ≔ XE-X; X ≔ XE
      <u>end</u> <u>else</u> X ≔ X + H
   <u>end</u> STEPSIZE;

   <u>procedure</u> COEFFICIENT;
   <u>begin</u> <u>real</u> R1, R2, EX, ZETA, ETA, SINL, COSL, SINH, COSH, D;
      <u>real</u> <u>procedure</u> R(X); <u>value</u> X; <u>real</u> X;
         <u>if</u> X &gt; 40 <u>then</u> R ≔ X/(X-2) <u>else</u>
         <u>begin</u> EX ≔ EXP(-X); R ≔ X × (1-EX)/(X-2 + (X + 2) × EX) <u>end</u>;

      B1 ≔ H × SIGMA1;
      B2 ≔ H × SIGMA2;
      <u>if</u> B1 &lt; ·1 <u>then</u> <u>begin</u> P ≔ 0; Q ≔ 1/3; <u>goto</u> OUT <u>end</u>;
      <u>if</u> B2 &lt; 0 <u>then</u> <u>goto</u> COMPLEX;
      <u>if</u> B1 &lt; 1 ∨ B2 &lt; ·1 <u>then</u> <u>goto</u> THIRDORDER;
      <u>if</u> ABS(B1-B2) &lt; B1 × B1 × &#9192;-6 <u>then</u> <u>goto</u> DOUBLEFIT;

      R1 ≔ R(B1) × B1; R2 ≔ R(B2) × B2;
      D ≔ B2 × R1-B1 × R2;
      P ≔ 2 × (R2-R1)/D;
      Q ≔ 2 × (B2-B1)/D;
      <u>goto</u> OUT;
      THIRDORDER: Q ≔ 1/3;
      P ≔ R(B1)/3-2/B1;
      <u>goto</u> OUT;
      DOUBLEFIT: B1 ≔ ·5 × (B1 + B2);
      R1 ≔ R(B1);
      <u>if</u> B1 &gt; 40 <u>then</u> EX ≔ 0;
      R2 ≔ B1/(1-EX); R2 ≔ 1-EX × R2 × R2;
      Q ≔ 1/(R1 × R1 × R2);
      P ≔ R1 × Q-2/B1;
      <u>goto</u> OUT;
      COMPLEX: ETA ≔ ABS(B1 × SIN(SIGMA2));
      ZETA ≔ ABS(B1 × COS(SIGMA2));
      <u>if</u> ETA &lt; B1 × B1 × &#9192;-6 <u>then</u>
      <u>begin</u> B1 ≔ B2 ≔ ZETA; <u>goto</u> DOUBLEFIT <u>end</u>;
      <u>if</u> ZETA &gt; 40 <u>then</u>
      <u>begin</u> P ≔ 1-4 × ZETA/B1/B1; Q ≔ 4 × (1-ZETA)/B1/B1 + 1 <u>end</u> <u>else</u>
      <u>begin</u> EX ≔ EXP(ZETA);
         SINL ≔ SIN(ETA); COSL ≔ COS(ETA);
         SINH ≔ ·5 × (EX-1/EX); COSH ≔ ·5 × (EX + 1/EX);
         D ≔ ETA × (COSH-COSL)-·5 × B1 × B1 × SINL;
         P ≔ (ZETA × SINL + ETA × SINH-4 × ZETA × ETA/B1/B1 × (COSH-COSL))/D;
         Q ≔ ETA × ((COSH-COSL-ZETA × SINH-ETA × SINL) × 4/B1/B1 + COSH + COSL)/D
      <u>end</u>;
      OUT:    C0 ≔ ·25 × H × H × (P + Q);
      C1 ≔ ·5 × H × (1 + P);
      C2 ≔ H-C1;
      C3 ≔ ·25 × H × H × (Q-P);
      C4 ≔ ·5 × H × P;
      ELEMENTS OF MATRIX
   <u>end</u> COEFFICIENT;

   <u>procedure</u> ELEMENTS OF MATRIX;
   <u>begin</u> <u>integer</u> K;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
         <u>begin</u> <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
                 A[I, K] ≔ C0 × MATMAT(1, M, I, K, J, J)-C1 × J[I, K];
            A[I, I] ≔ A[I, I] + 1
         <u>end</u>;
      AUX[2] ≔ 0; DEC(A, M, AUX, PI)
   <u>end</u> ELOFMAT;
   <u>procedure</u> NEWTON ITERATION;
   <u>begin</u> <u>integer</u> ITNUM; <u>real</u> JFL, ETA, DISCR;
      ITNUM ≔ 0;
      NEXT:   ITNUM ≔ ITNUM + 1;
      <u>if</u> EVALUATE(ITNUM) <u>then</u>
      <u>begin</u> JACOBIAN(J, Y); COEFFICIENT <u>end</u>
        <u>else</u> <u>if</u> ITNUM = 1 ∧ H ≠ HL <u>then</u> COEFFICIENT;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> FL[I] ≔ F(I);
      <u>if</u> ITNUM = 1 <u>then</u>
      <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
            <u>begin</u> JFL ≔ MATVEC(1, M, I, J, FL);
               DY[I] ≔ H × (FL[I]-C4 × JFL);
               YL[I] ≔ Y[I] + C2 × FL[I] + C3 × JFL
            <u>end</u>
      <u>end</u> <u>else</u>
        <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
           DY[I] ≔ YL[I]-Y[I] + C1 × FL[I]-C0 × MATVEC(1, M, I, J, FL);
      SOL(A, M, PI, DY);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> Y[I] ≔ Y[I] + DY[I];
      <u>if</u> ITNUM &lt; ITMAX <u>then</u>
      <u>begin</u> ETA ≔ SQRT(VECVEC(1, M, 0, Y, Y)) × RETA + AETA;
         DISCR ≔ SQRT(VECVEC(1, M, 0, DY, DY));
         <u>if</u> ETA &lt; DISCR <u>then</u> <u>goto</u> NEXT
      <u>end</u>
   <u>end</u> NEWTON;

   LAST ≔ <u>false</u>; K ≔ 0; HL ≔ 0;
   NEXT LEVEL:
   K ≔ K + 1;
   STEPSIZE;
   NEWTON ITERATION;
   HL ≔ H;
   OUTPUT;
   <u>if</u> ¬LAST <u>then</u> <u>goto</u> NEXT LEVEL
<u>end</u> LINIGER2;
<u>comment</u> ================== 33040 ================= ;
<u>procedure</u> MODIFIED TAYLOR(T, TE, M0, M, U, SIGMA, TAUMIN, I, DERIVATIVE, K,
  DATA, ALFA, NORM, AETA, RETA, ETA, RHO, OUT);
   <u>integer</u> M0, M, I, K, NORM;
     <u>real</u> T, TE, SIGMA, TAUMIN, ALFA, AETA, RETA, ETA, RHO;
     <u>array</u> U, DATA;
     <u>procedure</u> DERIVATIVE, OUT;

<u>begin</u> I ≔ 0;
   <u>begin</u> <u>integer</u> N, P, Q;
      <u>own</u> <u>real</u> EC0, EC1, EC2, TAU0, TAU1, TAU2, TAUS, T2;
      <u>real</u> T0, TAU, TAUI, TAUEC, ECL, BETAN, GAMMA;
      <u>real</u> <u>array</u> C[M0:M], BETA, BETHA[1:DATA[-2]];
      <u>Boolean</u> START, STEP1, LAST;
      <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;

      <u>procedure</u> COEFFICIENT;
      <u>begin</u> <u>integer</u> J; <u>real</u> IFAC;
         IFAC ≔ 1; GAMMA ≔ ·5; N ≔ DATA[-2]; P ≔ DATA[-1];
         BETAN ≔ DATA[0]; Q ≔ <u>if</u> P &lt; N <u>then</u> P + 1 <u>else</u> N;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> BETA[J] ≔ DATA[J]; IFAC ≔ IFAC/J;
               BETHA[J] ≔ IFAC-BETA[J]
            <u>end</u>;
         <u>if</u> P = N <u>then</u> BETHA[N] ≔ IFAC
      <u>end</u>;

      <u>real</u> <u>procedure</u> NORMFUNCTION(NORM, W);
         <u>integer</u> NORM; <u>array</u> W;
      <u>begin</u> <u>integer</u> J; <u>real</u> S, X;
         S ≔ 0;
         <u>if</u> NORM = 1 <u>then</u>
         <u>begin</u> <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u>
               <u>begin</u>  X ≔ ABS(W[J]); <u>if</u> X &gt; S <u>then</u> S ≔ X <u>end</u>
         <u>end</u> <u>else</u>
           S ≔ SQRT(VECVEC(M0, M, 0, W, W));
         NORMFUNCTION ≔ S
      <u>end</u>;

      <u>procedure</u> LOCAL ERROR BOUND;
         ETA ≔ AETA + RETA × NORMFUNCTION(NORM, U);

      <u>procedure</u> LOCAL ERROR CONSTRUCTION(I); <u>integer</u> I;
      <u>begin</u> <u>if</u> I = P <u>then</u> <u>begin</u> ECL ≔ 0; TAUEC ≔ 1 <u>end</u>;
         <u>if</u> I &gt; P + 1 <u>then</u> TAUEC ≔ TAUEC × TAU;
         ECL ≔ ECL + ABS(BETHA[I]) × TAUEC × NORMFUNCTION(NORM, C);
         <u>if</u> I = N <u>then</u>
         <u>begin</u> EC0 ≔ EC1; EC1 ≔ EC2; EC2 ≔ ECL;
            RHO ≔ ECL × TAU⭡Q
         <u>end</u>
      <u>end</u>;

      <u>procedure</u> STEPSIZE;
      <u>begin</u> <u>real</u> TAUACC, TAUSTAB, AA, BB, CC, EC;
         LOCAL ERROR BOUND;
         <u>if</u> ETA &gt; 0 <u>then</u>
         <u>begin</u> <u>if</u> START <u>then</u>
            <u>begin</u> <u>if</u> K = 0 <u>then</u>
               <u>begin</u> <u>integer</u> J;
                  <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u> C[J] ≔ U[J];
                  I ≔ 1; DERIVATIVE(I, C);
                  TAUACC ≔ ETA/NORMFUNCTION(NORM, C);
                  STEP1 ≔ <u>true</u>
               <u>end</u> <u>else</u>
               <u>if</u> STEP1 <u>then</u>
               <u>begin</u> TAUACC ≔ (ETA/RHO)⭡(1/Q) × TAU2;
                  <u>if</u> TAUACC &gt; 10 × TAU2 <u>then</u>
                    TAUACC ≔ 10 × TAU2 <u>else</u> STEP1 ≔ <u>false</u>
               <u>end</u> <u>else</u>
               <u>begin</u> BB ≔ (EC2-EC1)/TAU1; CC ≔ EC2-BB × T2;
                  EC ≔ BB × T + CC;
                  TAUACC ≔ <u>if</u> EC &lt; 0 <u>then</u> TAU2 <u>else</u>
                    (ETA/EC)⭡(1/Q);
                  START ≔ <u>false</u>
               <u>end</u>
            <u>end</u> <u>else</u>
            <u>begin</u> AA ≔ ((EC0-EC1)/TAU0 + (EC2-EC1)/TAU1)/
                 (TAU1 + TAU0);
               BB ≔ (EC2-EC1)/TAU1-AA × (2 × T2-TAU1);
               CC ≔ EC2-T2 × (BB + AA × T2); EC ≔ CC + T × (BB + T × AA);
               TAUACC ≔ <u>if</u> EC &lt; 0 <u>then</u> TAUS
               <u>else</u> (ETA/EC)⭡(1/Q);
               <u>if</u> TAUACC &gt; ALFA × TAUS <u>then</u> TAUACC ≔ ALFA × TAUS;
               <u>if</u> TAUACC &lt; GAMMA × TAUS <u>then</u> TAUACC ≔ GAMMA × TAUS;
            <u>end</u>
         <u>end</u> <u>else</u> TAUACC ≔ TE-T;
         <u>if</u> TAUACC &lt; TAUMIN <u>then</u> TAUACC ≔ TAUMIN;
         TAUSTAB ≔ BETAN/SIGMA;
         <u>if</u> TAUSTAB &lt; &#9192;-12 × (T-T0) <u>then</u>
         <u>begin</u> OUT; <u>goto</u> END OF MODIFIED TAYLOR <u>end</u>;
         TAU ≔ <u>if</u> TAUACC &gt; TAUSTAB <u>then</u> TAUSTAB <u>else</u> TAUACC;
         TAUS ≔ TAU; <u>if</u> TAU &GreaterSlantEqual; TE-T <u>then</u>
         <u>begin</u> TAU ≔ TE-T; LAST ≔ <u>true</u> <u>end</u>;
         TAU0 ≔ TAU1; TAU1 ≔ TAU2; TAU2 ≔ TAU
      <u>end</u>;

      <u>procedure</u> DIFFERENCE SCHEME;
      <u>begin</u> <u>integer</u> J; <u>real</u> B;
         <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u> C[J] ≔ U[J]; TAUI ≔ 1;
         NEXT TERM:
         I ≔ I + 1; DERIVATIVE(I, C); TAUI ≔ TAUI × TAU;
         B ≔ BETA[I] × TAUI;
         <u>if</u> ETA &gt; 0 ∧ I &GreaterSlantEqual; P <u>then</u> LOCAL ERROR CONSTRUCTION(I);
         <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u> U[J] ≔ U[J] + B × C[J];
         <u>if</u> I &lt; N <u>then</u> <u>goto</u> NEXT TERM;
         T2 ≔ T; <u>if</u> LAST <u>then</u>
         <u>begin</u> LAST ≔ <u>false</u>; T ≔ TE <u>end</u>
         <u>else</u> T ≔ T + TAU
      <u>end</u>;

      START ≔ K = 0; T0 ≔ T;
      COEFFICIENT; LAST ≔ <u>false</u>;
      NEXT LEVEL:
      STEPSIZE; K ≔ K + 1; I ≔ 0; DIFFERENCE SCHEME; OUT;
      <u>if</u> T ≠ TE <u>then</u> <u>goto</u> NEXT LEVEL
   <u>end</u>;
   END OF MODIFIED TAYLOR:
<u>end</u> MODIFIED TAYLOR;
<u>comment</u> ================== 33050 ================= ;
<u>procedure</u> EXPONENTIALLY FITTED TAYLOR(T, TE, M0, M, U, SIGMA, PHI, DIAMETER,
  DERIVATIVE, I, K, ALFA, NORM, AETA, RETA, ETA, RHO, HMIN, HSTART, OUTPUT);
   <u>integer</u> M0, M, I, K, NORM;
     <u>real</u> T, TE, SIGMA, PHI, DIAMETER, ALFA, AETA, RETA, ETA, RHO, HMIN, HSTART;
     <u>array</u> U;
     <u>procedure</u> DERIVATIVE, OUTPUT;
<u>begin</u> <u>integer</u> KL;
   <u>real</u> Q, EC0, EC1, EC2, H, HI, H0, H1, H2, BETAN, T2, SIGMAL, PHIL;
   <u>real</u> <u>array</u> C, RO[M0:M], BETA, BETHA[1:3];
   <u>Boolean</u> LAST, START;
   <u>procedure</u> INIVEC(L, U, A, X); <u>code</u> 31010;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B); <u>code</u> 31030;
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X); <u>code</u> 34020;
   <u>Boolean</u> <u>procedure</u> ZEROIN(X, Y, FX, EPS); <u>code</u> 34150;

   <u>procedure</u> COEFFICIENT;
   <u>begin</u> <u>real</u> B, B1, B2, BB, E, BETA2, BETA3;
      B ≔ H × SIGMAL; B1 ≔ B × COS(PHIL); BB ≔ B × B;
      <u>if</u> ABS(B) &lt; &#9192;-3 <u>then</u>
      <u>begin</u> BETA2 ≔ ·5-BB/24;
         BETA3 ≔ 1/6 + B1/12;
         BETHA[3] ≔ ·5 + B1/3
      <u>end</u> <u>else</u>
      <u>if</u> B1 &lt; -40 <u>then</u>
      <u>begin</u> BETA2 ≔ (-2 × B1-4 × B1 × B1/BB + 1)/BB;
         BETA3 ≔ (1 + 2 × B1/BB)/BB;
         BETHA[3] ≔ 1/BB
      <u>end</u> <u>else</u>
      <u>begin</u> E ≔ EXP(B1)/BB; B2 ≔ B × SIN(PHIL);
         BETA2 ≔ (-2 × B1-4 × B1 × B1/BB + 1)/BB;
         BETA3 ≔ (1 + 2 × B1/BB)/BB;
         <u>if</u> ABS(B2/B) &lt; &#9192;-5 <u>then</u>
         <u>begin</u> BETA2 ≔ BETA2-E × (B1-3);
            BETA3 ≔ BETA3 + E × (B1-2)/B1;
            BETHA[3] ≔ 1/BB + E × (B1-1)
         <u>end</u> <u>else</u>
         <u>begin</u> BETA2 ≔ BETA2-E × SIN(B2-3 × PHIL)/B2 × B;
            BETA3 ≔ BETA3 + E × SIN(B2-2 × PHIL)/B2;
            BETHA[3] ≔ 1/BB + E × SIN(B2-PHIL)/B2 × B;
         <u>end</u>
      <u>end</u>;
      BETA[1] ≔ BETHA[1] ≔ 1;
      BETA[2] ≔ BETA2; BETA[3] ≔ BETA3;
      BETHA[2] ≔ 1-BB × BETA3; B ≔ ABS(B);
      Q ≔ <u>if</u> B &lt; 1·5 <u>then</u> 4-2 × B/3 <u>else</u> <u>if</u> B &lt; 6 <u>then</u> (30-2 × B)/9
      <u>else</u> 2;
   <u>end</u>;

   <u>real</u> <u>procedure</u> NORMFUNCTION(NORM, W);
      <u>integer</u> NORM; <u>array</u> W;
   <u>begin</u> <u>integer</u> J; <u>real</u> S, X;
      S ≔ 0;
      <u>if</u> NORM = 1 <u>then</u>
      <u>begin</u> <u>for</u> J ≔ M0 <u>step</u> 1 <u>until</u> M <u>do</u>
            <u>begin</u> X ≔ ABS(W[J]); <u>if</u> X &gt; S <u>then</u> S ≔ X <u>end</u>
      <u>end</u> <u>else</u>
        S ≔ SQRT(VECVEC(M0, M, 0, W, W));
      NORMFUNCTION ≔ S;
   <u>end</u>;

   <u>procedure</u> LOCAL ERROR BOUND;
      ETA ≔ AETA + RETA × NORMFUNCTION(NORM, U);

   <u>procedure</u> LOCAL ERROR CONSTRUCTION(I); <u>integer</u> I;
   <u>begin</u> <u>if</u> I = 1 <u>then</u> INIVEC(M0, M, RO, 0);
      <u>if</u> I &lt; 4 <u>then</u> ELMVEC(M0, M, 0, RO, C, BETHA[I] × HI);
      <u>if</u> I = 4 <u>then</u>
      <u>begin</u> ELMVEC(M0, M, 0, RO, C, -H);
         RHO ≔ NORMFUNCTION(NORM, RO);
         EC0 ≔ EC1; EC1 ≔ EC2; EC2 ≔ RHO/H⭡Q;
      <u>end</u>
   <u>end</u>;

   <u>procedure</u> STEPSIZE;
   <u>begin</u> <u>real</u> HACC, HSTAB, HCR, HMAX, A, B, C;
      <u>if</u> ¬START <u>then</u> LOCAL ERROR BOUND;
      <u>if</u> START <u>then</u>
      <u>begin</u> H1 ≔ H2 ≔ HACC ≔ HSTART;
         EC2 ≔ EC1 ≔ 1; KL ≔ 1; START ≔ <u>false</u>
      <u>end</u> <u>else</u>
      <u>if</u> KL &lt; 3 <u>then</u>
      <u>begin</u> HACC ≔ (ETA/RHO)⭡(1/Q) × H2;
         <u>if</u> HACC &gt; 10 × H2 <u>then</u> HACC ≔ 10 × H2 <u>else</u> KL ≔ KL + 1
      <u>end</u> <u>else</u>
      <u>begin</u> A ≔ (H0 × (EC2-EC1)-H1 × (EC1-EC0))/(H2 × H0-H1 × H1);
         H ≔ H2 × (<u>if</u> ETA &lt; RHO <u>then</u> (ETA/RHO)⭡(1/Q) <u>else</u> ALFA);
         <u>if</u> A &gt; 0 <u>then</u>
         <u>begin</u> B ≔ (EC2-EC1-A × (H2-H1))/H1;
            C ≔ EC2-A × H2-B × T2; HACC ≔ 0; HMAX ≔ H;
            <u>if</u> ¬ZEROIN(HACC, H, HACC⭡Q × (A × HACC + B × T + C)-ETA,&#9192;-3 × H2) <u>then</u> HACC ≔ HMAX
         <u>end</u> <u>else</u> HACC ≔ H;
         <u>if</u> HACC &lt; ·5 × H2 <u>then</u> HACC ≔ ·5 × H2;
      <u>end</u>;
      <u>if</u> HACC &lt; HMIN <u>then</u> HACC ≔ HMIN; H ≔ HACC;
      <u>if</u> H × SIGMAL &gt; 1 <u>then</u>
      <u>begin</u> A ≔ ABS(DIAMETER/SIGMAL + &#9192;-14)/2; B ≔ 2 × ABS(SIN(PHIL));
         BETAN ≔ (<u>if</u> A &gt; B <u>then</u> 1/A <u>else</u> 1/B)/A;
         HSTAB ≔ ABS(BETAN/SIGMAL);
         <u>if</u> HSTAB &lt; &#9192;-14 × T <u>then</u> <u>goto</u> ENDOFEFT;
         <u>if</u> H &gt; HSTAB <u>then</u> H ≔ HSTAB
      <u>end</u>;
      HCR ≔ H2 × H2/H1;
      <u>if</u> KL &gt; 2 ∧ ABS(H-HCR) &lt; &#9192;-6 × HCR <u>then</u>
        H ≔ <u>if</u> H &lt; HCR <u>then</u> HCR × (1-&#9192;-7) <u>else</u> HCR × (1 + &#9192;-7);
      <u>if</u> T + H &gt; TE <u>then</u>
      <u>begin</u> LAST ≔ <u>true</u>; HSTART ≔ H; H ≔ TE-T <u>end</u>;
      H0 ≔ H1; H1 ≔ H2; H2 ≔ H;
   <u>end</u>;

   <u>procedure</u> DIFFERENCE SCHEME;
   <u>begin</u> HI ≔ 1; SIGMAL ≔ SIGMA; PHIL ≔ PHI;
      STEPSIZE;
      COEFFICIENT;
      <u>for</u> I ≔ 1, 2, 3 <u>do</u>
         <u>begin</u> HI ≔ HI × H;
            <u>if</u> I &gt; 1 <u>then</u> DERIVATIVE(I, C);
            LOCALERRORCONSTRUCTION(I);
            ELMVEC(M0, M, 0, U, C, BETA[I] × HI)
         <u>end</u>;
      T2 ≔ T; K ≔ K + 1;
      <u>if</u> LAST <u>then</u>
      <u>begin</u> LAST ≔ <u>false</u>; T ≔ TE; START ≔ <u>true</u>
      <u>end</u> <u>else</u> T ≔ T + H;
      DUPVEC(M0, M, 0, C, U);
      DERIVATIVE(1, C);
      LOCALERRORCONSTRUCTION(4);
      OUTPUT;
   <u>end</u>;

   START ≔ <u>true</u>; LAST ≔ <u>false</u>;
   DUPVEC(M0, M, 0, C, U);
   DERIVATIVE(1, C);
   <u>if</u> K = 0 <u>then</u>
   <u>begin</u> LOCAL ERROR BOUND; HSTART ≔ ETA/NORMFUNCTION(NORM, C)
   <u>end</u>;
   NEXT LEVEL:
   DIFFERENCE SCHEME;
   <u>if</u> T ≠ TE <u>then</u> <u>goto</u> NEXT LEVEL;
   ENDOFEFT:
<u>end</u> EXPONENTIAL FITTED TAYLOR;
<u>comment</u> ================== 33012 ================= ;
<u>procedure</u> RK2(X, A, B, Y, YA, Z, ZA, FXYZ, E, D, FI);
   <u>value</u> B, FI; <u>real</u> X, A, B, Y, YA, Z, ZA, FXYZ; <u>Boolean</u> FI;
     <u>array</u> E, D;
<u>begin</u> <u>real</u> E1, E2, E3, E4, XL, YL, ZL, H, INT, HMIN, HL,
     ABSH, K0, K1, K2, K3, K4, K5, DISCRY, DISCRZ, TOLY,
     TOLZ, MU, MU1, FHY, FHZ;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ A; D[4] ≔ YA; D[5] ≔ ZA <u>end</u>;
   D[1] ≔ 0; XL ≔ D[3]; YL ≔ D[4]; ZL ≔ D[5];
   <u>if</u> FI <u>then</u> D[2] ≔ B - D[3]; ABSH ≔ H ≔ ABS(D[2]);
   <u>if</u> B - XL &lt; 0 <u>then</u> H ≔ - H; INT ≔ ABS(B - XL);
   HMIN ≔ INT × E[1] + E[2]; HL ≔ INT × E[3] + E[4];
   <u>if</u> HL &lt; HMIN <u>then</u> HMIN ≔ HL; E1 ≔ E[1] / INT;
   E2 ≔ E[2] / INT; E3 ≔ E[3] / INT; E4 ≔ E[4] / INT;
   FIRST ≔ <u>true</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN; ABSH ≔ HMIN
   <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; B - XL ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> D[2] ≔ H; LAST ≔ <u>true</u>; H ≔ B - XL;
      ABSH ≔ ABS(H)
   <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: X ≔ XL; Y ≔ YL; Z ≔ ZL; K0 ≔ FXYZ × H;
   X ≔ XL + H / 4·5;
   Y ≔ YL + (ZL × 18 + K0 × 2) / 81 × H;
   Z ≔ ZL + K0 / 4·5  ; K1 ≔ FXYZ × H; X ≔ XL + H / 3;
   Y ≔ YL + (ZL × 6 + K0) / 18 × H;
   Z ≔ ZL + (K0 + K1 × 3) / 12; K2 ≔ FXYZ × H;
   X ≔ XL + H × ·5;
   Y ≔ YL + (ZL × 8 + K0 + K2) / 16 × H;
   Z ≔ ZL + (K0 + K2 × 3) / 8; K3 ≔ FXYZ × H;
   X ≔ XL + H × ·8;
   Y ≔ YL + (ZL × 100 + K0 × 12 + K3 × 28) / 125 × H;
   Z ≔ ZL + (K0 × 53 - K1 × 135 + K2 × 126 + K3 × 56)
     / 125; K4 ≔ FXYZ × H; X ≔ <u>if</u> LAST <u>then</u> B <u>else</u> XL + H;
   Y ≔ YL + (ZL × 336 + K0 × 21 + K2 × 92 + K4 × 55) /
     336 × H;
   Z ≔ ZL + (K0 × 133 - K1 × 378 + K2 × 276 + K3 × 112
     + K4 × 25) / 168; K5 ≔ FXYZ × H;
   DISCRY ≔ ABS(( - K0 × 21 + K2 × 108 - K3 × 112 + K4× 25) / 56 × H);
   DISCRZ ≔ ABS(K0 × 21 - K2 × 162 + K3 × 224 - K4 ×
     125 + K5 × 42) / 14;
   TOLY ≔ ABSH × (ABS(ZL) × E1 + E2);
   TOLZ ≔ ABS(K0) × E3 + ABSH × E4;
   REJECT ≔ DISCRY &gt; TOLY ∨ DISCRZ &gt; TOLZ;
   FHY ≔ DISCRY / TOLY; FHZ ≔ DISCRZ / TOLZ;
   <u>if</u> FHZ &gt; FHY <u>then</u> FHY ≔ FHZ;
   MU ≔ 1 / (1 + FHY) + ·45; <u>if</u> REJECT <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> D[1] ≔ D[1] + 1; Y ≔ YL; Z ≔ ZL;
         FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FHY ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FHY × H;
   ACC: MU1 ≔ MU;
   Y ≔ YL + (ZL × 56 + K0 × 7 + K2 × 36 - K4 × 15) / 56× HL;
   Z ≔ ZL + ( - K0 × 63 + K1 × 189 - K2 × 36 - K3 × 112
     + K4 × 50) / 28; K5 ≔ FXYZ × HL;
   Y ≔ YL + (ZL × 336 + K0 × 35 + K2 × 108 + K4 × 25)
     / 336 × HL;
   Z ≔ ZL + (K0 × 35 + K2 × 162 + K4 × 125 + K5 × 14)
     / 336;
   NEXT: <u>if</u> B ≠ X <u>then</u>
   <u>begin</u> XL ≔ X; YL ≔ Y; ZL ≔ Z; <u>goto</u> TEST <u>end</u>;
   <u>if</u> ¬LAST <u>then</u> D[2] ≔ H; D[3] ≔ X; D[4] ≔ Y; D[5] ≔ Z
<u>end</u> RK2;
<u>comment</u> ================== 33013 ================= ;
<u>procedure</u> RK2N(X, A, B, Y, YA, Z, ZA, FXYZJ, J, E, D,
  FI, N); <u>value</u> B, FI, N; <u>integer</u> J, N; <u>real</u> X, A, B, FXYZJ;
     <u>Boolean</u> FI; <u>array</u> Y, YA, Z, ZA, E, D;
<u>begin</u> <u>integer</u> JJ;
   <u>real</u> XL, H, INT, HMIN, HL, ABSH, FHM, DISCRY, DISCRZ,
     TOLY, TOLZ, MU, MU1, FHY, FHZ;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>array</u> YL, ZL, K0, K1, K2, K3, K4, K5[1:N], EE[1:4 ×
     N];
   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ A;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> D[JJ + 3] ≔ YA[JJ]; D[N + JJ + 3] ≔ ZA[JJ]
         <u>end</u>
   <u>end</u>;
   D[1] ≔ 0; XL ≔ D[3];
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> YL[JJ] ≔ D[JJ + 3]; ZL[JJ] ≔ D[N + JJ + 3] <u>end</u>;
   <u>if</u> FI <u>then</u> D[2] ≔ B - D[3]; ABSH ≔ H ≔ ABS(D[2]);
   <u>if</u> B - XL &lt; 0 <u>then</u> H ≔ - H; INT ≔ ABS(B - XL);
   HMIN ≔ INT × E[1] + E[2];
   <u>for</u> JJ ≔ 2 <u>step</u> 1 <u>until</u> 2 × N <u>do</u>
      <u>begin</u> HL ≔ INT × E[2 × JJ - 1] + E[2 × JJ];
         <u>if</u> HL &lt; HMIN <u>then</u> HMIN ≔ HL
      <u>end</u>;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> 4 × N <u>do</u> EE[JJ] ≔ E[JJ] / INT;
   FIRST ≔ <u>true</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN;
      ABSH ≔ ABS(H)
   <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; B - XL ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> D[2] ≔ H; LAST ≔ <u>true</u>; H ≔ B - XL;
      ABSH ≔ ABS(H)
   <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: X ≔ XL;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ]; Z[JJ] ≔ ZL[JJ] <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K0[J] ≔ FXYZJ × H;
   X ≔ XL + H / 4·5;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 18 + K0[JJ] × 2) /
           81 × H; Z[JJ] ≔ ZL[JJ] + K0[JJ] / 4·5;
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K1[J] ≔ FXYZJ × H;
   X ≔ XL + H / 3;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 6 + K0[JJ]) / 18 × H;
         Z[JJ] ≔ ZL[JJ] + (K0[JJ] + K1[JJ] × 3) / 12
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K2[J] ≔ FXYZJ × H;
   X ≔ XL + H × ·5;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 8 + K0[JJ] + K2[JJ])
           / 16 × H;
         Z[JJ] ≔ ZL[JJ] + (K0[JJ] + K2[JJ] × 3) / 8
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K3[J] ≔ FXYZJ × H;
   X ≔ XL + H × ·8;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 100 + K0[JJ] × 12 +
           K3[JJ] × 28) / 125 × H;
         Z[JJ] ≔ ZL[JJ] + (K0[JJ] × 53 - K1[JJ] × 135 +
           K2[JJ] × 126 + K3[JJ] × 56) / 125
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K4[J] ≔ FXYZJ × H;
   X ≔ <u>if</u> LAST <u>then</u> B <u>else</u> XL + H;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 336 + K0[JJ] × 21 +
           K2[JJ] × 92 + K4[JJ] × 55) / 336 × H;
         Z[JJ] ≔ ZL[JJ] + (K0[JJ] × 133 - K1[JJ] × 378 +
           K2[JJ] × 276 + K3[JJ] × 112 + K4[JJ] × 25) / 168
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K5[J] ≔ FXYZJ × H;
   REJECT ≔ <u>false</u>; FHM ≔ 0;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> DISCRY ≔ ABS(( - K0[JJ] × 21 + K2[JJ] × 108 -
           K3[JJ] × 112 + K4[JJ] × 25) / 56 × H);
         DISCRZ ≔ ABS(K0[JJ] × 21 - K2[JJ] × 162 + K3[JJ]× 224 - K4[JJ] × 125 + K5[JJ] × 42) / 14;
         TOLY ≔ ABSH × (ABS(ZL[JJ]) × EE[2 × JJ - 1] +
           EE[2 × JJ]);
         TOLZ ≔ ABS(K0[JJ]) × EE[2 × (JJ + N) - 1] + ABSH× EE[2 × (JJ + N)];
         REJECT ≔ DISCRY &gt; TOLY ∨ DISCRZ &gt; TOLZ ∨ REJECT;
         FHY ≔ DISCRY / TOLY; FHZ ≔ DISCRZ / TOLZ;
         <u>if</u> FHZ &gt; FHY <u>then</u> FHY ≔ FHZ;
         <u>if</u> FHY &gt; FHM <u>then</u> FHM ≔ FHY
      <u>end</u>;
   MU ≔ 1 / (1 + FHM) + ·45; <u>if</u> REJECT <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> D[1] ≔ D[1] + 1;
         <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> Y[JJ] ≔ YL[JJ]; Z[JJ] ≔ ZL[JJ] <u>end</u>;
         FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FHM ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FHM × H;
   ACC: MU1 ≔ MU;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 56 + K0[JJ] × 7 +
           K2[JJ] × 36 - K4[JJ] × 15) / 56 × HL;
         Z[JJ] ≔ ZL[JJ] + ( - K0[JJ] × 63 + K1[JJ] × 189
           - K2[JJ] × 36 - K3[JJ] × 112 + K4[JJ] × 50) / 28
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K5[J] ≔ FXYZJ × HL;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ] × 336 + K0[JJ] × 35 +
           K2[JJ] × 108 + K4[JJ] × 25) / 336 × HL;
         Z[JJ] ≔ ZL[JJ] + (K0[JJ] × 35 + K2[JJ] × 162 +
           K4[JJ] × 125 + K5[JJ] × 14) / 336
      <u>end</u>;
   NEXT: <u>if</u> B ≠ X <u>then</u>
   <u>begin</u> XL ≔ X;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> YL[JJ] ≔ Y[JJ]; ZL[JJ] ≔ Z[JJ] <u>end</u>;
      <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> ¬LAST <u>then</u> D[2] ≔ H; D[3] ≔ X;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> D[JJ + 3] ≔ Y[JJ]; D[N + JJ + 3] ≔ Z[JJ] <u>end</u>
<u>end</u> RK2N;
<u>comment</u> ================== 33014 ================= ;
<u>procedure</u> RK3(X, A, B, Y, YA, Z, ZA, FXY, E, D, FI);
   <u>value</u> B, FI; <u>real</u> X, A, B, Y, YA, Z, ZA, FXY; <u>Boolean</u> FI;
     <u>array</u> E, D;
<u>begin</u> <u>real</u> E1, E2, E3, E4, XL, YL, ZL, H, INT, HMIN, HL,
     ABSH, K0, K1, K2, K3, K4, K5, DISCRY, DISCRZ, TOLY,
     TOLZ, MU, MU1, FHY, FHZ;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ A; D[4] ≔ YA; D[5] ≔ ZA <u>end</u>;
   D[1] ≔ 0; XL ≔ D[3]; YL ≔ D[4]; ZL ≔ D[5];
   <u>if</u> FI <u>then</u> D[2] ≔ B - D[3]; ABSH ≔ H ≔ ABS(D[2]);
   <u>if</u> B - XL &lt; 0 <u>then</u> H ≔ - H; INT ≔ ABS(B - XL);
   HMIN ≔ INT × E[1] + E[2]; HL ≔ INT × E[3] + E[4];
   <u>if</u> HL &lt; HMIN <u>then</u> HMIN ≔ HL; E1 ≔ E[1] / INT;
   E2 ≔ E[2] / INT; E3 ≔ E[3] / INT; E4 ≔ E[4] / INT;
   FIRST ≔ REJECT ≔ <u>true</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN; ABSH ≔ HMIN
   <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; B - XL ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> D[2] ≔ H; LAST ≔ <u>true</u>; H ≔ B - XL;
      ABSH ≔ ABS(H)
   <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: <u>if</u> REJECT <u>then</u>
   <u>begin</u> X ≔ XL; Y ≔ YL; K0 ≔ FXY × H <u>end</u>
   <u>else</u> K0 ≔ K5 × H / HL; X ≔ XL + ·276393202250021 × H;
   Y ≔ YL + (ZL × ·2763932022 50021 + K0 ×·038196601125011) × H; K1 ≔ FXY × H;
   X ≔ XL + ·72360 6797749979 × H;
   Y ≔ YL + (ZL × ·723606797749979 + K1 × ·26180
     3398874989) × H; K2 ≔ FXY × H; X ≔ XL + H × ·5;
   Y ≔ YL + (ZL × ·5 + K0 × ·046875 + K1 ×·079824155839840 - K2 × ·001699155839840) × H;
   K4 ≔ FXY × H; X ≔ <u>if</u> LAST <u>then</u> B <u>else</u> XL + H;
   Y ≔ YL + (ZL + K0 × ·309016994374947 + K2 ×·190983005625053) × H; K3 ≔ FXY × H;
   Y ≔ YL + (ZL + K0 × ·083333333333333 + K1 ×·301502832395825 + K2 × ·115163834270842) × H;
   K5 ≔ FXY × H;
   DISCRY ≔ ABS(( - K0 × ·5 + K1 × 1·809016994374947 +
     K2 × ·690983005625053 - K4 × 2) × H);
   DISCRZ ≔ ABS((K0 - K3) × 2 - (K1 + K2) × 10 + K4 ×
     16 + K5 × 4); TOLY ≔ ABSH × (ABS(ZL) × E1 + E2);
   TOLZ ≔ ABS(K0) × E3 + ABSH × E4;
   REJECT ≔ DISCRY &gt; TOLY ∨ DISCRZ &gt; TOLZ;
   FHY ≔ DISCRY / TOLY; FHZ ≔ DISCRZ / TOLZ;
   <u>if</u> FHZ &gt; FHY <u>then</u> FHY ≔ FHZ;
   MU ≔ 1 / (1 + FHY) + ·45; <u>if</u> REJECT <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> D[1] ≔ D[1] + 1; Y ≔ YL; Z ≔ ZL;
         FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FHY ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FHY × H;
   ACC: MU1 ≔ MU;
   Z ≔ ZL + (K0 + K3) × ·083333333333333 + (K1 + K2) ×·416666666666667;
   NEXT: <u>if</u> B ≠ X <u>then</u>
   <u>begin</u> XL ≔ X; YL ≔ Y; ZL ≔ Z; <u>goto</u> TEST <u>end</u>;
   <u>if</u> ¬LAST <u>then</u> D[2] ≔ H; D[3] ≔ X; D[4] ≔ Y; D[5] ≔ Z
<u>end</u> RK3;
<u>comment</u> ================== 33015 ================= ;
<u>procedure</u> RK3N(X, A, B, Y, YA, Z, ZA, FXYJ, J, E, D,
  FI, N); <u>value</u> B, FI, N; <u>integer</u> J, N; <u>real</u> X, A, B, FXYJ;
     <u>Boolean</u> FI; <u>array</u> Y, YA, Z, ZA, E, D;
<u>begin</u> <u>integer</u> JJ;
   <u>real</u> XL, H, HMIN, INT, HL, ABSH, FHM, DISCRY, DISCRZ,
     TOLY, TOLZ, MU, MU1, FHY, FHZ;
   <u>Boolean</u> LAST, FIRST, REJECT;
   <u>array</u> YL, ZL, K0, K1, K2, K3, K4, K5[1:N], EE[1:4 ×
     N];
   <u>if</u> FI <u>then</u>
   <u>begin</u> D[3] ≔ A;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> D[JJ + 3] ≔ YA[JJ]; D[N + JJ + 3] ≔ ZA[JJ]
         <u>end</u>
   <u>end</u>;
   D[1] ≔ 0; XL ≔ D[3];
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> YL[JJ] ≔ D[JJ + 3]; ZL[JJ] ≔ D[N + JJ + 3] <u>end</u>;
   <u>if</u> FI <u>then</u> D[2] ≔ B - D[3]; ABSH ≔ H ≔ ABS(D[2]);
   <u>if</u> B - XL &lt; 0 <u>then</u> H ≔ - H; INT ≔ ABS(B - XL);
   HMIN ≔ INT × E[1] + E[2];
   <u>for</u> JJ ≔ 2 <u>step</u> 1 <u>until</u> 2 × N <u>do</u>
      <u>begin</u> HL ≔ INT × E[2 × JJ - 1] + E[2 × JJ];
         <u>if</u> HL &lt; HMIN <u>then</u> HMIN ≔ HL
      <u>end</u>;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> 4 × N <u>do</u> EE[JJ] ≔ E[JJ] / INT;
   FIRST ≔ REJECT ≔ <u>true</u>; <u>if</u> FI <u>then</u>
   <u>begin</u> LAST ≔ <u>true</u>; <u>goto</u> STEP <u>end</u>;
   TEST: ABSH ≔ ABS(H); <u>if</u> ABSH &lt; HMIN <u>then</u>
   <u>begin</u> H ≔ <u>if</u> H &gt; 0 <u>then</u> HMIN <u>else</u> - HMIN; ABSH ≔ HMIN
   <u>end</u>;
   <u>if</u> H &GreaterSlantEqual; B - XL ≡ H &GreaterSlantEqual; 0 <u>then</u>
   <u>begin</u> D[2] ≔ H; LAST ≔ <u>true</u>; H ≔ B - XL;
      ABSH ≔ ABS(H)
   <u>end</u>
   <u>else</u> LAST ≔ <u>false</u>;
   STEP: <u>if</u> REJECT <u>then</u>
   <u>begin</u> X ≔ XL;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ];
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K0[J] ≔ FXYJ × H
   <u>end</u>
   <u>else</u>
   <u>begin</u> FHY ≔ H / HL;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K0[JJ] ≔ K5[JJ] × FHY
   <u>end</u>;
   X ≔ XL + ·27639 3202250021 × H;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ]× ·276393202250021 + K0[JJ] × ·038196601125011) × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K1[J] ≔ FXYJ × H;
   X ≔ XL + ·723606797749979 × H;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ]× ·723606797749979 + K1[JJ] × ·261803398874989) × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K2[J] ≔ FXYJ × H;
   X ≔ XL + H × ·5;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ]× ·5 + K0[JJ] × ·046875 + K1[JJ] × ·079824155839840
        - K2[JJ] × ·00169 9155839840) × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K4[J] ≔ FXYJ × H;
   X ≔ <u>if</u> LAST <u>then</u> B <u>else</u> XL + H;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ]
        + K0[JJ] × ·309016994374947 + K2[JJ] ×·190983005625053) × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K3[J] ≔ FXYJ × H;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Y[JJ] ≔ YL[JJ] + (ZL[JJ]
        + K0[JJ] × ·083333333333333 + K1[JJ] × ·30150
        2832395825 + K2[JJ] × ·115163834270842) × H;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> K5[J] ≔ FXYJ × H;
   REJECT ≔ <u>false</u>; FHM ≔ 0;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> DISCRY ≔ ABS(( - K0[JJ] × ·5 + K1[JJ] ×
           1·809016994374947 + K2[JJ] × ·690983005625053 -
           K4[JJ] × 2) × H);
         DISCRZ ≔ ABS((K0[JJ] - K3[JJ]) × 2 - (K1[JJ] +
           K2[JJ]) × 10 + K4[JJ] × 16 + K5[JJ] × 4);
         TOLY ≔ ABSH × (ABS(ZL[JJ]) × EE[2 × JJ - 1] +
           EE[2 × JJ]);
         TOLZ ≔ ABS(K0[JJ]) × EE[2 × (JJ + N) - 1] + ABSH× EE[2 × (JJ + N)];
         REJECT ≔ DISCRY &gt; TOLY ∨ DISCRZ &gt; TOLZ ∨ REJECT;
         FHY ≔ DISCRY / TOLY; FHZ ≔ DISCRZ / TOLZ;
         <u>if</u> FHZ &gt; FHY <u>then</u> FHY ≔ FHZ;
         <u>if</u> FHY &gt; FHM <u>then</u> FHM ≔ FHY
      <u>end</u>;
   MU ≔ 1 / (1 + FHM) + ·45; <u>if</u> REJECT <u>then</u>
   <u>begin</u> <u>if</u> ABSH &LessSlantEqual; HMIN <u>then</u>
      <u>begin</u> D[1] ≔ D[1] + 1;
         <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> Y[JJ] ≔ YL[JJ]; Z[JJ] ≔ ZL[JJ] <u>end</u>;
         FIRST ≔ <u>true</u>; <u>goto</u> NEXT
      <u>end</u>;
      H ≔ MU × H; <u>goto</u> TEST
   <u>end</u> REJ;
   <u>if</u> FIRST <u>then</u>
   <u>begin</u> FIRST ≔ <u>false</u>; HL ≔ H; H ≔ MU × H; <u>goto</u> ACC
   <u>end</u>;
   FHY ≔ MU × H / HL + MU - MU1; HL ≔ H; H ≔ FHY × H;
   ACC: MU1 ≔ MU;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Z[JJ] ≔ ZL[JJ] + (K0[JJ]
        + K3[JJ]) × ·083333333333333 + (K1[JJ] + K2[JJ]) ×·416666666666667;
   NEXT: <u>if</u> B ≠ X <u>then</u>
   <u>begin</u> XL ≔ X;
      <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> YL[JJ] ≔ Y[JJ]; ZL[JJ] ≔ Z[JJ] <u>end</u>;
      <u>goto</u> TEST
   <u>end</u>;
   <u>if</u> ¬LAST <u>then</u> D[2] ≔ H; D[3] ≔ X;
   <u>for</u> JJ ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> D[JJ + 3] ≔ Y[JJ]; D[N + JJ + 3] ≔ Z[JJ] <u>end</u>
<u>end</u> RK3N;
<u>comment</u> ================== 35120 ================= ;
<u>real</u> <u>procedure</u> TAN(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> U;
   <u>Boolean</u> <u>procedure</u> OVERFLOW(X); <u>code</u> 30009;
   <u>real</u>    <u>procedure</u> GIANT;       <u>code</u> 30004;
   U ≔ SIN(X)/COS(X);
   TAN ≔ <u>if</u> OVERFLOW(U) <u>then</u> GIANT <u>else</u> U
<u>end</u> TAN;
<u>comment</u> ================== 35111 ================= ;
<u>real</u> <u>procedure</u> SINH(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> AX, Y;
   AX ≔ ABS(X);
   <u>if</u> AX &lt; 0·3 <u>then</u>
   <u>begin</u> Y ≔ <u>if</u> AX &lt; 0·1 <u>then</u> X × X <u>else</u> X × X/9;
      X ≔  ((( 0·0001984540     × Y +
        0·0083333331783 ) × Y +
        0·16666666666675) × Y +
        1·0             ) × X ;
      SINH ≔ <u>if</u> AX &lt; 0·1 <u>then</u> X <u>else</u>
        X × ( 1·0 + 0·14814814814815 × X × X )
   <u>end</u> <u>else</u> <u>if</u> AX &lt; 17·5 <u>then</u>
   <u>begin</u> AX ≔ EXP( AX ); SINH ≔ SIGN(X) × ·5 × ( AX -1/AX ) <u>end</u>
     <u>else</u> <u>if</u> AX &gt; 742·36063037970 <u>then</u>
   <u>begin</u> <u>real</u> <u>procedure</u> GIANT; <u>code</u> 30004;
      SINH ≔ SIGN(X) × GIANT
   <u>end</u> <u>else</u>
     SINH ≔ SIGN(X) × EXP(AX- ·69314 71805 59945)
<u>end</u> SINH;
<u>comment</u> ================== 35115 ================= ;
<u>real</u> <u>procedure</u> ARCCOSH(X); <u>value</u> X; <u>real</u> X;
   ARCCOSH ≔ <u>if</u> X &LessSlantEqual; 1 <u>then</u> 0 <u>else</u>
     <u>if</u> X &gt; &#9192;10 <u>then</u> 0·69314718055995 + LN(X) <u>else</u>
     LN(X + SQRT((X-1) × (X + 1)));
<u>comment</u> ================== 35080 ================= ;
<u>real</u> <u>procedure</u> EI(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> <u>array</u> P, Q[0:7];
   <u>real</u> <u>procedure</u> CHEPOLSER(N, X, A); <u>code</u> 31046;
   <u>real</u> <u>procedure</u> POL(N, X, A); <u>code</u> 31040;
   <u>real</u> <u>procedure</u> JFRAC(N, A, B); <u>code</u> 35083;

   <u>if</u> X &gt; 24 <u>then</u>
   <u>begin</u> P[0] ≔ + 1·00000000000058   ; Q[1] ≔ 1·99999999924131   ;
      P[1] ≔ X-3·00000016782085   ; Q[2] ≔ -2·99996432944446   ;
      P[2] ≔ X-5·00140345515924   ; Q[3] ≔ -7·90404992298926   ;
      P[3] ≔ X-7·49289167792884   ; Q[4] ≔ -4·31325836146628   ;
      P[4] ≔ X-3·08336269051763&#9192;+1; Q[5] ≔ 2·95999399486831&#9192;+2;
      P[5] ≔ X-1·39381360364405   ; Q[6] ≔ -6·74704580465832   ;
      P[6] ≔ X + 8·91263822573708   ; Q[7] ≔ 1·04745362652468&#9192;+3;
      P[7] ≔ X-5·31686623494482&#9192;+1;
      EI ≔ EXP(X) × (1 + JFRAC(7, Q, P)/X)/X
   <u>end</u> <u>else</u> <u>if</u> X &gt; 12 <u>then</u>
   <u>begin</u> P[0] ≔ + 9·99994296074708&#9192;-1; Q[1] ≔ 1·00083867402639   ;
      P[1] ≔ X-1·95022321289660   ; Q[2] ≔ -3·43942266899870   ;
      P[2] ≔ X + 1·75656315469614   ; Q[3] ≔ 2·89516727925135&#9192;+1;
      P[3] ≔ X + 1·79601688769252&#9192;+1; Q[4] ≔ 7·60761148007735&#9192;+2;
      P[4] ≔ X-3·23467330305403&#9192;+1; Q[5] ≔ 2·57776384238440&#9192;+1;
      P[5] ≔ X-8·28561994140641   ; Q[6] ≔ 5·72837193837324&#9192;+1;
      P[6] ≔ X-1·86545454883399&#9192;+1; Q[7] ≔ 6·95000655887434&#9192;+1;
      P[7] ≔ X-3·48334653602853   ;
      EI ≔ EXP(X) × JFRAC(7, Q, P)/X
   <u>end</u> <u>else</u> <u>if</u> X &gt; 6 <u>then</u>
   <u>begin</u> P[0] ≔ + 1·00443109228078   ; Q[1] ≔ 5·27468851962908&#9192;-1;
      P[1] ≔ X-4·32531132878135&#9192;+1; Q[2] ≔ 2·73624119889328&#9192;+3;
      P[2] ≔ X + 6·01217990830080&#9192;+1; Q[3] ≔ 1·43256738121938&#9192;+1;
      P[3] ≔ X-3·31842531997221&#9192;+1; Q[4] ≔ 1·00367439516726&#9192;+3;
      P[4] ≔ X + 2·50762811293560&#9192;+1; Q[5] ≔ -6·25041161671876   ;
      P[5] ≔ X + 9·30816385662165   ; Q[6] ≔ 3·00892648372915&#9192;+2;
      P[6] ≔ X-2·19010233854880&#9192;+1; Q[7] ≔ 3·93707701852715  ;
      P[7] ≔ X-2·18086381520724   ;
      EI ≔ EXP(X) × JFRAC(7, Q, P)/X
   <u>end</u> <u>else</u> <u>if</u> X &gt; 0 <u>then</u>
   <u>begin</u> <u>real</u> T, R, X0, XMX0;
      P[0] ≔ -1·95773036904548&#9192;+8; Q[0] ≔ -8·26271498626055&#9192;+7;
      P[1] ≔ 3·89280421311201&#9192;+6; Q[1] ≔ 8·91925767575612&#9192;+7;
      P[2] ≔ -2·21744627758845&#9192;+7; Q[2] ≔ -2·49033375740540&#9192;+7;
      P[3] ≔ -1·19623669349247&#9192;+5; Q[3] ≔ 4·28559624611749&#9192;+6;
      P[4] ≔ -2·49301393458648&#9192;+5; Q[4] ≔ -4·83547436162164&#9192;+5;
      P[5] ≔ -4·21001615357070&#9192;+3; Q[5] ≔ 3·57300298058508&#9192;+4;
      P[6] ≔ -5·49142265521085&#9192;+2; Q[6] ≔ -1·60708926587221&#9192;+3;
      P[7] ≔ -8·66937339951070   ; Q[7] ≔ 3·41718750000000&#9192;+1;
      X0 ≔ ·372507410781367;
      T ≔ X/3-1;
      R ≔ CHEPOLSER(7, T, P)/CHEPOLSER(7, T, Q);
      XMX0 ≔ (X-409576229586/1099511627776)-·767177250199394&#9192;-12;
      <u>if</u> ABS(XMX0) &gt; ·037 <u>then</u> T ≔ LN(X/X0) <u>else</u>
      <u>begin</u> <u>real</u> Z, Z2;
         P[0] ≔ ·837207933976075&#9192;+1; Q[0] ≔ ·418603966988037&#9192;+1;
         P[1] ≔ -·652268740837103&#9192;+1; Q[1] ≔ -·465669026080814&#9192;+1;
         P[2] ≔ ·569955700306720   ; Q[2] ≔ ·1&#9192;+1;
         Z ≔ XMX0/(X + X0); Z2 ≔ Z × Z;
         T ≔ Z × POL(2, Z2, P)/POL(2, Z2, Q)
      <u>end</u>;
      EI ≔ T + XMX0 × R
   <u>end</u> <u>else</u>
   <u>if</u> X &gt; -1 <u>then</u>
   <u>begin</u> <u>real</u> Y;
      P[0] ≔ -4·41785471728217&#9192;+4; Q[0] ≔ 7·65373323337614&#9192;+4;
      P[1] ≔ 5·77217247139444&#9192;+4; Q[1] ≔ 3·25971881290275&#9192;+4;
      P[2] ≔ 9·93831388962037&#9192;+3; Q[2] ≔ 6·10610794245759&#9192;+3;
      P[3] ≔ 1·84211088668000&#9192;+3; Q[3] ≔ 6·35419418378382&#9192;+2;
      P[4] ≔ 1·01093806161906&#9192;+2; Q[4] ≔ 3·72298352833327&#9192;+1;
      P[5] ≔ 5·03416184097568   ; Q[5] ≔ 1;
      Y ≔ -X;
      EI ≔ LN(Y)-POL(5, Y, P)/POL(5, Y, Q)
   <u>end</u> <u>else</u> <u>if</u> X &gt; -4 <u>then</u>
   <u>begin</u> <u>real</u> Y;
      P[0] ≔ 8·67745954838444&#9192;-8; Q[0] ≔ 1;
      P[1] ≔ 9·99995519301390&#9192;-1; Q[1] ≔ 1·28481935379157&#9192;+1;
      P[2] ≔ 1·18483105554946&#9192;+1; Q[2] ≔ 5·64433569561803&#9192;+1;
      P[3] ≔ 4·55930644253390&#9192;+1; Q[3] ≔ 1·06645183769914&#9192;+2;
      P[4] ≔ 6·99279451291003&#9192;+1; Q[4] ≔ 8·97311097125290&#9192;+1;
      P[5] ≔ 4·25202034768841&#9192;+1; Q[5] ≔ 3·14971849170441&#9192;+1;
      P[6] ≔ 8·83671808803844   ; Q[6] ≔ 3·79559003762122   ;
      P[7] ≔ 4·01377664940665&#9192;-1; Q[7] ≔ 9·08804569188869&#9192;-2;
      Y ≔ -1/X;
      EI ≔ -EXP(X) × POL(7, Y, P)/POL(7, Y, Q)
   <u>end</u> <u>else</u>
   <u>begin</u> <u>real</u> Y;
      P[0] ≔ -9·99999999998447&#9192;-1; Q[0] ≔ 1;
      P[1] ≔ -2·66271060431811&#9192;+1; Q[1] ≔ 2·86271060422192&#9192;+1;
      P[2] ≔ -2·41055827097015&#9192;+2; Q[2] ≔ 2·92310039388533&#9192;+2;
      P[3] ≔ -8·95927957772937&#9192;+2; Q[3] ≔ 1·33278537748257&#9192;+3;
      P[4] ≔ -1·29885688746484&#9192;+3; Q[4] ≔ 2·77761949509163&#9192;+3;
      P[5] ≔ -5·45374158883133&#9192;+2; Q[5] ≔ 2·40401713225909&#9192;+3;
      P[6] ≔ -5·66575206533869   ; Q[6] ≔ 6·31657483280800&#9192;+2;
      Y ≔ -1/X;
      EI ≔ -EXP(X) × Y × (1 + Y × POL(6, Y, P)/POL(6, Y, Q))
   <u>end</u>
<u>end</u> EI;
<u>comment</u> ================== 35086 ================= ;
<u>procedure</u> ENX(X, N1, N2, A);
   <u>value</u> X, N1, N2;
   <u>real</u> X; <u>integer</u> N1, N2; <u>array</u> A;
   <u>if</u> X &LessSlantEqual; 1·5 <u>then</u>
   <u>begin</u>
      <u>real</u> <u>procedure</u> EI(X); <u>code</u> 35080;
      <u>real</u> W, E; <u>integer</u> I;
      W ≔ -EI(-X);
      <u>if</u> N1 = 1 <u>then</u> A[1] ≔ W;
      <u>if</u> N2 &gt; 1 <u>then</u> E ≔ EXP(-X);
      <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N2 <u>do</u>
         <u>begin</u>
            W ≔ (E - X × W)/(I - 1);
            <u>if</u> I &GreaterSlantEqual; N1 <u>then</u> A[I] ≔ W
         <u>end</u>
   <u>end</u> <u>else</u>
   <u>begin</u> <u>integer</u> I, N; <u>real</u> W, E, AN;
      N ≔ ENTIER(X + ·5);
      <u>if</u> N &LessSlantEqual; 10 <u>then</u>
      <u>begin</u> <u>real</u> F, W1, T, H;
         <u>real</u> <u>array</u> P[2:19];
         P[ 2] ≔ ·37534261820491&#9192;-1; P[11] ≔ ·135335283236613   ;
         P[ 3] ≔ ·89306465560228&#9192;-2; P[12] ≔ ·497870683678639&#9192;-1;
         P[ 4] ≔ ·24233983686581&#9192;-2; P[13] ≔ ·183156388887342&#9192;-1;
         P[ 5] ≔ ·70576069342458&#9192;-3; P[14] ≔ ·673794699908547&#9192;-2;
         P[ 6] ≔ ·21480277819013&#9192;-3; P[15] ≔ ·247875217666636&#9192;-2;
         P[ 7] ≔ ·67375807781018&#9192;-4; P[16] ≔ ·911881965554516&#9192;-3;
         P[ 8] ≔ ·21600730159975&#9192;-4; P[17] ≔ ·335462627902512&#9192;-3;
         P[ 9] ≔ ·70411579854292&#9192;-5; P[18] ≔ ·123409804086680&#9192;-3;
         P[10] ≔ ·23253026570282&#9192;-5; P[19] ≔ ·453999297624848&#9192;-4;
         F ≔ W ≔ P[N];
         E ≔ P[N + 9];
         W1 ≔ T ≔ 1;
         H ≔ X-N;
         <u>for</u> I ≔ N-1, I-1 <u>while</u> ABS(W1) &gt; &#9192;-15 × W <u>do</u>
            <u>begin</u>
               F ≔ (E - I × F)/N;
               T ≔ -H × T / (N-I);
               W1 ≔ T × F; W ≔ W + W1
            <u>end</u>
      <u>end</u> <u>else</u>
      <u>begin</u>
         <u>procedure</u> NONEXPENX(X, N1, N2, A); <u>code</u> 35087;
         <u>array</u> B[N:N];
         NONEXPENX(X, N, N, B);
         W ≔ B[N] × EXP(-X)
      <u>end</u>;
      <u>if</u> N1 = N2 ∧ N1 = N <u>then</u> A[N] ≔ W <u>else</u>
      <u>begin</u>
         E ≔ EXP(-X);
         AN ≔ W;
         <u>if</u> N &LessSlantEqual; N2 ∧ N &GreaterSlantEqual; N1 <u>then</u> A[N] ≔ W;
         <u>for</u> I ≔ N-1 <u>step</u> -1 <u>until</u> N1 <u>do</u>
            <u>begin</u>
               W ≔ (E - I × W)/X;
               <u>if</u> I &LessSlantEqual; N2 <u>then</u> A[I] ≔ W
            <u>end</u>;
         W ≔ AN;
         <u>for</u> I ≔ N + 1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
            <u>begin</u>
               W ≔ (E - X × W)/(I - 1);
               <u>if</u> I &GreaterSlantEqual; N1 <u>then</u> A[I] ≔ W
            <u>end</u>
      <u>end</u>
   <u>end</u> ENX;
<u>comment</u> ================== 35087 ================= ;
<u>procedure</u> NONEXPENX(X, N1, N2, A);
   <u>value</u> X, N1, N2;
   <u>real</u> X; <u>integer</u> N1, N2; <u>array</u> A;
<u>begin</u> <u>integer</u> I, N; <u>real</u> W, AN;
   N ≔ <u>if</u> X &LessSlantEqual; 1·5 <u>then</u> 1 <u>else</u> ENTIER(X + ·5);
   <u>if</u> N &LessSlantEqual; 10 <u>then</u>
   <u>begin</u>
      <u>procedure</u> ENX(X, N1, N2, A); <u>code</u> 35086;
      <u>array</u> B[N:N];
      ENX(X, N, N, B);
      W ≔ B[N] × EXP(X)
   <u>end</u> <u>else</u>
   <u>begin</u>
      <u>integer</u> K, K1;
      <u>real</u> UE, VE, WE, WE1, UO, VO, WO, WO1, R, S;
      UE ≔ 1; VE ≔ WE ≔ 1/(X + N); WE1 ≔ 0;
      UO ≔ 1; VO ≔ -N/(X × (X + N + 1)); WO1 ≔ 1/X; WO ≔ VO + WO1;
      W ≔ (WE + WO)/2;
      K1 ≔ 1;
      <u>for</u> K ≔ K1 <u>while</u> WO-WE &gt; &#9192;-15 × W ∧ WE &gt; WE1 ∧ WO &lt; WO1 <u>do</u>
         <u>begin</u>
            WE1 ≔ WE; WO1 ≔ WO;
            R ≔ N + K; S ≔ R + X + K;
            UE ≔ 1/(1-K × (R-1) × UE/((S-2) × S));
            UO ≔ 1/(1-K ×  R  × UO/( S × S-1));
            VE ≔ VE × (UE-1);
            VO ≔ VO × (UO-1);
            WE ≔ WE + VE;
            WO ≔ WO + VO;
            W ≔ (WE + WO)/2;
            K1 ≔ K1 + 1
         <u>end</u>
   <u>end</u>;
   AN ≔ W;
   <u>if</u> N &LessSlantEqual; N2 ∧ N &GreaterSlantEqual; N1 <u>then</u> A[N] ≔ W;
   <u>for</u> I ≔ N-1 <u>step</u> -1 <u>until</u> N1 <u>do</u>
      <u>begin</u>
         W ≔ (1 - I × W)/X;
         <u>if</u> I &LessSlantEqual; N2 <u>then</u> A[I] ≔ W
      <u>end</u>;
   W ≔ AN;
   <u>for</u> I ≔ N + 1 <u>step</u> 1 <u>until</u> N2 <u>do</u>
      <u>begin</u>
         W ≔ (1 - X × W)/(I - 1);
         <u>if</u> I &GreaterSlantEqual; N1 <u>then</u> A[I] ≔ W
      <u>end</u>
<u>end</u> EXPENX;
<u>comment</u> ================== 35084 ================= ;
<u>procedure</u> SINCOSINT(X, SI, CI); <u>value</u> X; <u>real</u> X, SI, CI;
<u>begin</u> <u>real</u> ABSX, Z, F, G;
   <u>procedure</u> SINCOSFG(X, F, G); <u>code</u> 35085;
   <u>real</u> <u>procedure</u> CHEPOLSER(N, X, A); <u>code</u> 31046;

   ABSX ≔ ABS(X);
   <u>if</u> ABSX &LessSlantEqual; 4 <u>then</u>
   <u>begin</u> <u>real</u> <u>array</u> A[0:10]; <u>real</u> Z2;
      A[0] ≔ + 2·7368706803630&#9192;+00; A[1] ≔ -1·1106314107894&#9192;+00;
      A[2] ≔ + 1·4176562194666&#9192;-01; A[3] ≔ -1·0252652579174&#9192;-02;
      A[4] ≔ + 4·6494615619880&#9192;-04; A[5] ≔ -1·4361730896642&#9192;-05;
      A[6] ≔ + 3·2093684948229&#9192;-07; A[7] ≔ -5·4251990770162&#9192;-09;
      A[8] ≔ + 7·1776288639895&#9192;-11; A[9] ≔ -7·6335493723482&#9192;-13;
      A[10] ≔ + 6·6679958346983&#9192;-15;
      Z ≔ X / 4; Z2 ≔ Z × Z; G ≔ Z2 + Z2 - 1;
      SI ≔ Z × CHEPOLSER(10, G, A);
      A[0] ≔ + 2·9659601400727&#9192;+00; A[1] ≔ -9·4297198341830&#9192;-01;
      A[2] ≔ + 8·6110342738169&#9192;-02; A[3] ≔ -4·7776084547139&#9192;-03;
      A[4] ≔ + 1·7529161205146&#9192;-04; A[5] ≔ -4·5448727803752&#9192;-06;
      A[6] ≔ + 8·7515839180060&#9192;-08; A[7] ≔ -1·2998699938109&#9192;-09;
      A[8] ≔ + 1·5338974898831&#9192;-11; A[9] ≔ -1·4724256070277&#9192;-13;
      A[10] ≔ + 1·1721420798429&#9192;-15;
      CI ≔ ·577215664901533 + LN(ABSX) - Z2 × CHEPOLSER(10, G, A)
   <u>end</u> <u>else</u>
   <u>begin</u> <u>real</u> CX, SX;
      SINCOSFG(X, F, G);
      CX ≔ COS(X); SX ≔ SIN(X);
      SI ≔ 1·570796326794897; <u>if</u> X &lt; 0 <u>then</u> SI ≔ -SI;
      SI ≔ SI - F × CX - G × SX;
      CI ≔ F × SX - G × CX
   <u>end</u>
<u>end</u> SINCOSINT;
<u>comment</u> ================== 35085 ================= ;
<u>procedure</u> SINCOSFG(X, F, G); <u>value</u> X; <u>real</u> X, F, G;
<u>begin</u> <u>real</u> ABSX, SI, CI;
   <u>procedure</u> SINCOSINT(X, SI, CI); <u>code</u> 35084;
   <u>real</u> <u>procedure</u> CHEPOLSER(N, X, A); <u>code</u> 31046;

   ABSX ≔ ABS(X);
   <u>if</u> ABSX &LessSlantEqual; 4 <u>then</u>
   <u>begin</u> <u>real</u> CX, SX;
      SINCOSINT(X, SI, CI);
      CX ≔ COS(X); SX ≔ SIN(X); SI ≔ SI - 1·570796326794897;
      F ≔ CI × SX - SI × CX;
      G ≔ -CI × CX - SI × SX
   <u>end</u> <u>else</u>
   <u>begin</u> <u>real</u> <u>array</u> A[0:23];
      A[0] ≔ + 9·6578828035185&#9192;-01; A[1] ≔ -4·3060837778597&#9192;-02;
      A[2] ≔ -7·3143711748104&#9192;-03; A[3] ≔ + 1·4705235789868&#9192;-03;
      A[4] ≔ -9·8657685732702&#9192;-05; A[5] ≔ -2·2743202204655&#9192;-05;
      A[6] ≔ + 9·8240257322526&#9192;-06; A[7] ≔ -1·8973430148713&#9192;-06;
      A[8] ≔ + 1·0063435941558&#9192;-07; A[9] ≔ + 8·0819364822241&#9192;-08;
      A[10] ≔ -3·8976282875288&#9192;-08; A[11] ≔ + 1·0335650325497&#9192;-08;
      A[12] ≔ -1·4104344875897&#9192;-09; A[13] ≔ -2·5232078399683&#9192;-10;
      A[14] ≔ + 2·5699831325961&#9192;-10; A[15] ≔ -1·0597889253948&#9192;-10;
      A[16] ≔ + 2·8970031570214&#9192;-11; A[17] ≔ -4·1023142563083&#9192;-12;
      A[18] ≔ -1·0437693730018&#9192;-12; A[19] ≔ + 1·0994184520547&#9192;-12;
      A[20] ≔ -5·2214239401679&#9192;-13; A[21] ≔ + 1·7469920787829&#9192;-13;
      A[22] ≔ -3·8470012979279&#9192;-14;
      F ≔ CHEPOLSER(22, 8/ABSX-1, A) / X;
      A[0] ≔ + 2·2801220638241&#9192;-01; A[1] ≔ -2·6869727411097&#9192;-02;
      A[2] ≔ -3·5107157280958&#9192;-03; A[3] ≔ + 1·2398008635186&#9192;-03;
      A[4] ≔ -1·5672945116862&#9192;-04; A[5] ≔ -1·0664141798094&#9192;-05;
      A[6] ≔ + 1·1170629343574&#9192;-05; A[7] ≔ -3·1754011655614&#9192;-06;
      A[8] ≔ + 4·4317473520398&#9192;-07; A[9] ≔ + 5·5108696874463&#9192;-08;
      A[10] ≔ -5·9243078711743&#9192;-08; A[11] ≔ + 2·2102573381555&#9192;-08;
      A[12] ≔ -5·0256827540623&#9192;-09; A[13] ≔ + 3·1519168259424&#9192;-10;
      A[14] ≔ + 3·6306990848979&#9192;-10; A[15] ≔ -2·2974764234591&#9192;-10;
      A[16] ≔ + 8·5530309424048&#9192;-11; A[17] ≔ -2·1183067724443&#9192;-11;
      A[18] ≔ + 1·7133662645092&#9192;-12; A[19] ≔ + 1·7238877517248&#9192;-12;
      A[20] ≔ -1·2930281366811&#9192;-12; A[21] ≔ + 5·7472339223731&#9192;-13;
      A[22] ≔ -1·8415468268314&#9192;-13; A[23] ≔ + 3·5937256571434&#9192;-14;
      G ≔ 4 × CHEPOLSER(23, 8/ABSX-1, A) / ABSX /ABSX
   <u>end</u>
<u>end</u> SINCOSFG;
<u>comment</u> ================== 35060 ================= ;
<u>real</u> <u>procedure</u> RECIP GAMMA(X, ODD, EVEN);
   <u>value</u> X; <u>real</u> X, ODD, EVEN;
<u>begin</u> <u>integer</u> I;
   <u>real</u> ALFA, BETA, X2;
   <u>array</u> B[1:12];
   B[ 1] ≔ -·28387 65422 76024; B[ 2] ≔ -·07685 28408 44786;
   B[ 3] ≔ + ·00170 63050 71096; B[ 4] ≔ + ·00127 19271 36655;
   B[ 5] ≔ + ·00007 63095 97586; B[ 6] ≔ -·00000 49717 36704;
   B[ 7] ≔ -·00000 08659 20800; B[ 8] ≔ -·00000 00331 26120;
   B[ 9] ≔ + ·00000 00017 45136; B[10] ≔ + ·00000 00002 42310;
   B[11] ≔ + ·00000 00000 09161; B[12] ≔ -·00000 00000 00170;
   X2 ≔ X × X × 8;
   ALFA ≔ -·00000 00000 00001; BETA ≔ 0;
   <u>for</u> I ≔ 12 <u>step</u> - 2 <u>until</u> 2 <u>do</u>
      <u>begin</u> BETA ≔ -(ALFA × 2 + BETA); ALFA ≔ - BETA × X2 - ALFA + B[I]
      <u>end</u>;
   EVEN ≔ (BETA / 2 + ALFA) × X2 - ALFA + ·92187 02936 50453;
   ALFA ≔ -·00000 00000 00034; BETA ≔ 0;
   <u>for</u> I ≔ 11 <u>step</u> - 2 <u>until</u> 1 <u>do</u>
      <u>begin</u> BETA ≔ -(ALFA × 2 + BETA); ALFA ≔ - BETA × X2 - ALFA + B[I]
      <u>end</u>;
   ODD ≔ (ALFA + BETA) × 2;
   RECIP GAMMA ≔ ODD × X + EVEN
<u>end</u> RECIP GAMMA;
<u>comment</u> ================== 35061 ================= ;
<u>real</u> <u>procedure</u> GAMMA(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> Y, S, F, G, ODD, EVEN;
   <u>Boolean</u> INV;
   <u>real</u> <u>procedure</u> RECIP GAMMA(X, ODD, EVEN);
      <u>value</u> X; <u>real</u> X, ODD, EVEN;
      <u>code</u> 35060;
   <u>real</u> <u>procedure</u> LOG GAMMA(X); <u>value</u> X; <u>real</u> X;
      <u>code</u> 35062;
   <u>if</u> X &lt; ·5 <u>then</u>
   <u>begin</u> Y ≔ X - ENTIER(X / 2) × 2; S ≔ 3·14159 26535 8979;
      <u>if</u> Y &GreaterSlantEqual; 1 <u>then</u> <u>begin</u> S ≔ - S; Y ≔ 2 - Y <u>end</u>;
      <u>if</u> Y &GreaterSlantEqual; ·5 <u>then</u> Y ≔ 1 - Y; INV ≔ <u>true</u>; X ≔ 1 - X;
      F ≔ S / SIN(3·14159 26535 8979 × Y)
   <u>end</u>
   <u>else</u> INV ≔ <u>false</u>;
   <u>if</u> X &gt; 22 <u>then</u> G ≔ EXP(LOG GAMMA(X)) <u>else</u>
   <u>begin</u> S ≔ 1;
      NEXT: <u>if</u> X &gt; 1·5 <u>then</u>
      <u>begin</u> X ≔ X - 1; S ≔ S × X; <u>goto</u> NEXT <u>end</u>;
      G ≔ S / RECIP GAMMA(1 - X, ODD, EVEN)
   <u>end</u>;
   GAMMA ≔ <u>if</u> INV <u>then</u> F / G <u>else</u> G
<u>end</u> GAMMA;
<u>comment</u> ================== 35062 ================= ;
<u>real</u> <u>procedure</u> LOG GAMMA(X); <u>value</u> X; <u>real</u> X;
   <u>if</u> X &gt; 13 <u>then</u>
   <u>begin</u> <u>real</u> R, X2;
      R ≔ 1;
      NEXT: <u>if</u> X &LessSlantEqual; 22 <u>then</u>
      <u>begin</u> R ≔ R / X; X ≔ X + 1; <u>goto</u> NEXT <u>end</u>;
      X2 ≔ - 1 / (X × X); R ≔ LN(R);
      LOG GAMMA ≔ LN(X) × (X - ·5) - X + R + ·91893 85332 04672 +
        (((·59523 80952 38095&#9192;-3  × X2 + ·79365 07936 50794&#9192;-3) × X2 +·27777 77777 77778&#9192;-2) × X2 + ·83333 33333 33333&#9192;-1) / X
   <u>end</u>
   <u>else</u>
   <u>begin</u> <u>real</u> Y, F, U0, U1, U, Z;
      <u>integer</u> I;
      <u>array</u> B[1:18];
      F ≔ 1; U0 ≔ U1 ≔ 0;
      B[ 1] ≔ -·07611 41616 704358; B[ 2] ≔ + ·00843 23249 659328;
      B[ 3] ≔ -·00107 94937 263286; B[ 4] ≔ + ·00014 90074 800369;
      B[ 5] ≔ -·00002 15123 998886; B[ 6] ≔ + ·00000 31979 329861;
      B[ 7] ≔ -·00000 04851 693012; B[ 8] ≔ + ·00000 00747 148782;
      B[ 9] ≔ -·00000 00116 382967; B[10] ≔ + ·00000 00018 294004;
      B[11] ≔ -·00000 00002 896918; B[12] ≔ + ·00000 00000 461570;
      B[13] ≔ -·00000 00000 073928; B[14] ≔ + ·00000 00000 011894;
      B[15] ≔ -·00000 00000 001921; B[16] ≔ + ·00000 00000 000311;
      B[17] ≔ -·00000 00000 000051; B[18] ≔ + ·00000 00000 000008;
      <u>if</u> X &lt; 1 <u>then</u>
      <u>begin</u> F ≔ 1 / X; X ≔ X + 1 <u>end</u>
        <u>else</u>
      NEXT: <u>if</u> X &gt; 2 <u>then</u>
      <u>begin</u> X ≔ X - 1; F ≔ F × X; <u>goto</u> NEXT <u>end</u>;
      F ≔ LN(F); Y ≔ X + X - 3; Z ≔ Y + Y;
      <u>for</u> I ≔ 18 <u>step</u> - 1 <u>until</u> 1 <u>do</u>
         <u>begin</u> U ≔ U0; U0 ≔ Z × U0 + B[I] - U1; U1 ≔ U <u>end</u>;
      LOG GAMMA ≔ (U0 × Y + ·49141 53930 29387 - U1) × (X - 1) × (X - 2)
        + F
   <u>end</u> LOG GAMMA;
<u>comment</u> ================== 35030 ================= ;
<u>procedure</u> INCOMGAM(X, A, KLGAM, GRGAM, GAM, EPS);
   <u>value</u> X, A, EPS; <u>real</u> X, A, KLGAM, GRGAM, GAM, EPS;
<u>begin</u> <u>real</u> C0, C1, C2, D0, D1, D2, X2, AX, P, Q, R, S, R1, R2, SCF;
   <u>integer</u> N;
   S ≔ EXP(-X + A × LN(X)); SCF ≔ &#9192;+300;
   <u>if</u> X &LessSlantEqual; (<u>if</u> A &lt; 3 <u>then</u> 1 <u>else</u> A) <u>then</u>
   <u>begin</u> X2 ≔ X × X; AX ≔ A × X; D0 ≔ 1; P ≔ A; C0 ≔ S;
      D1 ≔ (A + 1) × (A + 2-X); C1 ≔ ((A + 1) × (A + 2) + X) × S;
      R2 ≔ C1/D1;
      <u>for</u> N ≔ 1, N + 1 <u>while</u> ABS((R2-R1)/R2) &gt; EPS <u>do</u>
         <u>begin</u> P ≔ 2 + P; Q ≔ (P + 1) × (P × (P + 2)-AX);
            R ≔ N × (N + A) × (P + 2) × X2;
            C2 ≔ (Q × C1 + R × C0)/P; D2 ≔ (Q × D1 + R × D0)/P;
            R1 ≔ R2; R2 ≔ C2/D2;
            C0 ≔ C1; C1 ≔ C2; D0 ≔ D1; D1 ≔ D2;
            <u>if</u> ABS(C1) &gt; SCF ∨ ABS(D1) &gt; SCF <u>then</u>
            <u>begin</u> C0 ≔ C0/SCF; C1 ≔ C1/SCF;
               D0 ≔ D0/SCF; D1 ≔ D1/SCF
            <u>end</u>
         <u>end</u>; KLGAM ≔ R2/A; GRGAM ≔ GAM - KLGAM
   <u>end</u> <u>else</u>
   <u>begin</u> C0 ≔ A × S; C1 ≔ (1 + X) × C0; Q ≔ X + 2  - A;
      D0 ≔ X; D1 ≔ X × Q; R2 ≔ C1/D1;
      <u>for</u> N ≔ 1, N + 1 <u>while</u> ABS((R2-R1)/R2) &gt; EPS <u>do</u>
         <u>begin</u>     Q ≔ 2 + Q; R ≔ N × (N + 1-A);
            C2 ≔ Q × C1-R × C0; D2 ≔ Q × D1-R × D0;
            R1 ≔ R2; R2 ≔ C2/D2;
            C0 ≔ C1; C1 ≔ C2; D0 ≔ D1; D1 ≔ D2;
            <u>if</u> ABS(C1) &gt; SCF ∨ ABS(D1) &gt; SCF <u>then</u>
            <u>begin</u> C0 ≔ C0/SCF; C1 ≔ C1/SCF;
               D0 ≔ D0/SCF; D1 ≔ D1/SCF
            <u>end</u>
         <u>end</u>; GRGAM ≔ R2/A; KLGAM ≔ GAM - GRGAM
   <u>end</u>
<u>end</u> INCOMGAM;
<u>comment</u> ================== 35050 ================= ;
<u>real</u> <u>procedure</u> INCBETA(X, P, Q, EPS);
   <u>value</u> X, P, Q, EPS; <u>real</u> X, P, Q, EPS;
<u>begin</u> <u>integer</u> M, N; <u>real</u> G, F, FN, FN1, FN2, GN, GN1, GN2, DN, PQ;
   <u>Boolean</u> N EVEN, RECUR;

   <u>real</u> <u>procedure</u> GAMMA(X); <u>value</u> X; <u>real</u> X;
      <u>code</u>  35061;

   <u>if</u> X = 0 ∨ X = 1 <u>then</u> INCBETA ≔ X <u>else</u>
   <u>begin</u> <u>if</u> X &gt; ·5 <u>then</u>
      <u>begin</u> F ≔ P; P ≔ Q; Q ≔ F; X ≔ 1-X; RECUR ≔ <u>true</u> <u>end</u>
      <u>else</u> RECUR ≔ <u>false</u>;
      G ≔ FN2 ≔ 0; M ≔ 0; PQ ≔ P + Q; F ≔ FN1 ≔ GN1 ≔ GN2 ≔ 1;
      N EVEN ≔ <u>false</u>;
      <u>for</u> N ≔ 1, N + 1 <u>while</u> ABS((F-G)/F) &gt; EPS <u>do</u>
         <u>begin</u> <u>if</u> N EVEN <u>then</u>
            <u>begin</u> M ≔ M + 1; DN ≔ M × X × (Q-M)/(P + N-1)/(P + N) <u>end</u>
            <u>else</u> DN ≔ -X × (P + M) × (PQ + M)/(P + N-1)/(P + N);
            G ≔ F; FN ≔ FN1 + DN × FN2; GN ≔ GN1 + DN × GN2;
            N EVEN ≔ ¬N EVEN; F ≔ FN/GN;
            FN2 ≔ FN1; FN1 ≔ FN; GN2 ≔ GN1; GN1 ≔ GN
         <u>end</u>;
      F ≔ F × X⭡P × (1-X)⭡Q × GAMMA(P + Q)/GAMMA(P + 1)/GAMMA(Q);
      <u>if</u> RECUR <u>then</u> F ≔ 1-F;
      INCBETA ≔ F
   <u>end</u>
<u>end</u> INCBETA;
<u>comment</u> ================== 35051 ================= ;
<u>procedure</u> IBPPLUSN(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
   <u>integer</u> NMAX; <u>real</u> X, P, Q, EPS; <u>array</u> I;
<u>begin</u> <u>integer</u> N;

   <u>procedure</u> IXQFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
      <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
      <u>code</u> 35053;

   <u>procedure</u> IXPFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
      <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
      <u>code</u> 35054;

   <u>if</u> X = 0 ∨ X = 1 <u>then</u>
   <u>begin</u> <u>for</u> N ≔ 0 <u>step</u> 1 <u>until</u> NMAX <u>do</u> I[N] ≔ X <u>end</u>
   <u>else</u>
   <u>begin</u> <u>if</u> X &LessSlantEqual; ·5 <u>then</u> IXQFIX(X, P, Q, NMAX, EPS, I) <u>else</u>
      <u>begin</u> IXPFIX(1-X, Q, P, NMAX, EPS, I);
         <u>for</u> N ≔ 0 <u>step</u> 1 <u>until</u> NMAX <u>do</u> I[N] ≔ 1-I[N]
      <u>end</u>
   <u>end</u>
<u>end</u> IBPPLUSN;
<u>comment</u> ================== 35052 ================= ;
<u>procedure</u> IBQPLUSN(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
   <u>integer</u> NMAX; <u>real</u> X, P, Q, EPS; <u>array</u> I;
<u>begin</u> <u>integer</u> N;

   <u>procedure</u> IXQFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
      <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
      <u>code</u> 35053;

   <u>procedure</u> IXPFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
      <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
      <u>code</u> 35054;

   <u>if</u> X = 0 ∨ X = 1 <u>then</u>
   <u>begin</u> <u>for</u> N ≔ 0 <u>step</u> 1 <u>until</u> NMAX <u>do</u> I[N] ≔ X <u>end</u>
   <u>else</u>
   <u>begin</u> <u>if</u> X &LessSlantEqual; ·5 <u>then</u> IXPFIX(X, P, Q, NMAX, EPS, I) <u>else</u>
      <u>begin</u> IXQFIX(1-X, Q, P, NMAX, EPS, I);
         <u>for</u> N ≔ 0 <u>step</u> 1 <u>until</u> NMAX <u>do</u> I[N] ≔ 1-I[N]
      <u>end</u>
   <u>end</u>
<u>end</u> IBQPLUSN;
<u>comment</u> ================== 35053 ================= ;
<u>procedure</u> IXQFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
   <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
<u>begin</u> <u>integer</u> M, MMAX; <u>real</u> S, IQ0, IQ1, Q0;

   <u>real</u> <u>procedure</u> INCBETA(X, P, Q, EPS);
      <u>value</u> X, P, Q, EPS; <u>real</u> X, P, Q, EPS;
      <u>code</u> 35050;

   <u>procedure</u> FORWARD(X, P, Q, I0, I1, NMAX, I);
      <u>value</u> X, P, Q, I0, I1, NMAX; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, I1;
        <u>array</u> I;
      <u>code</u> 35055;

   <u>procedure</u> BACKWARD(X, P, Q, I0, NMAX, EPS, I);
      <u>value</u> X, P, Q, I0, NMAX, EPS; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, EPS;
        <u>array</u> I;
      <u>code</u> 35056;

   M ≔ ENTIER(Q); S ≔ Q-M; Q0 ≔ <u>if</u> S &gt; 0 <u>then</u> S <u>else</u> S + 1;
   MMAX ≔ <u>if</u> S &gt; 0 <u>then</u> M <u>else</u> M-1;
   IQ0 ≔ INCBETA(X, P, Q0, EPS);
   <u>if</u> MMAX &gt; 0 <u>then</u> IQ1 ≔ INCBETA(X, P, Q0 + 1, EPS);
   <u>begin</u> <u>array</u> IQ[0:MMAX];
      FORWARD(X, P, Q0, IQ0, IQ1, MMAX, IQ);
      BACKWARD(X, P, Q, IQ[MMAX], NMAX, EPS, I)
   <u>end</u>
<u>end</u> IXQFIX;
<u>comment</u> ================== 35054 ================= ;
<u>procedure</u> IXPFIX(X, P, Q, NMAX, EPS, I); <u>value</u> X, P, Q, NMAX, EPS;
   <u>real</u> X, P, Q, EPS; <u>integer</u> NMAX; <u>array</u> I;
<u>begin</u> <u>integer</u> M, MMAX; <u>real</u> S, P0, I0, I1, IQ0, IQ1;

   <u>real</u> <u>procedure</u> INCBETA(X, P, Q, EPS);
      <u>value</u> X, P, Q, EPS; <u>real</u> X, P, Q, EPS;
      <u>code</u> 35050;

   <u>procedure</u> FORWARD(X, P, Q, I0, I1, NMAX, I);
      <u>value</u> X, P, Q, I0, I1, NMAX; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, I1;
        <u>array</u> I;
      <u>code</u> 35055;

   <u>procedure</u> BACKWARD(X, P, Q, I0, NMAX, EPS, I);
      <u>value</u> X, P, Q, I0, NMAX, EPS; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, EPS;
        <u>array</u> I;
      <u>code</u> 35056;

   M ≔ ENTIER(P); S ≔ P-M; P0 ≔ <u>if</u> S &gt; 0 <u>then</u> S <u>else</u> S + 1;
   MMAX ≔ <u>if</u> S &gt; 0 <u>then</u> M <u>else</u> M-1;
   I0 ≔ INCBETA(X, P0, Q, EPS);
   I1 ≔ INCBETA(X, P0, Q + 1, EPS);
   <u>begin</u> <u>array</u> IP[0:MMAX];
      BACKWARD(X, P0, Q, I0, MMAX, EPS, IP); IQ0 ≔ IP[MMAX];
      BACKWARD(X, P0, Q + 1, I1, MMAX, EPS, IP); IQ1 ≔ IP[MMAX]
   <u>end</u>;
   FORWARD(X, P, Q, IQ0, IQ1, NMAX, I)
<u>end</u> IXPFIX;
<u>comment</u> ================== 35055 ================= ;
<u>procedure</u> FORWARD(X, P, Q, I0, I1, NMAX, I);
   <u>value</u> X, P, Q, I0, I1, NMAX; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, I1;
     <u>array</u> I;
<u>begin</u> <u>integer</u> M, N; <u>real</u> Y, R, S;
   I[0] ≔ I0; <u>if</u> NMAX &gt; 0 <u>then</u> I[1] ≔ I1;
   M ≔ NMAX-1; R ≔ P + Q-1; Y ≔ 1-X;
   <u>for</u> N ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u>
      <u>begin</u> S ≔ (N + R) × Y;
         I[N + 1] ≔ ((N + Q + S) × I[N]-S × I[N-1])/(N + Q)
      <u>end</u>
<u>end</u> FORWARD;
<u>comment</u> ================== 35056 ================= ;
<u>procedure</u> BACKWARD(X, P, Q, I0, NMAX, EPS, I);
   <u>value</u> X, P, Q, I0, NMAX, EPS; <u>integer</u> NMAX; <u>real</u> X, P, Q, I0, EPS;
     <u>array</u> I;
<u>begin</u> <u>integer</u> M, N, NU; <u>real</u> R, PQ, Y, LOGX;
   <u>array</u> IAPPROX[0:NMAX];
   I[0] ≔ I0; <u>if</u> NMAX &gt; 0 <u>then</u>
   <u>begin</u> <u>for</u> N ≔ 1 <u>step</u> 1 <u>until</u> NMAX <u>do</u> IAPPROX[N] ≔ 0;
      PQ ≔ P + Q-1; LOGX ≔ LN(X);
      R ≔ NMAX + (LN(EPS) + Q × LN(NMAX))/LOGX;
      NU ≔ ENTIER(R-Q × LN(R)/LOGX);
      L1:     N ≔ NU; R ≔ X;
      L2:     Y ≔ (N + PQ) × X; R ≔ Y/(Y + (N + P) × (1-R));
      <u>if</u> N &LessSlantEqual; NMAX <u>then</u> I[N] ≔ R; N ≔ N-1;
      <u>if</u> N &GreaterSlantEqual; 1 <u>then</u> <u>goto</u> L2; R ≔ I0;
      <u>for</u> N ≔ 1 <u>step</u> 1 <u>until</u> NMAX <u>do</u> R ≔ I[N] ≔ I[N] × R;
      <u>for</u> N ≔ 1 <u>step</u> 1 <u>until</u> NMAX <u>do</u>
           <u>if</u> ABS((I[N]-IAPPROX[N])/I[N]) &gt; EPS <u>then</u>
         <u>begin</u> <u>for</u> M ≔ 1 <u>step</u> 1 <u>until</u> NMAX <u>do</u>
                 IAPPROX[M] ≔ I[M]; NU ≔ NU + 5; <u>goto</u> L1
         <u>end</u>
   <u>end</u>
<u>end</u> BACKWARD;
<u>comment</u> ================== 34150 ================= ;
<u>Boolean</u> <u>procedure</u> ZEROIN(X, Y, FX, TOLX);
   <u>real</u> X, Y, FX, TOLX;
<u>begin</u> <u>integer</u> EXT;
   <u>real</u> C, FC, B, FB, A, FA, D, FD, FDB, FDA, W, MB,
     TOL, M, P, Q, DW;
   DW ≔ DWARF; B ≔ X; FB ≔ FX; A ≔ X ≔ Y; FA ≔ FX;
   INTERPOLATE: C ≔ A; FC ≔ FA; EXT ≔ 0;
   EXTRAPOLATE: <u>if</u> ABS(FC) &lt; ABS(FB) <u>then</u>
   <u>begin</u> <u>if</u> C ≠ A <u>then</u> <u>begin</u> D ≔ A; FD ≔ FA <u>end</u>;
      A ≔ B; FA ≔ FB; B ≔ X ≔ C; FB ≔ FC; C ≔ A; FC ≔ FA
   <u>end</u> INTERCHANGE;
   TOL ≔ TOLX; M ≔ (C + B) × 0·5; MB ≔ M - B;
   <u>if</u> ABS(MB) &gt; TOL <u>then</u>
   <u>begin</u> <u>if</u> EXT &gt; 2 <u>then</u> W ≔ MB <u>else</u>
      <u>begin</u> TOL ≔ TOL × SIGN(MB);
         P ≔ (B - A) × FB; <u>if</u> EXT &LessSlantEqual; 1 <u>then</u>
           Q ≔ FA - FB <u>else</u>
         <u>begin</u> FDB ≔ (FD - FB) / (D - B);
            FDA ≔ (FD - FA) / (D - A);
            P ≔ FDA × P; Q ≔ FDB × FA - FDA × FB
         <u>end</u>; <u>if</u> P &lt; 0 <u>then</u>
         <u>begin</u> P ≔ -P; Q ≔ -Q <u>end</u>;
         W ≔ <u>if</u> P &lt; DW ∨ P &LessSlantEqual; Q × TOL <u>then</u> TOL <u>else</u>
           <u>if</u> P &lt; MB × Q <u>then</u> P / Q <u>else</u> MB
      <u>end</u>; D ≔ A; FD ≔ FA; A ≔ B; FA ≔ FB;
      X ≔ B ≔ B + W; FB ≔ FX;
      <u>if</u> (<u>if</u> FC &GreaterSlantEqual; 0 <u>then</u> FB &GreaterSlantEqual; 0 <u>else</u> FB &LessSlantEqual; 0) <u>then</u>
        <u>goto</u> INTERPOLATE <u>else</u>
      <u>begin</u> EXT ≔ <u>if</u> W = MB <u>then</u> 0 <u>else</u> EXT + 1;
         <u>goto</u> EXTRAPOLATE
      <u>end</u>
   <u>end</u>; Y ≔ C;
   ZEROIN ≔ <u>if</u> FC &GreaterSlantEqual; 0 <u>then</u> FB &LessSlantEqual; 0 <u>else</u> FB &GreaterSlantEqual; 0
<u>end</u> ZEROIN;
<u>comment</u> ================== 34440 ================= ;
<u>procedure</u> MARQUARDT(M, N, PAR, G, V, FUNCT, JACOBIAN, IN, OUT);
   <u>value</u> M, N; <u>integer</u> M, N; <u>array</u> PAR, G, V, IN, OUT;
     <u>Boolean</u> <u>procedure</u> FUNCT; <u>procedure</u> JACOBIAN;
<u>begin</u> <u>integer</u> MAXFE, FE, IT, I, J, ERR;
   <u>real</u> VV, WW, W, MU, RES, FPAR, FPARPRES, LAMBDA, LAMBDAMIN,
     P, PW, RELTOLRES, ABSTOLRES;
   <u>array</u> EM[0:7], VAL, B, BB, PARPRES[1:N], JAC[1:M, 1:N];

   <u>procedure</u> MULCOL(L, U, S, T, A, B, X); <u>code</u> 31022;
   <u>procedure</u> DUPVEC(L, U, S, A, B); <u>code</u> 31030;
   <u>real</u> <u>procedure</u> VECVEC(L, U, S, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, S, A, B); <u>code</u> 34011;
   <u>real</u> <u>procedure</u> TAMVEC(L, U, S, A, B); <u>code</u> 34012;
   <u>real</u> <u>procedure</u> MATTAM(L, U, S, T, A, B); <u>code</u> 34015;
   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM);
      <u>code</u> 34273;

   <u>procedure</u> LOCFUNCT(M, N, PAR, G);
      <u>integer</u> M, N; <u>array</u> PAR, G;
   <u>begin</u> FE ≔ FE + 1; <u>if</u> FE &GreaterSlantEqual; MAXFE <u>then</u> ERR ≔ 1 <u>else</u>
      <u>if</u> ¬FUNCT(M, N, PAR, G) <u>then</u> ERR ≔ 2;
      <u>if</u> ERR ≠ 0 <u>then</u> <u>goto</u> EXIT
   <u>end</u> LOCFUNCT;

   VV ≔ 10; W ≔ 0·5; MU ≔ 0·01;
   WW ≔ (<u>if</u> IN[6] &lt; &#9192;-7 <u>then</u> &#9192;-8 <u>else</u> &#9192;-1 × IN[6]);
   EM[0] ≔ EM[2] ≔ EM[6] ≔ IN[0]; EM[4] ≔ 10 × N;
   RELTOLRES ≔ IN[3]; ABSTOLRES ≔ IN[4]⭡2; MAXFE ≔ IN[5];
   ERR ≔ 0; FE ≔ IT ≔ 1; P ≔ FPAR ≔ RES ≔ 0;
   PW ≔ -LN(WW × IN[0])/2·30;

   <u>if</u> ¬FUNCT(M, N, PAR, G) <u>then</u>
   <u>begin</u> ERR ≔ 3; <u>goto</u> ESCAPE <u>end</u>;
   FPAR ≔ VECVEC(1, M, 0, G, G); OUT[3] ≔ SQRT(FPAR);

   <u>for</u> IT ≔ 1, IT + 1 <u>while</u> FPAR &gt; ABSTOLRES ∧
     RES &gt; RELTOLRES × FPAR + ABSTOLRES <u>do</u>
      <u>begin</u> JACOBIAN(M, N, PAR, G, JAC, LOCFUNCT);
         I ≔ QRISNGVALDEC(JAC, M, N, VAL, V, EM);
         <u>if</u> IT = 1 <u>then</u>
           LAMBDA ≔ IN[6] × VECVEC(1, N, 0, VAL, VAL) <u>else</u>
         <u>if</u> P = 0 <u>then</u> LAMBDA ≔ LAMBDA × W <u>else</u> P ≔ 0;

         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              B[I] ≔ VAL[I] × TAMVEC(1, M, I, JAC, G);

         L:   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              BB[I] ≔ B[I]/(VAL[I] × VAL[I] + LAMBDA);
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
              PARPRES[I] ≔ PAR[I] - MATVEC(1, N, I, V, BB);
         LOCFUNCT(M, N, PARPRES, G);
         FPARPRES ≔ VECVEC(1, M, 0, G, G);
         RES ≔ FPAR-FPARPRES;
         <u>if</u> RES &lt; MU × VECVEC(1, N, 0, B, BB) <u>then</u>
         <u>begin</u> P ≔ P + 1; LAMBDA ≔ VV × LAMBDA;
            <u>if</u> P = 1 <u>then</u>
            <u>begin</u> LAMBDAMIN ≔ WW × VECVEC(1, N, 0, VAL, VAL);
               <u>if</u> LAMBDA &lt; LAMBDAMIN <u>then</u> LAMBDA ≔ LAMBDAMIN
            <u>end</u>;
            <u>if</u> P &lt; PW <u>then</u> <u>goto</u> L <u>else</u>
            <u>begin</u> ERR ≔ 4;
               <u>goto</u> EXIT
            <u>end</u>;
         <u>end</u>;

         DUPVEC(1, N, 0, PAR, PARPRES);
         FPAR ≔ FPARPRES
      <u>end</u> ITERATION;

   EXIT:
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        MULCOL(1, N, I, I, JAC, V, 1/(VAL[I] + IN[0]));
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> I <u>do</u>
           V[I, J] ≔ V[J, I] ≔ MATTAM(1, N, I, J, JAC, JAC);

   LAMBDA ≔ LAMBDAMIN ≔ VAL[1];
   <u>for</u> I ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
        <u>if</u> VAL[I] &gt; LAMBDA    <u>then</u> LAMBDA   ≔ VAL[I] <u>else</u>
      <u>if</u> VAL[I] &lt; LAMBDAMIN <u>then</u> LAMBDAMIN ≔ VAL[I];

   OUT[7] ≔ (LAMBDA/(LAMBDAMIN + IN[0]))⭡2;
   OUT[2] ≔ SQRT(FPAR);
   OUT[6] ≔ SQRT(RES + FPAR)-OUT[2];
   ESCAPE:
   OUT[4] ≔ FE;
   OUT[5] ≔ IT-1;
   OUT[1] ≔ ERR
<u>end</u> MARQUARDT;
<u>comment</u> ================== 33135 ================= ;
<u>procedure</u> IMPEX (N, T0, TEND, Y0, DERIV, AVAILABLE, H0, HMAX,
  PRESCH, EPS, WEIGHTS, UPDATE, FAIL, CONTROL);
   <u>value</u> N;
   <u>integer</u> N;
     <u>real</u> T0, TEND, H0, HMAX, EPS;
     <u>Boolean</u> PRESCH, FAIL;
     <u>array</u> Y0, WEIGHTS;
     <u>Boolean</u> <u>procedure</u> AVAILABLE;
     <u>procedure</u> DERIV, UPDATE, CONTROL;
<u>begin</u> <u>integer</u> I, K, ECI;
   <u>real</u> T, T1, T2, T3, TP, H, H2, HNEW, ALF, LQ;
   <u>array</u> Y, Z, S1, S2, S3, U1, U3, W1, W2, W3, EHR[1:N], R, RF[1:5, 1:N],
     ERR[1:3], A1, A2[1:N, 1:N];
   <u>integer</u> <u>array</u> PS1, PS2[1:N];
   <u>Boolean</u> START, TWO, HALV;
   <u>procedure</u> INIVEC(L, U, A, X);             <u>code</u> 31010;
   <u>procedure</u> INIMAT(LR, UR, LC, UC, A, X);     <u>code</u> 31011;
   <u>procedure</u> MULVEC(L, U, SHIFT, A, B, X);     <u>code</u> 31020;
   <u>procedure</u> MULROW(L, U, I, J, A, B, X);       <u>code</u> 31021;
   <u>procedure</u> DUPVEC(L, U, SHIFT, A, B);       <u>code</u> 31030;
   <u>procedure</u> DUPROWVEC(L, U, I, A, B);        <u>code</u> 31032;
   <u>procedure</u> DUPMAT(L, U, I, J, A, B);         <u>code</u> 31035;
   <u>real</u> <u>procedure</u> VECVEC(L, U, SHIFT, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B);    <u>code</u> 34011;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B);  <u>code</u> 34013;
   <u>procedure</u> ELMVEC(L, U, SHIFT, A, B, X);     <u>code</u> 34020;
   <u>procedure</u> ELMROW(L, U, I, J, A, B, X);       <u>code</u> 34024;
   <u>procedure</u> DEC(A, N, AUX, P);              <u>code</u> 34300;
   <u>procedure</u> SOL(A, N, P, B);                <u>code</u> 34051;

   <u>procedure</u> DFDY(T, Y, A); <u>real</u> T; <u>array</u> Y, A;
   <u>begin</u> <u>integer</u> I, J; <u>real</u> SL; <u>array</u> F1, F2[1:N];
      DERIV(T, Y, F1, N);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u>
            SL ≔ &#9192;-6 × Y[I]; <u>if</u> ABS(SL) &lt; &#9192;-6 <u>then</u> SL ≔ &#9192;-6;
            Y[I] ≔ Y[I] + SL; DERIV(T, Y, F2, N);
            <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 A[J, I] ≔ (F2[J]-F1[J])/SL;
            Y[I] ≔ Y[I]-SL;
         <u>end</u>
   <u>end</u> DFDY;

   <u>procedure</u> STARTV(Y, T); <u>value</u> T; <u>real</u> T; <u>array</u> Y;
   <u>begin</u> <u>real</u> A, B, C;
      A ≔ (T-T1)/(T1-T2); B ≔ (T-T2)/(T1-T3);
      C ≔ (T-T1)/(T2-T3) × B; B ≔ A × B;
      A ≔ 1 + A + B; B ≔ A + C-1;
      MULVEC(1, N, 0, Y, S1, A); ELMVEC(1, N, 0, Y, S2, -B);
      ELMVEC(1, N, 0, Y, S3, C)
   <u>end</u> STARTV;
   <u>procedure</u> ITERATE(Z, Y, A, H, T, WEIGHTS, FAIL, PS);
      <u>array</u> Z, Y, A, WEIGHTS; <u>real</u> H, T; <u>label</u> FAIL;
        <u>integer</u> <u>array</u> PS;
   <u>begin</u> <u>integer</u> IT, LIT; <u>real</u> MAX, MAX1, CONV; <u>array</u> DZ, F1[1:N];
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Z[I] ≔ (Z[I] + Y[I])/2;
      IT ≔ LIT ≔ 1; CONV ≔ 1;
      ATER: DERIV(T, Z, F1, N);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
           F1[I] ≔ DZ[I] ≔ Z[I]-H × F1[I]/2-Y[I];
      SOL(A, N, PS, DZ);
      ELMVEC(1, N, 0, Z, DZ, -1);
      MAX ≔ 0;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
           MAX ≔ MAX + (WEIGHTS[I] × DZ[I])⭡2;
      MAX ≔ SQRT(MAX);
      <u>if</u> MAX × CONV &lt; EPS/10 <u>then</u> <u>goto</u> OUT;
      IT ≔ IT + 1; <u>if</u> IT = 2 <u>then</u> <u>goto</u> ASS;
      CONV ≔ MAX/MAX1;
      <u>if</u> CONV &gt; ·2 <u>then</u>
      <u>begin</u> <u>if</u> LIT = 0 <u>then</u> <u>goto</u> FAIL;
         LIT ≔ 0; CONV ≔ 1; IT ≔ 1;
         RECOMP(A, H, T, Z, FAIL, PS);
      <u>end</u>;
      ASS: MAX1 ≔ MAX;
      <u>goto</u> ATER;
      OUT: <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> Z[I] ≔ 2 × Z[I]-Y[I];
   <u>end</u> ITERATE;

   <u>procedure</u> RECOMP(A, H, T, Y, FAIL, PS);
      <u>real</u> H, T; <u>array</u> A, Y; <u>label</u> FAIL; <u>integer</u> <u>array</u> PS;
   <u>begin</u> <u>real</u> SL; <u>array</u> AUX[1:3];
      SL ≔ H/2;
      <u>if</u> ¬AVAILABLE(T, Y, A, N) <u>then</u> DFDY(T, Y, A);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> MULROW(1, N, I, I, A, A, -SL); A[I, I] ≔ 1 + A[I, I]
         <u>end</u>;
      AUX[2] ≔ &#9192;-14;
      DEC(A, N, AUX, PS);
      <u>if</u> AUX[3] &lt; N <u>then</u> <u>goto</u> FAIL
   <u>end</u> RECOMP;

   <u>procedure</u> INITIALIZATION;
   <u>begin</u> H2 ≔ HNEW; H ≔ H2/2;
      DUPVEC(1, N, 0, S1, Y0); DUPVEC(1, N, 0, S2, Y0); DUPVEC(1, N, 0, S3, Y0);
      DUPVEC(1, N, 0, W1, Y0); DUPROWVEC(1, N, 1, R, Y0);
      INIVEC(1, N, U1, 0); INIVEC(1, N, W2, 0);
      INIMAT(2, 5, 1, N, R, 0); INIMAT(1, 5, 1, N, RF, 0);
      T ≔ T1 ≔ T0; T2 ≔ T0-2 × H-&#9192;6; T3 ≔ 2 × T2 + 1;
      RECOMP(A1, H, T, S1, MISS, PS1); RECOMP(A2, H2, T, W1, MISS, PS2);
   <u>end</u>
     <u>procedure</u> ONE LARGE STEP;
   <u>begin</u> STARTV(Z, T + H);
      ITERATE(Z, S1, A1, H, T + H/2, WEIGHTS, MISS, PS1);
      DUPVEC(1, N, 0, Y, Z);
      STARTV(Z, T + H2);
      ITERATE(Z, Y, A1, H, T + 3 × H/2, WEIGHTS, MISS, PS1);
      DUPVEC(1, N, 0, U3, U1); DUPVEC(1, N, 0, U1, Y);
      DUPVEC(1, N, 0, S3, S2); DUPVEC(1, N, 0, S2, S1);
      DUPVEC(1, N, 0, S1, Z);
      ELMVEC(1, N, 0, Z, W1, 1); ELMVEC(1, N, 0, Z, S2, -1);
      ITERATE(Z, W1, A2, H2, T + H, WEIGHTS, MISS, PS2);
      T3 ≔ T2; T2 ≔ T1; T1 ≔ T + H2;
      DUPVEC(1, N, 0, W3, W2); DUPVEC(1, N, 0, W2, W1); DUPVEC(1, N, 0, W1, Z);
   <u>end</u>;

   <u>procedure</u> CHANGE OF INFORMATION;
   <u>begin</u> <u>real</u> ALF1, C1, C2, C3; <u>array</u> KOF[2:4, 2:4], E, D[1:4];
      C1 ≔ HNEW/H2; C2 ≔ C1 × C1; C3 ≔ C2 × C1;
      KOF[2, 2] ≔ C1; KOF[2, 3] ≔ (C1-C2)/2; KOF[2, 4] ≔ C3/6-C2/2 + C1/3;
      KOF[3, 3] ≔ C2; KOF[3, 4] ≔ C2-C3; KOF[4, 4] ≔ C3;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
           U1[I] ≔ R[2, I] + R[3, I]/2 + R[4, I]/3;
      ALF1 ≔ MATVEC(1, N, 1, RF, U1)/VECVEC(1, N, 0, U1, U1);
      ALF ≔ (ALF + ALF1) × C1;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u>
            E[1] ≔ RF[1, I]-ALF1 × U1[I];
            E[2] ≔ RF[2, I]-ALF1 × 2 × R[3, I];
            E[3] ≔ RF[3, I]-ALF1 × 4 × R[4, I];
            E[4] ≔ RF[4, I];
            D[1] ≔ R[1, I]; RF[1, I] ≔ E[1] ≔ E[1] × C2;
            <u>for</u> K ≔ 2 <u>step</u> 1 <u>until</u> 4 <u>do</u>
               <u>begin</u> R[K, I] ≔ D[K] ≔ MATMAT(K, 4, K, I, KOF, R);
                  RF[K, I] ≔ E[K] ≔ C2 × MATVEC(K, 4, K, KOF, E)
               <u>end</u> K;
            S1[I] ≔ D[1] + E[1]; W1[I] ≔ D[1] + 4 × E[1];
            S2[I] ≔ S1[I]-(D[2] + E[2]/2);
            S3[I] ≔ S2[I]-(D[2] + E[2]) + (D[3] + E[3]/2);
         <u>end</u> I;
      T3 ≔ T-HNEW; T2 ≔ T-HNEW/2; T1 ≔ T;
      H2 ≔ HNEW; H ≔ H2/2; ERR[1] ≔ 0;
      <u>if</u> HALV <u>then</u>
      <u>begin</u> DUPVEC(1, N, 0, PS2, PS1); DUPMAT(1, N, 1, N, A2, A1) <u>end</u>;
      <u>if</u> TWO <u>then</u>
      <u>begin</u> DUPVEC(1, N, 0, PS1, PS2); DUPMAT(1, N, 1, N, A1, A2)
      <u>end</u> <u>else</u> RECOMP(A1, HNEW/2, T, S1, MISS, PS1);
      <u>if</u> ¬HALV <u>then</u> RECOMP(A2, HNEW, T, W1, MISS, PS2);
   <u>end</u>;
   <u>procedure</u> BACKWARD DIFFERENCES;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> <u>real</u> B0, B1, B2, B3;
            B1 ≔ (U1[I] + 2 × S2[I] + U3[I])/4;
            B2 ≔ (W1[I] + 2 × W2[I] + W3[I])/4;
            B3 ≔ (S3[I] + 2 × U3[I] + S2[I])/4;
            B2 ≔ (B2-B1)/3; B0 ≔ B1-B2;
            B2 ≔ B2-(S1[I]-2 × S2[I] + S3[I])/16;
            B1 ≔ 2 × B3-(B2 + RF[1, I])-(B0 + R[1, I])/2;
            B3 ≔ 0;
            <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> 4 <u>do</u>
               <u>begin</u> B1 ≔ B1-B3; B3 ≔ R[K, I]; R[K, I] ≔ B0; B0 ≔ B0-B1
               <u>end</u>; R[5, I] ≔ B0;
            <u>for</u> K ≔ 1 <u>step</u> 1 <u>until</u> 4 <u>do</u>
               <u>begin</u> B3 ≔ RF[K, I]; RF[K, I] ≔ B2; B2 ≔ B2-B3 <u>end</u>;
            RF[5, I] ≔ B2;
         <u>end</u>;

   <u>procedure</u> ERROR ESTIMATES;
   <u>begin</u> <u>real</u> C0, C1, C2, C3, B0, B1, B2, B3, W, SL1, SN, LR;
      C0 ≔ C1 ≔ C2 ≔ C3 ≔ 0;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> W ≔ WEIGHTS[I]⭡2;
            B0 ≔ RF[4, I]/36; C0 ≔ C0 + B0 × B0 × W; LR ≔ ABS(B0);
            B1 ≔ RF[1, I] + ALF × R[2, I]; C1 ≔ C1 + B1 × B1 × W;
            B2 ≔ RF[3, I]; C2 ≔ C2 + B2 × B2 × W;
            SL1 ≔ ABS(RF[1, I]-RF[2, I]);
            SN ≔ <u>if</u> SL1 &lt; &#9192;-10 <u>then</u> 1 <u>else</u> ABS(RF[1, I]-R[4, I]/6)/SL1;
            <u>if</u> SN &gt; 1 <u>then</u> SN ≔ 1;
            <u>if</u> START <u>then</u> <u>begin</u> SN ≔ SN⭡4; LR ≔ LR × 4 <u>end</u>;
            EHR[I] ≔ B3 ≔ SN × EHR[I] + LR; C3 ≔ C3 + B3 × B3 × W;
         <u>end</u> I;
      B0 ≔ ERR[1];
      ERR[1] ≔ B1 ≔ SQRT(C0); ERR[2] ≔ SQRT(C1);
      ERR[3] ≔ SQRT(C3) + SQRT(C2)/2;
      LQ ≔ EPS/(<u>if</u> B0 &lt; B1 <u>then</u> B1 <u>else</u> B0);
      <u>if</u> B0 &lt; B1 ∧ LQ &GreaterSlantEqual; 80 <u>then</u> LQ ≔ 10;
   <u>end</u>;

   <u>procedure</u> REJECT;
      <u>if</u> START <u>then</u>
      <u>begin</u> HNEW ≔ LQ⭡(1/5) × H/2; <u>goto</u> INIT
      <u>end</u> <u>else</u>
      <u>begin</u> <u>for</u> K ≔ 1, 2, 3, 4, 1, 2, 3 <u>do</u> ELMROW(1, N, K, K + 1, R, R, -1);
         <u>for</u> K ≔ 1, 2, 3, 4 <u>do</u> ELMROW(1, N, K, K + 1, RF, RF, -1);
         T ≔ T-H2; HALV ≔ <u>true</u>; HNEW ≔ H; <u>goto</u> MSTP
      <u>end</u>;
   <u>procedure</u> STEPSIZE;
      <u>if</u> LQ &lt; 2 <u>then</u>
      <u>begin</u> HALV ≔ <u>true</u>; HNEW ≔ H <u>end</u> <u>else</u>
      <u>begin</u> <u>if</u> LQ &gt; 80 <u>then</u>
           HNEW ≔ (<u>if</u> LQ &gt; 5120 <u>then</u> (LQ/5)⭡(1/5) <u>else</u> 2) × H2;
         <u>if</u> HNEW &gt; HMAX <u>then</u> HNEW ≔ HMAX;
         <u>if</u> TEND &gt; T ∧ TEND-T &lt; HNEW <u>then</u> HNEW ≔ TEND-T;
         TWO ≔ HNEW = 2 × H2;
      <u>end</u>;

   <u>if</u> PRESCH <u>then</u> H ≔ H0 <u>else</u>
   <u>begin</u> <u>if</u> H0 &gt; HMAX <u>then</u> H ≔ HMAX <u>else</u> H ≔ H0;
      <u>if</u> H &gt; (TEND-T0)/4 <u>then</u> H ≔ (TEND-T0)/4;
   <u>end</u>;
   HNEW ≔ H;
   ALF ≔ 0; T ≔ TP ≔ T0;
   INIVEC(1, 3, ERR, 0); INIVEC(1, N, EHR, 0);
   DUPROWVEC(1, N, 1, R, Y0);
   CONTROL(TP, T, H, HNEW, R, ERR, N);
   INIT: INITIALIZATION; START ≔ <u>true</u>;
   <u>for</u> ECI ≔ 0, 1, 2, 3 <u>do</u>
      <u>begin</u> ONE LARGE STEP; T ≔ T + H2;
         <u>if</u> ECI &gt; 0 <u>then</u>
         <u>begin</u> BACKWARD DIFFERENCES; UPDATE(WEIGHTS, S2, N) <u>end</u>
      <u>end</u>;
   ECI ≔ 4;
   MSTP: <u>if</u> HNEW ≠ H2 <u>then</u>
   <u>begin</u> ECI ≔ 1; CHANGE OF INFORMATION;
      ONE LARGE STEP; T ≔ T + H2; ECI ≔ 2;
   <u>end</u>;
   ONE LARGE STEP;
   BACKWARD DIFFERENCES;
   UPDATE(WEIGHTS, S2, N);
   ERROR ESTIMATES;
   <u>if</u> ECI &lt; 4 ∧ LQ &gt; 80 <u>then</u> LQ ≔ 20;
   HALV ≔ TWO ≔ <u>false</u>;
   <u>if</u> PRESCH <u>then</u> <u>goto</u> TRYCK;
   <u>if</u> LQ &lt; 1 <u>then</u> REJECT <u>else</u> STEPSIZE;
   TRYCK: <u>if</u> TP &LessSlantEqual; T <u>then</u> CONTROL(TP, T, H, HNEW, R, ERR, N);
   <u>if</u> START <u>then</u> START ≔ <u>false</u>;
   <u>if</u> HNEW = H2 <u>then</u> T ≔ T + H2; ECI ≔ ECI + 1;
   <u>if</u> T &lt; TEND + H2 <u>then</u> <u>goto</u> MSTP <u>else</u> <u>goto</u> END;
   MISS: FAIL ≔ PRESCH;
   <u>if</u> ¬FAIL <u>then</u>
   <u>begin</u> <u>if</u> ECI &gt; 1 <u>then</u> T ≔ T-H2;
      HALV ≔ TWO ≔ <u>false</u>; HNEW ≔ H2/2;
      <u>if</u> START <u>then</u> <u>goto</u> INIT <u>else</u> <u>goto</u> TRYCK
   <u>end</u>;
   END:
<u>end</u> IMPEX;
<u>comment</u> ================== 35021 ================= ;
<u>procedure</u> ERRORFUNCTION(X, ERF, ERFC);
   <u>value</u> X; <u>real</u> X, ERF, ERFC;
   <u>if</u> X &gt; 26   <u>then</u> <u>begin</u> ERF ≔  1; ERFC ≔ 0 <u>end</u> <u>else</u>
   <u>if</u> X &lt; -5·5 <u>then</u> <u>begin</u> ERF ≔ -1; ERFC ≔ 2 <u>end</u> <u>else</u>
   <u>begin</u> <u>real</u> ABSX, C, P, Q;
      <u>real</u> <u>procedure</u> NONEXPERFC(X); <u>code</u> 35022;

      ABSX ≔ ABS(X);
      <u>if</u> ABSX &LessSlantEqual; 0·5 <u>then</u>
      <u>begin</u> C ≔ X × X;         P ≔ ((-0·35609 84370 18154&#9192;-1  × C +
           0·69963 83488 61914&#9192;+1) × C + 0·21979 26161 82942&#9192;+2) × C +
           0·24266 79552 30532&#9192;+3;
         Q ≔ ((C +
           0·15082 79763 04078&#9192;+2) × C + 0·91164 90540 45149&#9192;+2) × C +
           0·21505 88758 69861&#9192;+3;
         ERF ≔  X × P / Q; ERFC ≔ 1 - ERF
      <u>end</u> <u>else</u>
      <u>begin</u> ERFC ≔ EXP(-X × X) × NONEXPERFC(ABSX);
         ERF ≔ 1 - ERFC;
         <u>if</u> X &lt; 0 <u>then</u>
         <u>begin</u> ERF ≔ -ERF; ERFC ≔ 2 - ERFC <u>end</u>
      <u>end</u>
   <u>end</u> ERRORFUNCTION;
<u>comment</u> ================== 35022 ================= ;
<u>real</u> <u>procedure</u> NONEXPERFC(X); <u>value</u> X; <u>real</u> X;
<u>begin</u> <u>real</u> ABSX, ERF, ERFC, C, P, Q;
   <u>procedure</u> ERRORFUNCTION(X, ERF, ERFC); <u>code</u> 35021;

   ABSX ≔ ABS(X);
   <u>if</u> ABSX &LessSlantEqual; 0·5 <u>then</u>
   <u>begin</u> ERRORFUNCTION(X, ERF, ERFC);
      NONEXPERFC ≔ EXP(X × X) × ERFC
   <u>end</u> <u>else</u>
   <u>if</u> ABSX &lt; 4 <u>then</u>
   <u>begin</u> C ≔ ABSX;      P ≔ ((((((-0·13686 48573 82717&#9192;-6  × C +
        0·56419 55174 78974&#9192;+0) × C + 0·72117 58250 88309&#9192;+1) × C +
        0·43162 22722 20567&#9192;+2) × C + 0·15298 92850 46940&#9192;+3) × C +
        0·33932 08167 34344&#9192;+3) × C + 0·45191 89537 11873&#9192;+3) × C +
        0·30045 92610 20162&#9192;+3;
      Q ≔ ((((((C +
        0·12782 72731 96294&#9192;+2) × C + 0·77000 15293 52295&#9192;+2) × C +
        0·27758 54447 43988&#9192;+3) × C + 0·63898 02644 65631&#9192;+3) × C +
        0·93135 40948 50610&#9192;+3) × C + 0·79095 09253 27898&#9192;+3) × C +
        0·30045 92609 56983&#9192;+3;
      NONEXPERFC ≔ <u>if</u> X &gt; 0 <u>then</u> P / Q <u>else</u>
        EXP(X × X) × 2 - P / Q
   <u>end</u> <u>else</u>
   <u>begin</u> C ≔ 1 / X / X;     P ≔ (((0·22319 24597 34185&#9192;-1  × C +
        0·27866 13086 09648&#9192;-0) × C + 0·22695 65935 39687&#9192;-0) × C +
        0·49473 09106 23251&#9192;-1) × C + 0·29961 07077 03542&#9192;-2;
      Q ≔ (((C +
        0·19873 32018 17135&#9192;+1) × C + 0·10516 75107 06793&#9192;+1) × C +
        0·19130 89261 07830&#9192;+0) × C + 0·10620 92305 28468&#9192;-1;
      C ≔ (C × (-P) / Q + 0·56418 95835 47756) / ABSX;
      NONEXPERFC ≔ <u>if</u> X &gt; 0 <u>then</u> C <u>else</u> EXP(X × X) × 2 - C
   <u>end</u>
<u>end</u> NONEXPERFC;
<u>comment</u> ================== 35027 ================= ;
<u>procedure</u> FRESNEL(X, C, S); <u>value</u> X; <u>real</u> X, C, S;
<u>begin</u> <u>real</u> ABSX, X3, X4, A, P, Q, F, G, C1, S1;
   <u>procedure</u> FG(X, F, G); <u>code</u> 35028;
   ABSX ≔ ABS(X);
   <u>if</u> ABSX &LessSlantEqual; 1·2 <u>then</u>
   <u>begin</u> A ≔ X × X; X3 ≔ A × X; X4 ≔ A × A;
      P ≔ (((5·47711 38568 2687&#9192;-6  × X4 - 5·28079 65137 2623&#9192;-4)× X4 + 1·76193 95254 3491&#9192;-2) × X4 - 1·99460 89882 6184&#9192;-1)× X4 + 1;
      Q ≔ (((1·18938 90142 2876&#9192;-7  × X4 + 1·55237 88527 6994&#9192;-5)× X4 + 1·09957 21502 5642&#9192;-3) × X4 + 4·72792 11201 0453&#9192;-2)× X4 + 1;
      C ≔ X × P / Q;
      P ≔ (((6·71748 46662 5141&#9192;-7  × X4 - 8·45557 28435 2777&#9192;-5)× X4 + 3·87782 12346 3683&#9192;-3) × X4 - 7·07489 91514 4523&#9192;-2)× X4 + 5·23598 77559 8299&#9192;-1;
      Q ≔ (((5·95281 22767 8410&#9192;-8  × X4 + 9·62690 87593 9034&#9192;-6)× X4 + 8·17091 94215 2134&#9192;-4) × X4 + 4·11223 15114 2384&#9192;-2)× X4 + 1;
      S ≔ X3 × P / Q
   <u>end</u> <u>else</u>
   <u>if</u> ABSX &LessSlantEqual; 1·6 <u>then</u>
   <u>begin</u> A ≔ X × X; X3 ≔ A × X; X4 ≔ A × A;
      P ≔ ((((-5·68293 31012 1871&#9192;-8  × X4 + 1·02365 43505 6106&#9192;-5)× X4 - 6·71376 03469 4922&#9192;-4) × X4 + 1·91870 27943 1747&#9192;-2)× X4 - 2·07073 36033 5324&#9192;-1) × X4 + 1·00000 00000 0111&#9192;+0;
      Q ≔ ((((4·41701 37406 5010&#9192;-10 × X4 + 8·77945 37789 2369&#9192;-8)× X4 + 1·01344 63086 6749&#9192;-5) × X4 + 7·88905 24505 2360&#9192;-4)× X4 + 3·96667 49695 2323&#9192;-2) × X4 + 1;
      C ≔ X × P / Q;
      P ≔ ((((-5·76765 81559 3089&#9192;-9  × X4 + 1·28531 04374 2725&#9192;-6)× X4 - 1·09540 02391 1435&#9192;-4) × X4 + 4·30730 52650 4367&#9192;-3)× X4 - 7·37766 91401 0191&#9192;-2) × X4 + 5·23598 77559 8344&#9192;-1;
      Q ≔ ((((2·05539 12445 8580&#9192;-10 × X4 + 5·03090 58124 6612&#9192;-8)× X4 + 6·87086 26571 8620&#9192;-6) × X4 + 6·18224 62019 5473&#9192;-4)× X4 + 3·53398 34276 7472&#9192;-2) × X4 + 1;
      S ≔ X3 × P / Q
   <u>end</u> <u>else</u>
   <u>if</u> ABSX &lt; &#9192;15 <u>then</u>
   <u>begin</u> FG(X, F, G);
      A ≔ X × X;
      A ≔ (A - ENTIER(A / 4) × 4) × 1·57079 63267 9490;
      C1 ≔ COS(A); S1 ≔ SIN(A);
      A ≔ <u>if</u> X &lt; 0 <u>then</u> -0·5 <u>else</u> 0·5;
      C ≔  F × S1 - G × C1 + A;
      S ≔ -F × C1 - G × S1 + A
   <u>end</u> <u>else</u> C ≔ S ≔ SIGN(X) × 0·5
<u>end</u> FRESNEL;
<u>comment</u> ================== 35028 ================= ;
<u>procedure</u> FG(X, F, G); <u>value</u> X; <u>real</u> X, F, G;
<u>begin</u> <u>real</u> ABSX, C, S, C1, S1, A, XINV, X3INV, C4, P, Q;
   <u>procedure</u> FRESNEL(X, C, S); <u>code</u> 35027;

   ABSX ≔ ABS(X);
   <u>if</u> ABSX &LessSlantEqual; 1·6 <u>then</u>
   <u>begin</u> FRESNEL(X, C, S);
      A ≔ X × X × 1·57079 63267 9490; C1 ≔ COS(A); S1 ≔ SIN(A);
      A ≔ <u>if</u> X &lt; 0 <u>then</u> -0·5 <u>else</u> 0·5;
      P ≔ A - C; Q ≔ A - S;
      F ≔ Q × C1 - P × S1;
      G ≔ P × C1 + Q × S1
   <u>end</u> <u>else</u>
   <u>if</u> ABSX &LessSlantEqual; 1·9 <u>then</u>
   <u>begin</u> XINV ≔ 1 / X; A ≔ XINV × XINV;
      X3INV ≔ A × XINV; C4 ≔ A × A;
      P ≔ (((1·35304 23554 0388&#9192;+1  × C4 + 6·98534 26160 1021&#9192;+1)× C4 + 4·80340 65557 7925&#9192;+1) × C4 + 8·03588 12280 3942&#9192;+0)× C4 + 3·18309 26850 4906&#9192;-1;
      Q ≔ (((6·55630 64008 3916&#9192;+1  × C4 + 2·49561 99380 5172&#9192;+2)× C4 + 1·57611 00558 0123&#9192;+2) × C4 + 2·55491 61843 5795&#9192;+1)× C4 + 1;
      F ≔ XINV × P / Q;
      P ≔ ((((2·05421 43249 8501&#9192;+1  × C4 + 1·96232 03797 1663&#9192;+2)× C4 + 1·99182 81867 8903&#9192;+2) × C4 + 5·31122 81348 0989&#9192;+1)× C4 + 4·44533 82755 0512&#9192;+0) × C4 + 1·01320 61881 0275&#9192;-1;
      Q ≔ ((((1·01379 48339 6003&#9192;+3  × C4 + 3·48112 14785 6545&#9192;+3)× C4 + 2·54473 13318 1822&#9192;+3) × C4 + 5·83590 57571 6429&#9192;+2)× C4 + 4·53925 01967 3689&#9192;+1) × C4 + 1;
      G ≔ X3INV × P / Q
   <u>end</u> <u>else</u>
   <u>if</u> ABSX &LessSlantEqual; 2·4 <u>then</u>
   <u>begin</u> XINV ≔ 1 / X; A ≔ XINV × XINV;
      X3INV ≔ A × XINV; C4 ≔ A × A;
      P ≔ ((((7·17703 24936 5140&#9192;+2  × C4 + 3·09145 16157 4430&#9192;+3)× C4 + 1·93007 64078 6716&#9192;+3) × C4 + 3·39837 13492 6984&#9192;+2)× C4 + 1·95883 94102 1969&#9192;+1) × C4 + 3·18309 88182 2017&#9192;-1;
      Q ≔ ((((3·36121 69918 0551&#9192;+3  × C4 + 1·09334 24898 8809&#9192;+4)× C4 + 6·33747 15585 1144&#9192;+3) × C4 + 1·08535 06750 0650&#9192;+3)× C4 + 6·18427 13817 2887&#9192;+1) × C4 + 1;
      F ≔ XINV × P / Q;
      P ≔ ((((3·13330 16306 8756&#9192;+2  × C4 + 1·59268 00608 5354&#9192;+3)× C4 + 9·08311 74952 9594&#9192;+2) × C4 + 1·40959 61791 1316&#9192;+2)× C4 + 7·11205 00178 9783&#9192;+0) × C4 + 1·01321 16176 1805&#9192;-1;
      Q ≔ ((((1·15149 83237 6261&#9192;+4  × C4 + 2·41315 56721 3370&#9192;+4)× C4 + 1·06729 67803 0581&#9192;+4) × C4 + 1·49051 92279 7329&#9192;+3)× C4 + 7·17128 59693 9302&#9192;+1) × C4 + 1;
      G ≔ X3INV × P / Q
   <u>end</u> <u>else</u>
   <u>begin</u> XINV ≔ 1 / X; A ≔ XINV × XINV;
      X3INV ≔ A × XINV; C4 ≔ A × A;
      P ≔ ((((2·61294 75322 5142&#9192;+4  × C4 + 6·13547 11361 4700&#9192;+4)× C4 + 1·34922 02817 1857&#9192;+4) × C4 + 8·16343 40178 4375&#9192;+2)× C4 + 1·64797 71284 1246&#9192;+1) × C4 + 9·67546 03296 7090&#9192;-2;
      Q ≔ ((((1·37012 36481 7226&#9192;+6  × C4 + 1·00105 47890 0791&#9192;+6)× C4 + 1·65946 46262 1853&#9192;+5) × C4 + 9·01827 59623 1524&#9192;+3)× C4 + 1·73871 69067 3649&#9192;+2) × C4 + 1;
      F ≔ (C4 × (-P) / Q + 0·31830 98861 83791) × XINV;
      P ≔ (((((1·72590 22465 4837&#9192;+6  × C4 + 6·66907 06166 8636&#9192;+6)× C4 + 1·77758 95083 8030&#9192;+6) × C4 + 1·35678 86781 3756&#9192;+5)× C4 + 3·87754 14174 6378&#9192;+3) × C4 + 4·31710 15782 3358&#9192;+1)× C4 + 1·53989 73381 9769&#9192;-1;
      Q ≔ (((((1·40622 44112 3580&#9192;+8  × C4 + 9·38695 86253 1635&#9192;+7)× C4 + 1·62095 60050 0232&#9192;+7) × C4 + 1·02878 69305 6688&#9192;+6)× C4 + 2·69183 18039 6243&#9192;+4) × C4 + 2·86733 19497 5899&#9192;+2)× C4 + 1;
      G ≔ (C4 × (-P) / Q + 0·10132 11836 42338) × X3INV
   <u>end</u>
<u>end</u> FG;
<u>comment</u> ================== 34453 ================= ;
<u>Boolean</u> <u>procedure</u> ZEROINDER(X, Y, FX, DFX, TOLX);
   <u>real</u> X, Y, FX, DFX, TOLX;
<u>begin</u> <u>integer</u> EXT;
   <u>real</u> B, FB, DFB, A, FA, DFA, C, FC, DFC, D, W, MB,
     TOL, M, P, Q, DW;
   <u>real</u> <u>procedure</u> DWARF; <u>code</u> 30003;
   DW ≔ DWARF;
   B ≔ X; FB ≔ FX; DFB ≔ DFX; A ≔ X ≔ Y; FA ≔ FX; DFA ≔ DFX;
   INTERPOLATE: C ≔ A; FC ≔ FA; DFC ≔ DFA; EXT ≔ 0;
   EXTRAPOLATE: <u>if</u> ABS(FC) &lt; ABS(FB) <u>then</u>
   <u>begin</u> A ≔ B; FA ≔ FB; DFA ≔ DFB; B ≔ X ≔ C; FB ≔ FC;
      DFB ≔ DFC; C ≔ A; FC ≔ FA; DFC ≔ DFA
   <u>end</u> INTERCHANGE;
   TOL ≔ TOLX; M ≔ (C + B) × 0·5; MB ≔ M - B;
   <u>if</u> ABS(MB) &gt; TOL <u>then</u>
   <u>begin</u> <u>if</u> EXT &gt; 2 <u>then</u> W ≔ MB <u>else</u>
      <u>begin</u> TOL ≔ TOL × SIGN(MB);
         D ≔ <u>if</u> EXT = 2 <u>then</u> DFA <u>else</u> (FB - FA) / (B - A);
         P ≔ FB × D × (B - A);
         Q ≔ FA × DFB - FB × D;
         <u>if</u> P &lt; 0 <u>then</u> <u>begin</u> P ≔ -P; Q ≔ -Q <u>end</u>;
         W ≔ <u>if</u> P &lt; DW ∨ P &LessSlantEqual; Q × TOL <u>then</u> TOL <u>else</u>
           <u>if</u> P &lt; MB × Q <u>then</u> P / Q <u>else</u> MB;
      <u>end</u>; A ≔ B; FA ≔ FB; DFA ≔ DFB;
      X ≔ B ≔ B + W; FB ≔ FX; DFB ≔ DFX;
      <u>if</u> (<u>if</u> FC &GreaterSlantEqual; 0 <u>then</u> FB &GreaterSlantEqual; 0 <u>else</u> FB &LessSlantEqual; 0) <u>then</u>
        <u>goto</u> INTERPOLATE <u>else</u>
      <u>begin</u> EXT ≔ <u>if</u> W = MB <u>then</u> 0 <u>else</u> EXT + 1;
         <u>goto</u> EXTRAPOLATE
      <u>end</u>
   <u>end</u>; Y ≔ C;
   ZEROINDER ≔ <u>if</u> FC &GreaterSlantEqual; 0 <u>then</u> FB &LessSlantEqual; 0 <u>else</u> FB &GreaterSlantEqual; 0
<u>end</u> ZEROINDER;
<u>comment</u> ================== 34432 ================= ;
<u>procedure</u> PRAXIS(N, X, FUNCT, IN, OUT);
   <u>value</u> N; <u>integer</u> N;
     <u>array</u> X, IN, OUT;
     <u>real</u> <u>procedure</u> FUNCT;
<u>begin</u>
   <u>comment</u> THIS PROCEDURE MINIMIZES FUNCT(N, X), WITH THE
     PRINCIPAL AXIS METHOD (SEE BRENT, R.P, 1973, ALGORITHMS
     FOR MINIMIZATION WITHOUT DERIVATIVES, CH.7);

   <u>procedure</u> INIVEC(L, U, A, X);                     <u>code</u> 31010;
   <u>procedure</u> INIMAT(L, U, K, V, A, X);               <u>code</u> 31011;
   <u>procedure</u> DUPVEC(L, U, K, A, X);                  <u>code</u> 31030;
   <u>procedure</u> DUPMAT(L, U, K, V, A, B);               <u>code</u> 31035;
   <u>procedure</u> DUPCOLVEC(L, U, K, A, B);               <u>code</u> 31034;
   <u>procedure</u> MULROW(L, U, I, J, A, B, X);            <u>code</u> 31021;
   <u>procedure</u> MULCOL(L, U, I, J, A, B, X);            <u>code</u> 31022;
   <u>real</u> <u>procedure</u> VECVEC(L, U, S, A, B);           <u>code</u> 34010;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B);        <u>code</u> 34014;
   <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B);        <u>code</u> 34015;
   <u>procedure</u> ICHROWCOL(L, U, I, J, A);               <u>code</u> 34033;
   <u>procedure</u> ELMVECCOL(L, U, I, A, B, X);            <u>code</u> 34021;
   <u>integer</u> <u>procedure</u> QRISNGVALDEC(A, M, N, VAL, V, EM); <u>code</u> 34273;
   <u>procedure</u> SETRANDOM(X);                           <u>code</u> 11014;
   <u>real</u> <u>procedure</u> RANDOM;                          <u>code</u> 11015;
   <u>real</u> <u>procedure</u> DWARF;                           <u>code</u> 30003;

   <u>procedure</u> SORT;
   <u>begin</u> <u>integer</u> I, J, K; <u>real</u> S;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N - 1 <u>do</u>
         <u>begin</u> K ≔ I; S ≔ D[I];
            <u>for</u> J ≔ I + 1 <u>step</u> 1 <u>until</u> N <u>do</u> <u>if</u> D[J] &gt; S <u>then</u>
               <u>begin</u> K ≔ J; S ≔ D[J] <u>end</u>;
            <u>if</u> K &gt; I <u>then</u>
            <u>begin</u> D[K] ≔ D[I]; D[I] ≔ S;
               <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                  <u>begin</u> S ≔ V[J, I]; V[J, I] ≔ V[J, K]; V[J, K] ≔ S
                  <u>end</u>
            <u>end</u>
         <u>end</u>
   <u>end</u> SORT;
   <u>procedure</u> MIN(J, NITS, D2, X1, F1, FK); <u>value</u> J, NITS, FK;
      <u>integer</u> J, NITS; <u>real</u> D2, X1, F1; <u>Boolean</u> FK;
   <u>begin</u>
      <u>real</u> <u>procedure</u> FLIN(L); <u>value</u> L; <u>real</u> L;
      <u>begin</u> <u>integer</u> I; <u>array</u> T[1:N];
         <u>if</u> J &gt; 0 <u>then</u>
         <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 T[I] ≔ X[I] + L × V[I, J]
         <u>end</u> <u>else</u>
         <u>begin</u> <u>comment</u> SEARCH ALONG PARABOLIC SPACE CURVE;
            QA ≔ L × (L - QD1) / (QD0 × (QD0 + QD1));
            QB ≔ (L + QD0) × (QD1 - L) /(QD0 × QD1);
            QC ≔ L × (L + QD0) / (QD1 × (QD0 + QD1));
            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                 T[I] ≔ QA × Q0[I] + QB × X[I] + QC × Q1[I]
         <u>end</u>;
         NF ≔ NF + 1; FLIN ≔ FUNCT(N, T)
      <u>end</u> FLIN;

      <u>integer</u> K; <u>Boolean</u> DZ;
      <u>real</u> X2, XM, F0, F2, FM, D1, T2, S, SF1, SX1;
      SF1 ≔ F1; SX1 ≔ X1;
      K ≔ 0; XM ≔ 0; F0 ≔ FM ≔ FX; DZ ≔ D2 &lt; RELTOL;
      S ≔ SQRT(VECVEC(1, N, 0, X, X));
      T2 ≔ M4 × SQRT(ABS(FX) / (<u>if</u> DZ <u>then</u> DMIN <u>else</u> D2)
        + S × LDT) + M2 × LDT; S ≔ S × M4 + ABSTOL;
      <u>if</u> DZ ∧ T2 &gt; S <u>then</u> T2 ≔ S;
      <u>if</u> T2 &lt; SMALL <u>then</u> T2 ≔ SMALL;
      <u>if</u> T2 &gt; 0·01 × H <u>then</u> T2 ≔ 0·01 × H;
      <u>if</u> FK ∧ F1 &LessSlantEqual; FM <u>then</u>
      <u>begin</u> XM ≔ X1; FM ≔ F1 <u>end</u>;
      <u>if</u> ¬FK ∨ ABS(X1) &lt; T2 <u>then</u>
      <u>begin</u> X1 ≔ <u>if</u> X1 &gt; 0 <u>then</u> T2 <u>else</u> -T2;
         F1 ≔ FLIN(X1)
      <u>end</u>;
      <u>if</u> F1 &LessSlantEqual; FM <u>then</u>
      <u>begin</u> XM ≔ X1; FM ≔ F1 <u>end</u>;
      L0: <u>if</u> DZ <u>then</u>
      <u>begin</u> <u>comment</u> EVALUATE FLIN AT ANOTHER POINT
           AND ESTIMATE THE SECOND DERIVATIVE;
         X2 ≔ <u>if</u> F0 &lt; F1 <u>then</u> -X1 <u>else</u> X1 × 2;
         F2 ≔ FLIN(X2); <u>if</u> F2 &LessSlantEqual; FM <u>then</u>
         <u>begin</u> XM ≔ X2; FM ≔ F2 <u>end</u>;
         D2 ≔ (X2 × (F1-F0)-X1 × (F2-F0))/(X1 × X2 × (X1-X2))
      <u>end</u>;
      <u>comment</u> ESTIMATE FIRST DERIVATIVE AT 0;
      D1 ≔ (F1-F0)/X1-X1 × D2; DZ ≔ <u>true</u>;
      X2 ≔ <u>if</u> D2 &LessSlantEqual; SMALL <u>then</u>
        (<u>if</u> D1 &lt; 0 <u>then</u> H <u>else</u> -H)
      <u>else</u> -0·5 × D1/D2;
      <u>if</u> ABS(X2) &gt; H <u>then</u> X2 ≔ <u>if</u> X2 &gt; 0 <u>then</u> H <u>else</u> -H;
      L1: F2 ≔ FLIN(X2);
      <u>if</u> K &lt; NITS ∧ F2 &gt; F0 <u>then</u>
      <u>begin</u> K ≔ K + 1;
         <u>if</u> F0 &lt; F1 ∧ X1 × X2 &gt; 0 <u>then</u> <u>goto</u> L0;
         X2 ≔ 0·5 × X2; <u>goto</u> L1
      <u>end</u>;
      NL ≔ NL + 1;
      <u>if</u> F2 &gt; FM <u>then</u> X2 ≔ XM <u>else</u> FM ≔ F2;
      D2 ≔ <u>if</u> ABS(X2 × (X2-X1)) &gt; SMALL <u>then</u>
        (X2 × (F1-F0)-X1 × (FM-F0))/(X1 × X2 × (X1-X2))
      <u>else</u> <u>if</u> K &gt; 0 <u>then</u> 0 <u>else</u> D2;
      <u>if</u> D2 &LessSlantEqual; SMALL <u>then</u> D2 ≔ SMALL;
      X1 ≔ X2; FX ≔ FM;
      <u>if</u> SF1 &lt; FX <u>then</u>
      <u>begin</u> FX ≔ SF1; X1 ≔ SX1 <u>end</u>;
      <u>if</u> J &gt; 0 <u>then</u> ELMVECCOL(1, N, J, X, V, X1)
   <u>end</u> MIN;

   <u>procedure</u> QUAD;
   <u>begin</u> <u>integer</u> I; <u>real</u> L, S;
      S ≔ FX; FX ≔ QF1; QF1 ≔ S; QD1 ≔ 0;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> S ≔ X[I]; X[I] ≔ L ≔ Q1[I]; Q1[I] ≔ S;
            QD1 ≔ QD1 + (S - L) ⭡ 2
         <u>end</u>;
      L ≔ QD1 ≔ SQRT(QD1); S ≔ 0;
      <u>if</u> (QD0 × QD1 &gt; DWARF) ∧ NL &GreaterSlantEqual; 3 × N × N <u>then</u>
      <u>begin</u> MIN(0, 2, S, L, QF1, <u>true</u>);
         QA ≔ L × (L-QD1)/(QD0 × (QD0 + QD1));
         QB ≔ (L + QD0) × (QD1-L)/(QD0 × QD1);
         QC ≔ L × (L + QD0)/(QD1 × (QD0 + QD1))
      <u>end</u> <u>else</u>
      <u>begin</u> FX ≔ QF1; QA ≔ QB ≔ 0; QC ≔ 1 <u>end</u>;
      QD0 ≔ QD1; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> S ≔ Q0[I]; Q0[I] ≔ X[I];
            X[I] ≔ QA × S + QB × X[I] + QC × Q1[I]
         <u>end</u>
   <u>end</u> QUAD;

   <u>Boolean</u> ILLC;
   <u>integer</u> I, J, K, K2, NL, MAXF, NF, KL, KT, KTM;
   <u>real</u> S, SL, DN, DMIN, FX, F1, LDS, LDT, SF, DF, QF1, QD0,
     QD1, QA, QB, QC, M2, M4, SMALL, VSMALL, LARGE, VLARGE, SCBD,
     LDFAC, T2, MACHEPS, RELTOL, ABSTOL, H;
   <u>array</u> V[1:N, 1:N], D, Y, Z, Q0, Q1[1:N];

   MACHEPS ≔ IN[0]; RELTOL ≔ IN[1]; ABSTOL ≔ IN[2]; MAXF ≔ IN[5];
   H ≔ IN[6]; SCBD ≔ IN[7]; KTM ≔ IN[8]; ILLC ≔ IN[9] &lt; 0;
   SMALL ≔ MACHEPS ⭡ 2; VSMALL ≔ SMALL ⭡ 2;
   LARGE ≔ 1/SMALL; VLARGE ≔ 1/VSMALL;
   M2 ≔ RELTOL; M4 ≔ SQRT(M2); SETRANDOM(0·5);
   LDFAC ≔ <u>if</u> ILLC <u>then</u> 0·1 <u>else</u> 0·01;
   KT ≔ NL ≔ 0; NF ≔ 1; OUT[3] ≔ QF1 ≔ FX ≔ FUNCT(N, X);
   ABSTOL ≔ T2 ≔ SMALL + ABS(ABSTOL); DMIN ≔ SMALL;
   <u>if</u> H &lt; ABSTOL × 100 <u>then</u> H ≔ ABSTOL × 100; LDT ≔ H;
   INIMAT(1, N, 1, N, V, 0);
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> V[I, I] ≔ 1;
   D[1] ≔ QD0 ≔ 0; DUPVEC(1, N, 0, Q1, X);
   INIVEC(1, N, Q0, 0);
   <u>comment</u> MAIN LOOP;
   L0: SF ≔ D[1]; D[1] ≔ S ≔ 0;
   MIN(1, 2, D[1], S, FX, <u>false</u>);
   <u>if</u> S &LessSlantEqual; 0 <u>then</u> MULCOL(1, N, 1, 1, V, V, -1);
   <u>if</u> SF &LessSlantEqual; 0·9 × D[1] ∨ 0·9 × SF &GreaterSlantEqual; D[1] <u>then</u>
     INIVEC(2, N, D, 0);
   <u>for</u> K ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> DUPVEC(1, N, 0, Y, X); SF ≔ FX;
         ILLC ≔ ILLC ∨ KT &gt; 0;
         L1: KL ≔ K; DF ≔ 0; <u>if</u> ILLC <u>then</u>
         <u>begin</u> <u>comment</u> RANDOM STOP TO GET OFF
              RESULTION VALLEY;
            <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> S ≔ Z[I] ≔ (0·1 × LDT + T2 × 10⭡KT)× (RANDOM-0·5);
                  ELMVECCOL(1, N, I, X, V, S)
               <u>end</u>;
            FX ≔ FUNCT(N, X); NF ≔ NF + 1
         <u>end</u>;
         <u>for</u> K2 ≔ K <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> SL ≔ FX; S ≔ 0;
               MIN (K2, 2, D[K2], S, FX, <u>false</u>);
               S ≔ <u>if</u> ILLC <u>then</u> D[K2] × (S + Z[K2]) ⭡ 2
               <u>else</u> SL-FX; <u>if</u> DF &lt; S <u>then</u>
               <u>begin</u> DF ≔ S; KL ≔ K2 <u>end</u>;
            <u>end</u>;
         <u>if</u> ¬ILLC ∧ DF &lt; ABS(100 × MACHEPS × FX) <u>then</u>
         <u>begin</u> ILLC ≔ <u>true</u>; <u>goto</u> L1 <u>end</u>;
         <u>for</u> K2 ≔ 1 <u>step</u> 1 <u>until</u> K-1 <u>do</u>
            <u>begin</u> S ≔ 0; MIN(K2, 2, D[K2], S, FX, <u>false</u>) <u>end</u>;
         F1 ≔ FX; FX ≔ SF; LDS ≔ 0;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> SL ≔ X[I]; X[I] ≔ Y[I]; SL ≔ Y[I] ≔ SL - Y[I];
               LDS ≔ LDS + SL × SL
            <u>end</u>; LDS ≔ SQRT(LDS);
         <u>if</u> LDS &gt; SMALL <u>then</u>
         <u>begin</u> <u>for</u> I ≔ KL - 1 <u>step</u> -1 <u>until</u> K <u>do</u>
               <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                       V[J, I + 1] ≔ V[J, I]; D[I + 1] ≔ D[I]
               <u>end</u>;
            D[K] ≔ 0; DUPCOLVEC(1, N, K, V, Y);
            MULCOL(1, N, K, K, V, V, 1 / LDS);
            MIN(K, 4, D[K], LDS, F1, <u>true</u>); <u>if</u> LDS &LessSlantEqual; 0 <u>then</u>
            <u>begin</u> LDS ≔ LDS; MULCOL(1, N, K, K, V, V, -1) <u>end</u>
         <u>end</u>;
         LDT ≔ LDFAC × LDT; <u>if</u> LDT &lt; LDS <u>then</u> LDT ≔ LDS;
         T2 ≔ M2 × SQRT(VECVEC(1, N, 0, X, X)) + ABSTOL;
         KT ≔ <u>if</u> LDT &gt; 0·5 × T2 <u>then</u> 0 <u>else</u> KT + 1;
         <u>if</u> KT &gt; KTM <u>then</u> <u>begin</u> OUT[1] ≔ 0; <u>goto</u> L2 <u>end</u>
      <u>end</u>;
   QUAD;
   DN ≔ 0; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> D[I] ≔ 1/SQRT(D[I]);
         <u>if</u> DN &lt; D[I] <u>then</u> DN ≔ D[I]
      <u>end</u>;
   <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> S ≔ D[J]/DN; MULCOL(1, N, J, J, V, V, S) <u>end</u>;
   <u>if</u> SCBD &gt; 1 <u>then</u>
   <u>begin</u> S ≔ VLARGE; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> SL ≔ Z[I] ≔ SQRT(MATTAM(1, N, I, I, V, V));
            <u>if</u> SL &lt; M4 <u>then</u> Z[I] ≔ M4;
            <u>if</u> S &gt; SL <u>then</u> S ≔ SL
         <u>end</u>;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> SL ≔ S/Z[I]; Z[I] ≔ 1/SL;
            <u>if</u> Z[I] &gt; SCBD <u>then</u>
            <u>begin</u> SL ≔ 1/SCBD; Z[I] ≔ SCBD <u>end</u>;
            MULROW(1, N, I, I, V, V, SL)
         <u>end</u>
   <u>end</u>;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
        ICHROWCOL(I + 1, N, I, I, V);
   <u>begin</u> <u>array</u> A[1:N, 1:N], EM[0:7];
      EM[0] ≔ EM[2] ≔ MACHEPS;
      EM[4] ≔ 10 × N; EM[6] ≔ VSMALL;
      DUPMAT(1, N, 1, N, A, V);
      <u>if</u> QRISNGVALDEC(A, N, N, D, V, EM) ≠ 0 <u>then</u>
      <u>begin</u> OUT[1] ≔ 2; <u>goto</u> L2 <u>end</u>;
   <u>end</u>;
   <u>if</u> SCBD &gt; 1 <u>then</u>
   <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
           MULROW(1, N, I, I, V, V, Z[I]);
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> S ≔ SQRT(TAMMAT(1, N, I, I, V, V));
            D[I] ≔ S × D[I]; S ≔ 1/S;
            MULCOL(1, N, I, I, V, V, S)
         <u>end</u>
   <u>end</u>;
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> S ≔ DN × D[I];
         D[I] ≔ <u>if</u> S &gt; LARGE <u>then</u> VSMALL <u>else</u>
           <u>if</u> S &lt; SMALL <u>then</u> VLARGE <u>else</u> S ⭡ (-2)
      <u>end</u>;
   SORT;
   DMIN ≔ D[N]; <u>if</u> DMIN &lt; SMALL <u>then</u> DMIN ≔ SMALL;
   ILLC ≔ (M2 × D[1]) &gt; DMIN;
   <u>if</u> NF &lt; MAXF <u>then</u> <u>goto</u> L0 <u>else</u> OUT[1] ≔ 1;
   L2: OUT[2] ≔ FX;
   OUT[4] ≔ NF; OUT[5] ≔ NL; OUT[6] ≔ LDT
<u>end</u> PRAXIS;
<u>comment</u> ================== 31061 ================= ;
<u>real</u> <u>procedure</u> INFNRMVEC(L, U, K, A); <u>value</u> L, U;
   <u>integer</u> L, U, K; <u>array</u> A;
<u>begin</u> <u>real</u> R, MAX;
   MAX ≔ 0; K ≔ L;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> R ≔ ABS(A[L]); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; K ≔ L <u>end</u>
      <u>end</u>;
   INFNRMVEC ≔ MAX
<u>end</u> INFNRMVEC;
<u>comment</u> ================== 31062 ================= ;
<u>real</u> <u>procedure</u> INFNRMROW(L, U, I, K, A); <u>value</u> L, U, I;
   <u>integer</u> L, U, I, K; <u>array</u> A;
<u>begin</u> <u>real</u> R, MAX;
   MAX ≔ 0; K ≔ L;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> R ≔ ABS(A[I, L]); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; K ≔ L <u>end</u>
      <u>end</u>;
   INFNRMROW ≔ MAX
<u>end</u> INFNRMROW;
<u>comment</u> ================== 31063 ================= ;
<u>real</u> <u>procedure</u> INFNRMCOL(L, U, J, K, A); <u>value</u> L, U, J;
   <u>integer</u> L, U, J, K; <u>array</u> A;
<u>begin</u> <u>real</u> R, MAX;
   MAX ≔ 0; K ≔ L;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> R ≔ ABS(A[L, J]); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; K ≔ L <u>end</u>
      <u>end</u>;
   INFNRMCOL ≔ MAX
<u>end</u> INFNRMCOL;
<u>comment</u> ================== 31064 ================= ;
<u>real</u> <u>procedure</u> INFNRMMAT(LR, UR, LC, UC, KR, A);
   <u>value</u> LR, UR, LC, UC; <u>integer</u> LR, UR, LC, UC, KR; <u>array</u> A;
<u>begin</u> <u>real</u> R, MAX;
   <u>real</u> <u>procedure</u> ONENRMROW(L, U, I, A); <u>code</u> 31066;
   MAX ≔ 0; KR ≔ LR;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
      <u>begin</u> R ≔ ONENRMROW(LC, UC, LR, A); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; KR ≔ LR <u>end</u>
      <u>end</u>;
   INFNRMMAT ≔ MAX
<u>end</u> INFNRMMAT;
<u>comment</u> ================== 31065 ================= ;
<u>real</u> <u>procedure</u> ONENRMVEC(L, U, A); <u>value</u> L, U;
   <u>integer</u> L, U; <u>array</u> A;
<u>begin</u> <u>real</u> SUM;
   SUM ≔ 0; <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
        SUM ≔ SUM + ABS(A[L]);
   ONENRMVEC ≔ SUM
<u>end</u> ONENRMVEC;
<u>comment</u> ================== 31066 ================= ;
<u>real</u> <u>procedure</u> ONENRMROW(L, U, I, A); <u>value</u> L, U, I;
   <u>integer</u> L, U, I; <u>array</u> A;
<u>begin</u> <u>real</u> SUM;
   SUM ≔ 0; <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
        SUM ≔ SUM + ABS(A[I, L]);
   ONENRMROW ≔ SUM
<u>end</u> ONENRMROW;
<u>comment</u> ================== 31067 ================= ;
<u>real</u> <u>procedure</u> ONENRMCOL(L, U, J, A); <u>value</u> L, U, J;
   <u>integer</u> L, U, J; <u>array</u> A;
<u>begin</u> <u>real</u> SUM;
   SUM ≔ 0; <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
        SUM ≔ SUM + ABS(A[L, J]);
   ONENRMCOL ≔ SUM
<u>end</u> ONENRMCOL;
<u>comment</u> ================== 31068 ================= ;
<u>real</u> <u>procedure</u> ONENRMMAT(LR, UR, LC, UC, KC, A);
   <u>value</u> LR, UR, LC, UC; <u>integer</u> LR, UR, LC, UC, KC; <u>array</u> A;
<u>begin</u> <u>real</u> MAX, R;
   <u>real</u> <u>procedure</u> ONENRMCOL(L, U, J, A); <u>code</u> 31067;
   MAX ≔ 0; KC ≔ LC;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
      <u>begin</u> R ≔ ONENRMCOL(LR, UR, LC, A); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; KC ≔ LC <u>end</u>
      <u>end</u>;
   ONENRMMAT ≔ MAX
<u>end</u> ONENRMMAT;
<u>comment</u> ================== 31069 ================= ;
<u>real</u> <u>procedure</u> ABSMAXMAT(LR, UR, LC, UC, I, J, A);
   <u>value</u> LR, UR, LC, UC; <u>integer</u> LR, UR, LC, UC, I, J; <u>array</u> A;
<u>begin</u> <u>integer</u> II; <u>real</u> MAX, R;
   <u>real</u> <u>procedure</u> INFNRMCOL(L, U, I, K, A); <u>code</u> 31063;
   MAX ≔ 0; I ≔ LR; J ≔ LC;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
      <u>begin</u> R ≔ INFNRMCOL(LR, UR, LC, II, A); <u>if</u> R &gt; MAX <u>then</u>
         <u>begin</u> MAX ≔ R; I ≔ II; J ≔ LC <u>end</u>
      <u>end</u>;
   ABSMAXMAT ≔ MAX
<u>end</u> ABSMAXMAT;
<u>comment</u> ================== 35140 ================= ;
<u>procedure</u> AIRY(Z, AI, AID, BI, BID, EXPON, FIRST);
   <u>value</u> Z, FIRST; <u>Boolean</u> FIRST;
     <u>real</u> Z, AI, AID, BI, BID, EXPON;
<u>begin</u> <u>real</u> S, T, U, V, SC, TC, UC, VC, X, K1, K2, K3, K4,
     C, ZT, SI, CO, EXPZT, SQRTZ, WWL, PL, PL1, PL2, PL3;
   <u>own</u> <u>real</u> C1, C2, SQRT3, SQRT1OPI, PIO4;
   <u>own</u> <u>real</u> <u>array</u> XX, WW[1:10];
   <u>integer</u> N, L;

   <u>if</u> FIRST <u>then</u>
   <u>begin</u> SQRT3 ≔    1·73205080756887729;
      SQRT1OPI ≔ 0·56418958354775629;
      PIO4 ≔     0·78539816339744831;
      C1 ≔       0·35502 80538 87817;
      C2 ≔       0·25881 94037 92807;
      XX[ 1] ≔   1·40830 81072 180964&#9192;+1;
      XX[ 2] ≔   1·02148 85479 197331&#9192;+1;
      XX[ 3] ≔   7·44160 18450 450930    ;
      XX[ 4] ≔   5·30709 43061 781927    ;
      XX[ 5] ≔   3·63401 35029 132462    ;
      XX[ 6] ≔   2·33106 52303 052450    ;
      XX[ 7] ≔   1·34479 70824 609268    ;
      XX[ 8] ≔   6·41888 58369 567296&#9192;-1;
      XX[ 9] ≔   2·01003 45998 121046&#9192;-1;
      XX[10] ≔   8·05943 59172 052833&#9192;-3;
      WW[ 1] ≔   3·15425 15762 964787&#9192;-14;
      WW[ 2] ≔   6·63942 10819 584921&#9192;-11;
      WW[ 3] ≔   1·75838 89061 345669&#9192;-8;
      WW[ 4] ≔   1·37123 92370 435815&#9192;-6;
      WW[ 5] ≔   4·43509 66639 284350&#9192;-5;
      WW[ 6] ≔   7·15550 10917 718255&#9192;-4;
      WW[ 7] ≔   6·48895 66103 335381&#9192;-3;
      WW[ 8] ≔   3·64404 15875 773282&#9192;-2;
      WW[ 9] ≔   1·43997 92418 590999&#9192;-1;
      WW[10] ≔   8·12311 41336 261486&#9192;-1;
   <u>end</u>;

   EXPON ≔ 0;
   <u>if</u> Z &GreaterSlantEqual; -5·0 ∧ Z &LessSlantEqual; 8 <u>then</u>
   <u>begin</u> U ≔ V ≔ T ≔ UC ≔ VC ≔ TC ≔ 1;
      S ≔ SC ≔ 0·5; N ≔ 0; X ≔ Z × Z × Z;
      <u>for</u> N ≔ N + 3 <u>while</u> ABS(U) + ABS(V) + ABS(S) + ABS(T)&gt; &#9192;-18 <u>do</u>
         <u>begin</u> U ≔ U × X/(N × (N-1)); V ≔ V × X/(N × (N + 1));
            S ≔ S × X/(N × (N + 2)); T ≔ T × X/(N × (N-2));
            UC ≔ UC + U; VC ≔ VC + V; SC ≔ SC + S; TC ≔ TC + T
         <u>end</u>;
      BI ≔ SQRT3 × (C1 × UC + C2 × Z × VC);
      BID ≔ SQRT3 × (C1 × Z × Z × SC + C2 × TC);
      <u>if</u> Z &lt; 2·5 <u>then</u>
      <u>begin</u> AI ≔ C1 × UC - C2 × Z × VC;
         AID ≔ C1 × SC × Z × Z - C2 × TC;
         <u>goto</u> END
      <u>end</u>
   <u>end</u>;

   K1 ≔ K2 ≔ K3 ≔ K4 ≔ 0;
   SQRTZ ≔ SQRT(ABS(Z));
   ZT ≔ 0·66666 66666 66667 × ABS(Z) × SQRTZ;
   C ≔ SQRT1OPI/SQRT(SQRTZ);
   <u>if</u> Z &lt; 0 <u>then</u>
   <u>begin</u> Z ≔ -Z; CO ≔ COS(ZT-PIO4); SI ≔ SIN(ZT-PIO4);
      <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> 10 <u>do</u>
         <u>begin</u> WWL ≔ WW[L]; PL ≔ XX[L]/ZT;
            PL2 ≔ PL × PL; PL1 ≔ 1 + PL2; PL3 ≔ PL1 × PL1;
            K1 ≔ K1 + WWL/PL1;
            K2 ≔ K2 + WWL × PL/PL1;
            K3 ≔ K3 + WWL × PL × (1 + PL × (2/ZT + PL))/PL3;
            K4 ≔ K4 + WWL × (-1-PL × (1 + PL × (ZT-PL))/ZT)/PL3;
         <u>end</u>;
      AI ≔ C × (CO × K1 + SI × K2);
      AID ≔ 0·25 × AI/Z - C × SQRTZ × (CO × K3 + SI × K4);
      BI ≔ C × (CO × K2-SI × K1);
      BID ≔ 0·25 × BI/Z - C × SQRTZ × (CO × K4-SI × K3);
   <u>end</u> <u>else</u>
   <u>begin</u> <u>if</u> Z &lt; 9 <u>then</u> EXPZT ≔ EXP(ZT) <u>else</u>
      <u>begin</u> EXPZT ≔ 1; EXPON ≔ ZT <u>end</u>;
      <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> 10 <u>do</u>
         <u>begin</u> WWL ≔ WW[L]; PL ≔ XX[L]/ZT;
            PL1 ≔ 1 + PL; PL2 ≔ 1-PL;
            K1 ≔ K1 + WWL/PL1;
            K2 ≔ K2 + WWL × PL/(ZT × PL1 × PL1);
            K3 ≔ K3 + WWL/PL2;
            K4 ≔ K4 + WWL × PL/(ZT × PL2 × PL2);
         <u>end</u>;
      AI ≔ 0·5 × C × K1/EXPZT;
      AID ≔ AI × (-·25/Z-SQRTZ) + 0·5 × C × SQRTZ × K2/EXPZT;
      <u>if</u> Z &GreaterSlantEqual; 8 <u>then</u>
      <u>begin</u> BI ≔ C × K3 × EXPZT;
         BID ≔ BI × (SQRTZ-0·25/Z) - C × K4 × SQRTZ × EXPZT;
      <u>end</u>;
   <u>end</u>;
   END:
<u>end</u> AIRY;
<u>comment</u> ================== 35145 ================= ;
<u>real</u> <u>procedure</u> AIRYZEROS(N, D, ZAI, VAI);
   <u>value</u> N, D; <u>integer</u> N, D; <u>array</u> ZAI, VAI;
<u>begin</u> <u>Boolean</u> A, FOUND; <u>integer</u> I;
   <u>real</u> C, E, R, ZAJ, ZAK, VAJ, DAJ, KAJ, ZZ;
   <u>procedure</u> AIRY(A, B, C, D, E, F, G); <u>code</u> 35140;

   A ≔  D = 0 ∨ D = 2;
   R ≔ <u>if</u> D = 0 ∨ D = 3 <u>then</u> -1·1780 97245 09617
   <u>else</u> -3·5342 91735 28852;
   <u>comment</u>  R := i̲f̲ D = 0 ∨ D = 3 t̲h̲e̲n̲ -3 × PI / 8
     e̲l̲s̲e̲ -9 × PI / 8;
   AIRY(0, ZAJ, VAJ, DAJ, KAJ, ZZ, <u>true</u>);
   <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
      <u>begin</u> R ≔ R + 4·7123 88980 38469; <u>comment</u> R := R + 3 × PI / 2;
         ZZ ≔ R × R;
         ZAJ ≔ <u>if</u> I = 1 ∧ D = 1 <u>then</u> -1·01879 297 <u>else</u>
           <u>if</u> I = 1 ∧ D = 2 <u>then</u> -1·17371 322 <u>else</u>
           R ⭡ 0·66666 66666 66667 × ( <u>if</u> A <u>then</u>
           - ( 1 + ( 5/48 - ( 5/36 - ( 77125/82944 - (
           1080 56875 / 69 67296 - (16 23755 96875 / 3344 30208)
           /ZZ)/ZZ)/ZZ)/ZZ)/ZZ)
         <u>else</u>
           - ( 1 - ( 7/48 - ( 35/288 - ( 1 81223 / 2 07360 - (
           186 83371 / 12 44160 - ( 9 11458 84361 / 1911 02976 )
           /ZZ)/ZZ)/ZZ)/ZZ)/ZZ));
         <u>if</u>  D &LessSlantEqual; 1 <u>then</u> AIRY(ZAJ, VAJ, DAJ, C, E, ZZ, <u>false</u>)
         <u>else</u> AIRY(ZAJ, C, E, VAJ, DAJ, ZZ, <u>false</u>);
         FOUND ≔ ABS( <u>if</u> A <u>then</u> VAJ <u>else</u> DAJ ) &lt; &#9192;-12;
         <u>for</u> C ≔ C <u>while</u> ¬FOUND <u>do</u>
            <u>begin</u> <u>if</u> A <u>then</u>
               <u>begin</u> KAJ ≔ VAJ / DAJ;
                  ZAK ≔ ZAJ - KAJ × (1 + ZAJ × KAJ × KAJ)
               <u>end</u> <u>else</u>
               <u>begin</u> KAJ ≔ DAJ / (ZAJ × VAJ);
                  ZAK ≔ ZAJ - KAJ × (1 + KAJ × (KAJ × ZAJ + 1 / ZAJ))
               <u>end</u>;
               <u>if</u>  D &LessSlantEqual; 1 <u>then</u> AIRY(ZAK, VAJ, DAJ, C, E, ZZ, <u>false</u>)
               <u>else</u> AIRY(ZAK, C, E, VAJ, DAJ, ZZ, <u>false</u>);
               FOUND ≔ ABS(ZAK - ZAJ) &lt; &#9192;-14 × ABS(ZAK) ∨
                 ABS(<u>if</u> A <u>then</u> VAJ <u>else</u> DAJ) &lt; &#9192;-12;
               ZAJ ≔ ZAK
            <u>end</u>;
         VAI[I] ≔ <u>if</u> A <u>then</u> DAJ <u>else</u> VAJ;
         ZAI[I] ≔ ZAJ;
      <u>end</u>;
   AIRYZEROS ≔ ZAI[N];
<u>end</u> AIRYZEROS;
<u>comment</u> ================== 31040 ================= ;
<u>real</u> <u>procedure</u> POL(N, X, A);
   <u>value</u> N, X; <u>integer</u> N; <u>real</u> X; <u>array</u> A;
<u>begin</u> <u>real</u> R;
   R ≔ 0;
   <u>for</u> N ≔ N <u>step</u> -1 <u>until</u> 0 <u>do</u>
        R ≔ R × X  + A[N];
   POL ≔ R
<u>end</u> POL;
<u>comment</u> ================== 31241 ================= ;
<u>procedure</u> TAYPOL(N, K, X, A);
   <u>value</u> N, K, X;
   <u>integer</u> N, K; <u>real</u> X; <u>array</u> A;
   <u>if</u> X ≠ 0 <u>then</u>
   <u>begin</u> <u>integer</u> I, J, NM1;
      <u>real</u> XJ, AA, H;
      XJ ≔ 1;
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> XJ ≔ XJ × X; A[J] ≔ A[J] × XJ <u>end</u>;
      AA ≔ A[N]; NM1 ≔ N-1;
      <u>for</u> J ≔ 0 <u>step</u> 1 <u>until</u> K <u>do</u>
         <u>begin</u> H ≔ AA;
            <u>for</u> I ≔ NM1 <u>step</u> -1 <u>until</u> J <u>do</u>
                 H ≔ A[ I] ≔ A[I] + H
         <u>end</u>
   <u>end</u> <u>else</u>
     <u>for</u> K ≔ K <u>step</u> -1 <u>until</u> 1 <u>do</u> A[K] ≔ 0;
<u>comment</u> ================== 31242 ================= ;
<u>procedure</u> NORDERPOL (N, K, X, A);
   <u>value</u> N, K, X;
   <u>integer</u> N, K; <u>real</u> X; <u>array</u> A;
   <u>if</u> X ≠ 0 <u>then</u>
   <u>begin</u> <u>integer</u> I, J, NM1;
      <u>real</u> XJ, AA, H;
      <u>array</u> XX[0:N];
      XJ ≔ 1;
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> XJ ≔ XX[J] ≔ XJ × X; A[J] ≔ A[J] × XJ <u>end</u>;
      H ≔ AA ≔ A[N]; NM1 ≔ N-1;
      <u>for</u> I ≔ NM1 <u>step</u> -1 <u>until</u> 0 <u>do</u> H ≔ A[I] ≔ A[I] + H;
      <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
         <u>begin</u> H ≔ AA;
            <u>for</u> I ≔ NM1 <u>step</u> -1 <u>until</u> J <u>do</u>
                 H ≔ A[ I] ≔ A[I] + H;
            A[J] ≔ H/XX[J]
         <u>end</u>
   <u>end</u> NORDERPOL ;
<u>comment</u> ================== 31243 ================= ;
<u>procedure</u> DERPOL (N, K, X, A);
   <u>value</u> N, K, X;
   <u>integer</u> N, K; <u>real</u> X; <u>array</u> A;
<u>begin</u> <u>integer</u> J; <u>real</u> FAC;
   <u>procedure</u> NORDERPOL(N, K, X, A); <u>code</u> 31242;
   FAC ≔ 1;
   NORDERPOL (N, K, X, A);
   <u>for</u> J ≔ 2 <u>step</u> 1 <u>until</u> K <u>do</u>
      <u>begin</u> FAC ≔ FAC × J; A[J] ≔ A[J] × FAC <u>end</u>
<u>end</u> DERPOL ;
<u>comment</u> ================== 32075 ================= ;
<u>real</u> <u>procedure</u> TRICUB(XI, YI, XJ, YJ, XK, YK, G, RE, AE);
   <u>value</u> XI, YI, XJ, YJ, XK, YK, RE, AE;
   <u>real</u> XI, YI, XJ, YJ, XK, YK, RE, AE; <u>real</u> <u>procedure</u> G;
<u>begin</u> <u>real</u> SURF, SURFMIN, XZ, YZ, GI, GJ, GK;

   <u>real</u> <u>procedure</u> INT(AX1, AY1, AF1, AX2, AY2, AF2, AX3, AY3, AF3,
     BX1, BY1, BF1, BX2, BY2, BF2, BX3, BY3, BF3,
     PX, PY, PF);
      <u>value</u> BX1, BY1, BF1, BX2, BY2, BF2, BX3, BY3, BF3, PX, PY, PF;
      <u>real</u>  BX1, BY1, BF1, BX2, BY2, BF2, BX3, BY3, BF3, PX, PY, PF,
        AX1, AY1, AF1, AX2, AY2, AF2, AX3, AY3, AF3;
   <u>begin</u> <u>real</u> E, I3, I4, I5, A, B, C, SX1, SY1, SX2, SY2, SX3, SY3,
        CX1, CY1, CF1, CX2, CY2, CF2, CX3, CY3, CF3,
        DX1, DY1, DF1, DX2, DY2, DF2, DX3, DY3, DF3;

      A ≔ AF1 + AF2 + AF3; B ≔ BF1 + BF2 + BF3;
      I3 ≔ 3 × A + 27 × PF + 8 × B;
      E ≔ ABS(I3) × RE + AE;

      <u>if</u> SURF &lt; SURFMIN ∨ ABS(5 × A + 45 × PF - I3) &lt; E
        <u>then</u> INT ≔ I3 × SURF <u>else</u>
      <u>begin</u> CX1 ≔ AX1 + PX; CY1 ≔ AY1 + PY; CF1 ≔ G(CX1, CY1);
         CX2 ≔ AX2 + PX; CY2 ≔ AY2 + PY; CF2 ≔ G(CX2, CY2);
         CX3 ≔ AX3 + PX; CY3 ≔ AY3 + PY; CF3 ≔ G(CX3, CY3);
         C ≔ CF1 + CF2 + CF3;
         I4 ≔ A + 9 × PF + 4 × B + 12 × C;

         <u>if</u> ABS(I3 - I4) &lt; E <u>then</u> INT ≔ I4 × SURF <u>else</u>
         <u>begin</u> SX1 ≔ ·5 × BX1; SY1 ≔ ·5 × BY1;
            DX1 ≔ AX1 + SX1; DY1 ≔ AY1 + SY1; DF1 ≔ G(DX1, DY1);
            SX2 ≔  ·5 × BX2; SY2 ≔  ·5 × BY2;
            DX2 ≔ AX2 + SX2; DY2 ≔ AY2 + SY2; DF2 ≔ G(DX2, DY2);
            SX3 ≔  ·5 × BX3; SY3 ≔  ·5 × BY3;
            DX3 ≔ AX3 + SX3; DY3 ≔ AY3 + SY3; DF3 ≔ G(DX3, DY3);

            I5 ≔ (51 × A + 2187 × PF + 276 × B + 972 × C -
              768 × (DF1 + DF2 + DF3))/63;
            <u>if</u> ABS(I4 - I5) &lt; E <u>then</u> INT ≔ I5 × SURF <u>else</u>
            <u>begin</u> SURF ≔ ·25 × SURF;

               INT ≔ 
                 INT(SX1, SY1, BF1, SX2, SY2, BF2, SX3, SY3, BF3,
                 DX1, DY1, DF1, DX2, DY2, DF2, DX3, DY3, DF3,
                 PX, PY, PF) +

                 INT(AX1, AY1, AF1, SX3, SY3, BF3, SX2, SY2, BF2, DX1, DY1, DF1,
                 AX1 + SX2, AY1 + SY2, G(AX1 + SX2, AY1 + SY2),
                 AX1 + SX3, AY1 + SY3, G(AX1 + SX3, AY1 + SY3),·5 × CX1, ·5 × CY1, CF1) +
                 INT(AX2, AY2, AF2, SX3, SY3, BF3, SX1, SY1, BF1, DX2, DY2, DF2,
                 AX2 + SX1, AY2 + SY1, G(AX2 + SX1, AY2 + SY1),
                 AX2 + SX3, AY2 + SY3, G(AX2 + SX3, AY2 + SY3),·5 × CX2, ·5 × CY2, CF2) +
                 INT(AX3, AY3, AF3, SX1, SY1, BF1, SX2, SY2, BF2, DX3, DY3, DF3,
                 AX3 + SX2, AY3 + SY2, G(AX3 + SX2, AY3 + SY2),
                 AX3 + SX1, AY3 + SY1, G(AX3 + SX1, AY3 + SY1),·5 × CX3, ·5 × CY3, CF3);

               SURF ≔ 4 × SURF
            <u>end</u>
         <u>end</u>
      <u>end</u>
   <u>end</u> INT;

   SURF ≔ 0·5 × ABS(XJ × YK - XK × YJ + XI × YJ -
     XJ × YI + XK × YI - XI × YK);
   SURFMIN ≔ SURF × RE; RE ≔ 30 × RE; AE ≔ 30 × AE/SURF;
   XZ ≔ (XI + XJ + XK)/3; YZ ≔ (YI + YJ + YK)/3;
   GI ≔ G(XI, YI); GJ ≔ G(XJ, YJ); GK ≔ G(XK, YK);
   XI ≔ XI × ·5; YI ≔ YI × ·5; XJ ≔ XJ × ·5;
   YJ ≔ YJ × ·5; XK ≔ XK × ·5; YK ≔ YK × ·5;

   TRICUB ≔ INT(XI, YI, GI, XJ, YJ, GJ, XK, YK, GK,
     XJ + XK, YJ + YK, G(XJ + XK, YJ + YK),
     XK + XI, YK + YI, G(XK + XI, YK + YI),
     XI + XJ, YI + YJ, G(XI + XJ, YI + YJ),·5 × XZ, ·5 × YZ, G(XZ, YZ))/60
<u>end</u> TRICUB;
<u>comment</u> ================== 34444 ================= ;
<u>procedure</u> PEIDE(N, M, NOBS, NBP, PAR, RES, BP, JTJINV, IN, OUT, DERIV, JAC DFDY,
  JAC DFDP, CALL YSTART, DATA, MONITOR);
   <u>value</u> N, M, NOBS; <u>integer</u> N, M, NOBS, NBP;
     <u>array</u> PAR, RES, JTJINV, IN, OUT;
     <u>integer</u> <u>array</u> BP;
     <u>procedure</u>  CALL YSTART, DATA, MONITOR;
     <u>Boolean</u> <u>procedure</u> DERIV, JAC DFDY, JACDFDP;
<u>begin</u> <u>integer</u> I, J, EXTRA, WEIGHT, NCOL, NROW, AWAY, NPAR, II, JJ, MAX,
     NFE, NIS;
   <u>real</u> EPS, EPS1, XEND, C, X, T, HMIN, HMAX, RES1, IN3, IN4, FAC3, FAC4;
   <u>array</u> AUX[1:3], OBS[1:NOBS], SAVE[-38:6 × N], TOBS[0:NOBS],
     YP[1:NBP + NOBS, 1:NBP + M], YMAX[1:N], Y[1:6 × N × (NBP + M + 1)], FY[1:N, 1:N],
     FP[1:N, 1:M + NBP];
   <u>integer</u> <u>array</u> COBS[1:NOBS];
   <u>Boolean</u> FIRST, SEC, CLEAN;

   <u>procedure</u> INIVEC(L, U, A, X); <u>code</u> 31010;
   <u>procedure</u> INIMAT(L1, U1, L2, U2, A, X); <u>code</u> 31011;
   <u>procedure</u> MULVEC(L, U, S, A, B, X); <u>code</u> 31020;
   <u>procedure</u> MULROW(L, U, I, J, A, B, X); <u>code</u> 31021;
   <u>procedure</u> DUPVEC(L, U, S, A, B); <u>code</u> 31030;
   <u>procedure</u> DUPMAT(L1, U1, L2, U2, A, B); <u>code</u> 31035;
   <u>real</u> <u>procedure</u> VECVEC(L, U, S, A, B); <u>code</u> 34010;
   <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> ELMVEC(L, U, S, A, B, X); <u>code</u> 34020;
   <u>procedure</u> SOL(A, N, P, B); <u>code</u> 34051;
   <u>procedure</u> DEC(A, N, AUX, P); <u>code</u> 34300;
   <u>procedure</u> MARQUARDT(M, N, P, R, C, F, J, I, O); <u>code</u> 34440;

   <u>real</u> <u>procedure</u> INTERPOL(STARTINDEX, JUMP, K, TOBSDIF);
      <u>value</u> STARTINDEX, JUMP, K, TOBSDIF;
      <u>integer</u> STARTINDEX, JUMP, K; <u>real</u> TOBSDIF;
   <u>begin</u> <u>integer</u> I; <u>real</u> S, R; S ≔ Y[STARTINDEX]; R ≔ TOBSDIF;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> K <u>do</u>
         <u>begin</u> STARTINDEX ≔ STARTINDEX + JUMP;
            S ≔ S + Y[STARTINDEX] × R; R ≔ R × TOBSDIF
         <u>end</u>; INTERPOL ≔ S
   <u>end</u> INTERPOL;

   <u>procedure</u> JAC DYDP(NROW, NCOL, PAR, RES, JAC, LOCFUNCT);
      <u>value</u> NROW, NCOL; <u>integer</u> NROW, NCOL;
        <u>array</u> PAR, RES, JAC; <u>procedure</u> LOCFUNCT;
   <u>begin</u>
      DUPMAT(1, NROW, 1, NCOL, JAC, YP)
   <u>end</u> JACOBIAN;
   <u>Boolean</u> <u>procedure</u> FUNCT(NROW, NCOL, PAR, RES);
      <u>value</u> NROW, NCOL; <u>integer</u> NROW, NCOL; <u>array</u> PAR, RES;
   <u>begin</u> <u>integer</u> L, K, KNEW, FAILS, SAME, KPOLD, N6, NNPAR, J5N,
        COBSII;
      <u>real</u> XOLD, HOLD, A0, TOLUP, TOL, TOLDWN, TOLCONV, H, CH, CHNEW,
        ERROR, DFI, TOBSDIF;
      <u>Boolean</u> EVALUATE, EVALUATED, DECOMPOSE, CONV;
      <u>array</u> A[0:5], DELTA, LAST DELTA, DF, Y0[1:N], JACOB[1:N, 1:N];
      <u>integer</u> <u>array</u> P[1:N];

      <u>real</u> <u>procedure</u> NORM2(AI); <u>real</u> AI;
      <u>begin</u> <u>real</u> S, A; S ≔ &#9192;-100;
         <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> A ≔ AI/YMAX[I]; S ≔ S + A × A <u>end</u>;
         NORM2 ≔ S
      <u>end</u> NORM2;

      <u>procedure</u> RESET;
      <u>begin</u> <u>if</u> CH &lt; HMIN/HOLD <u>then</u> CH ≔ HMIN/HOLD <u>else</u>
         <u>if</u> CH &gt; HMAX/HOLD <u>then</u> CH ≔ HMAX/HOLD;
         X ≔ XOLD; H ≔ HOLD × CH; C ≔ 1;
         <u>for</u> J ≔ 0 <u>step</u> N <u>until</u> K × N <u>do</u>
            <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    Y[J + I] ≔ SAVE[J + I] × C;
               C ≔ C × CH
            <u>end</u>;
         DECOMPOSE ≔ <u>true</u>
      <u>end</u> RESET;

      <u>procedure</u> ORDER;
      <u>begin</u> C ≔ EPS × EPS; J ≔ (K-1) × (K + 8)/2 - 38;
         <u>for</u> I ≔ 0 <u>step</u> 1 <u>until</u> K <u>do</u> A[I] ≔ SAVE[I + J];
         J ≔ J + K + 1;
         TOLUP  ≔ C × SAVE[J];
         TOL    ≔ C × SAVE[J + 1];
         TOLDWN ≔ C × SAVE[J + 2];
         TOLCONV ≔ EPS/(2 × N × (K + 2));
         A0 ≔ A[0];  DECOMPOSE ≔ <u>true</u>;
      <u>end</u> ORDER;

      <u>procedure</u> EVALUATE JACOBIAN;
      <u>begin</u> EVALUATE ≔ <u>false</u>;
         DECOMPOSE ≔ EVALUATED ≔ <u>true</u>;
         <u>if</u> ¬JAC DFDY(PAR, Y, X, FY) <u>then</u>
         <u>begin</u> SAVE[-3] ≔ 4; <u>goto</u> RETURN <u>end</u>;
      <u>end</u> EVALUATE JACOBIAN;
      <u>procedure</u> DECOMPOSE JACOBIAN;
      <u>begin</u> DECOMPOSE ≔ <u>false</u>;
         C ≔ -A0 × H;
         <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                    JACOB[I, J] ≔ FY[I, J] × C;
               JACOB[J, J] ≔ JACOB[J, J] + 1
            <u>end</u>;
         DEC(JACOB, N, AUX, P)
      <u>end</u> DECOMPOSE JACOBIAN;

      <u>procedure</u> CALCULATE STEP AND ORDER;
      <u>begin</u> <u>real</u> A1, A2, A3;
         A1 ≔ <u>if</u> K &LessSlantEqual; 1 <u>then</u> 0 <u>else</u>
           0·75 × (TOLDWN/NORM2(Y[K × N + I])) ⭡ (0·5/K);
         A2 ≔ 0·80 × (TOL/ERROR) ⭡ (0·5/(K + 1));
         A3 ≔ <u>if</u> K &GreaterSlantEqual; 5 ∨ FAILS ≠ 0
           <u>then</u> 0 <u>else</u>
           0·70 × (TOLUP/NORM2(DELTA[I] - LAST DELTA[I]))⭡
           (0·5/(K + 2));

         <u>if</u> A1 &gt; A2 ∧ A1 &gt; A3 <u>then</u>
         <u>begin</u> KNEW ≔ K-1; CHNEW ≔ A1 <u>end</u> <u>else</u>
         <u>if</u> A2 &gt; A3 <u>then</u>
         <u>begin</u> KNEW ≔ K  ; CHNEW ≔ A2 <u>end</u> <u>else</u>
         <u>begin</u> KNEW ≔ K + 1; CHNEW ≔ A3 <u>end</u>
      <u>end</u> CALCULATE STEP AND ORDER;

      <u>if</u> SEC <u>then</u> <u>begin</u> SEC ≔ <u>false</u>; <u>goto</u> RETURN <u>end</u>;
      NPAR ≔ M; EXTRA ≔ NIS ≔ 0; II ≔ 1;
      JJ ≔ <u>if</u> NBP = 0 <u>then</u> 0 <u>else</u> 1;
      N6 ≔ N × 6;
      INIVEC(-3, -1, SAVE, 0);
      INIVEC(N6 + 1, (6 + M) × N, Y, 0);
      INIMAT(1, NOBS + NBP, 1, M + NBP, YP, 0);
      T ≔ TOBS[1]; X ≔ TOBS[0];
      CALL YSTART(PAR, Y, YMAX);
      HMAX ≔ TOBS[1]-TOBS[0]; HMIN ≔ HMAX × IN[1];
      EVALUATE JACOBIAN; NNPAR ≔ N × NPAR;

      NEW START:
      K ≔ 1; KPOLD ≔ 0; SAME ≔ 2; ORDER;
      <u>if</u> ¬DERIV(PAR, Y, X, DF) <u>then</u>
      <u>begin</u> SAVE[-3] ≔ 3; <u>goto</u> RETURN <u>end</u>;
      H ≔ SQRT(2 × EPS/SQRT(NORM2 (MATVEC(1, N, I, FY, DF))));
      <u>if</u> H &gt; HMAX <u>then</u> H ≔ HMAX <u>else</u>
      <u>if</u> H &lt; HMIN <u>then</u> H ≔ HMIN;
      XOLD ≔ X; HOLD ≔ H; CH ≔ 1;
      <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> SAVE[I] ≔ Y[I]; SAVE[N + I] ≔ Y[N + I] ≔ DF[I] × H <u>end</u>;
      FAILS ≔ 0;
      <u>for</u> L ≔ 0 <u>while</u> X &lt; XEND <u>do</u>
         <u>begin</u> <u>if</u> X + H &LessSlantEqual; XEND <u>then</u> X ≔ X + H <u>else</u>
            <u>begin</u> H ≔ XEND-X; X ≔ XEND; CH ≔ H/HOLD; C ≔ 1;
               <u>for</u> J ≔ N <u>step</u> N <u>until</u> K × N <u>do</u>
                  <u>begin</u> C ≔ C × CH;
                     <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> J + N <u>do</u>
                          Y[I] ≔ Y[I] × C
                  <u>end</u>;
               SAME ≔ <u>if</u> SAME &lt; 3 <u>then</u> 3 <u>else</u> SAME + 1;
            <u>end</u>;

            <u>comment</u> PREDICTION;
            <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> <u>for</u> I ≔ L <u>step</u> N <u>until</u> (K-1) × N + L <u>do</u>
                       <u>for</u> J ≔ (K-1) × N + L <u>step</u> -N <u>until</u> I <u>do</u>
                          Y[J] ≔ Y[J] + Y[J + N];
                  DELTA[L] ≔ 0
               <u>end</u>;  EVALUATED ≔ <u>false</u>;

            <u>comment</u> CORRECTION AND ESTIMATION LOCAL ERROR;
            <u>for</u> L ≔ 1, 2, 3 <u>do</u>
               <u>begin</u> <u>if</u> ¬DERIV(PAR, Y, X, DF) <u>then</u>
                  <u>begin</u> SAVE[-3] ≔ 3; <u>goto</u> RETURN <u>end</u>;
                  <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                       DF[I] ≔ DF[I] × H - Y[N + I];
                  <u>if</u> EVALUATE <u>then</u> EVALUATE JACOBIAN;
                  <u>if</u> DECOMPOSE <u>then</u> DECOMPOSE JACOBIAN;
                  SOL(JACOB, N, P, DF);

                  CONV ≔ <u>true</u>;
                  <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                     <u>begin</u> DFI ≔ DF[I];
                        Y[  I] ≔ Y[  I] + A0 × DFI;
                        Y[N + I] ≔ Y[N + I] +      DFI;
                        DELTA[I] ≔ DELTA[I] +  DFI;
                        CONV ≔ CONV ∧ ABS(DFI) &lt; TOLCONV × YMAX[I]
                     <u>end</u>;
                  <u>if</u> CONV <u>then</u>
                  <u>begin</u> ERROR ≔ NORM2(DELTA[I]);
                     <u>goto</u> CONVERGENCE
                  <u>end</u>
               <u>end</u>;

            <u>comment</u> ACCEPTANCE OR REJECTION;
            <u>if</u> ¬CONV <u>then</u>
            <u>begin</u> <u>if</u> ¬EVALUATED <u>then</u> EVALUATE ≔ <u>true</u>
               <u>else</u>
               <u>begin</u> CH ≔ CH/4; <u>if</u> H &lt; 4 × HMIN <u>then</u>
                  <u>begin</u> SAVE[-1] ≔ SAVE[-1] + 10;
                     HMIN ≔ HMIN/10;
                     <u>if</u> SAVE[-1] &gt; 40 <u>then</u> <u>goto</u> RETURN
                  <u>end</u>
               <u>end</u>;
               RESET
            <u>end</u> <u>else</u> CONVERGENCE:

            <u>if</u> ERROR &gt; TOL <u>then</u>
            <u>begin</u> FAILS ≔ FAILS + 1;
               <u>if</u> H &gt; 1·1 × HMIN <u>then</u>
               <u>begin</u> <u>if</u> FAILS &gt; 2 <u>then</u>
                  <u>begin</u>  RESET; <u>goto</u> NEW START
                  <u>end</u> <u>else</u>
                  <u>begin</u> CALCULATE STEP AND ORDER;
                     <u>if</u> KNEW ≠ K <u>then</u>
                     <u>begin</u> K ≔ KNEW; ORDER <u>end</u>;
                     CH ≔ CH × CHNEW; RESET
                  <u>end</u>
               <u>end</u> <u>else</u>
               <u>begin</u> <u>if</u> K = 1 <u>then</u>
                  <u>begin</u> <u>comment</u> VIOLATE EPS CRITERION;
                     SAVE[-2] ≔ SAVE[-2] + 1;
                     SAME ≔ 4; <u>goto</u> ERROR TEST OK
                  <u>end</u>;
                  K ≔ 1; RESET; ORDER; SAME ≔ 2
               <u>end</u>
            <u>end</u> <u>else</u> ERROR TEST OK:

            <u>begin</u> FAILS ≔ 0;
               <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                  <u>begin</u> C ≔ DELTA[I];
                     <u>for</u> L ≔ 2 <u>step</u> 1 <u>until</u> K <u>do</u>
                          Y[L × N + I] ≔ Y[L × N + I] + A[L] × C;
                     <u>if</u> ABS(Y[I]) &gt; YMAX[I] <u>then</u>
                       YMAX[I] ≔  ABS(Y[I])
                  <u>end</u>;

               SAME ≔ SAME-1;
               <u>if</u> SAME = 1 <u>then</u>
                 DUPVEC(1, N, 0, LAST DELTA, DELTA) <u>else</u>
               <u>if</u> SAME = 0 <u>then</u>
               <u>begin</u> CALCULATE STEP AND ORDER;
                  <u>if</u> CHNEW &gt; 1·1 <u>then</u>
                  <u>begin</u>
                     <u>if</u> K ≠ KNEW <u>then</u>
                     <u>begin</u> <u>if</u> KNEW &gt; K <u>then</u>
                          MULVEC(KNEW × N + 1, KNEW × N + N, -KNEW × N, Y, DELTA,
                          A[K]/KNEW);
                        K ≔ KNEW; ORDER
                     <u>end</u>;
                     SAME ≔ K + 1;
                     <u>if</u> CHNEW × H &gt; HMAX
                       <u>then</u> CHNEW ≔ HMAX/H;
                     H ≔ H × CHNEW; C ≔ 1;
                     <u>for</u> J ≔ N <u>step</u> N <u>until</u> K × N <u>do</u>
                        <u>begin</u> C ≔ C × CHNEW;
                           MULVEC(J + 1, J + N, 0, Y, Y, C)
                        <u>end</u>; DECOMPOSE ≔ <u>true</u>
                  <u>end</u>
                  <u>else</u> SAME ≔ 10
               <u>end</u> OF A SINGLE INTEGRATION STEP OF Y;
               NIS ≔ NIS + 1;

               <u>comment</u> START OF A INTEGRATION STEP OF YP;
               <u>if</u> CLEAN <u>then</u>
               <u>begin</u> HOLD ≔ H; XOLD ≔ X; KPOLD ≔ K; CH ≔ 1;
                  DUPVEC(1, K × N + N, 0, SAVE, Y)
               <u>end</u> <u>else</u>
               <u>begin</u> <u>if</u> H ≠ HOLD <u>then</u>
                  <u>begin</u> CH ≔ H/HOLD; C ≔ 1;
                     <u>for</u> J ≔ N6 + NNPAR <u>step</u> NNPAR <u>until</u>
                       KPOLD × NNPAR + N6 <u>do</u>
                        <u>begin</u> C ≔ C × CH;
                           <u>for</u> I ≔ J + 1 <u>step</u> 1 <u>until</u> J + NNPAR <u>do</u>
                                Y[I] ≔ Y[I] × C
                        <u>end</u>; HOLD ≔ H
                  <u>end</u>;
                  <u>if</u> K &gt; KPOLD <u>then</u>
                    INIVEC(N6 + K × NNPAR + 1, N6 + K × NNPAR + NNPAR, Y, 0);
                  XOLD ≔ X; KPOLD ≔ K; CH ≔ 1;
                  DUPVEC(1, K × N + N, 0, SAVE, Y);
                  EVALUATE JACOBIAN;
                  DECOMPOSE JACOBIAN;
                  <u>if</u> ¬JAC DFDP(PAR, Y, X, FP) <u>then</u>
                  <u>begin</u> SAVE[-3] ≔ 5; <u>goto</u> RETURN <u>end</u>;
                  <u>if</u> NPAR &gt; M <u>then</u> INIMAT(1, N, M + 1, NPAR, FP, 0);

                  <u>comment</u> PREDICTION;
                  <u>for</u> L ≔ 0 <u>step</u> 1 <u>until</u> K-1 <u>do</u>
                       <u>for</u> J ≔ K-1 <u>step</u> -1 <u>until</u> L <u>do</u>
                          ELMVEC(J × NNPAR + N6 + 1, J × NNPAR + N6 + NNPAR, NNPAR, Y, Y, 1);

                  <u>comment</u> CORRECTION;
                  <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> NPAR <u>do</u>
                     <u>begin</u> J5N ≔ (J + 5) × N;
                        DUPVEC(1, N, J5N, Y0, Y);
                        <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u> DF[I] ≔                              H × (FP[I, J] + MATVEC(1, N, I, FY, Y0))
                             -Y[NNPAR + J5N + I];
                        SOL(JACOB, N, P, DF);
                        <u>for</u> L ≔ 0 <u>step</u> 1 <u>until</u> K <u>do</u>
                           <u>begin</u> I ≔ L × NNPAR + J5N;
                              ELMVEC(I + 1, I + N, -I, Y, DF, A[L])
                           <u>end</u>
                     <u>end</u>
               <u>end</u>;
               <u>for</u> L ≔ 0 <u>while</u> X &GreaterSlantEqual; T <u>do</u>
                  <u>begin</u>
                     <u>comment</u> CALCULATION OF A ROW OF THE JACOBIAN
                       MATRIX AND AN ELEMENT OF THE RESIDUAL
                       VECTOR;
                     TOBSDIF ≔ (TOBS[II]-X)/H; COBSII ≔ COBS[II];
                     RES[II] ≔ INTERPOL(COBSII, N, K, TOBSDIF)-OBS[II];
                     <u>if</u> ¬CLEAN <u>then</u>
                     <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> NPAR <u>do</u>
                             YP[II, I] ≔ INTERPOL(COBSII + (I + 5) × N, NNPAR, K,
                             TOBSDIF);

                        <u>comment</u> INTRODUCING OF BREAK-POINTS;
                        <u>if</u> BP[JJ] ≠ II <u>then</u> <u>else</u>
                        <u>if</u> FIRST ∧ ABS(RES[II]) &lt; EPS1 <u>then</u>
                        <u>begin</u> NBP ≔ NBP-1; DUPVEC(JJ, NBP, 1, BP, BP);
                           BP[NBP + 1] ≔ 0
                        <u>end</u> <u>else</u>
                        <u>begin</u> EXTRA ≔ EXTRA + 1;
                           <u>if</u> FIRST <u>then</u> PAR[M + JJ] ≔ OBS[II];
                           <u>comment</u> INTRODUCING A JACOBIAN ROW AND A
                             RESIDUAL VECTOR ELEMENT FOR
                             CONTINUITY REQUIREMENTS;
                           YP[NOBS + JJ, M + JJ] ≔ -WEIGHT;
                           MULROW(1, NPAR, NOBS + JJ, II, YP, YP, WEIGHT);
                           RES[NOBS + JJ] ≔ WEIGHT × (RES[II] + OBS[II]-
                             PAR[M + JJ])
                        <u>end</u>
                     <u>end</u>;

                     <u>if</u> II = NOBS <u>then</u> <u>goto</u> RETURN <u>else</u>
                     <u>begin</u> T ≔ TOBS[II + 1];
                        <u>if</u> BP[JJ] = II ∧ JJ &lt; NBP <u>then</u> JJ ≔ JJ + 1;
                        HMAX ≔ T-TOBS[II]; HMIN ≔ HMAX × IN[1]; II ≔ II + 1
                     <u>end</u>;
                  <u>end</u>;

               <u>comment</u> BREAK-POINTS INTRODUCE NEW INITIAL VALUES
                 FOR Y AND YP;
               <u>if</u> EXTRA &gt; 0 <u>then</u>
               <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
                     <u>begin</u> Y[I] ≔ INTERPOL(I, N, K, TOBSDIF);
                        <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> NPAR <u>do</u>
                             Y[I + (J + 5) × N] ≔ INTERPOL(I + (J + 5) × N, NNPAR, K,
                             TOBSDIF)
                     <u>end</u>;
                  <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> EXTRA <u>do</u>
                     <u>begin</u>  COBSII ≔ COBS[BP[NPAR-M + L]];
                        Y[COBSII] ≔ PAR[NPAR + L];
                        <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> NPAR + EXTRA <u>do</u>
                             Y[COBSII + (5 + I) × N] ≔ 0;
                        INIVEC(1 + NNPAR + (L + 5) × N, NNPAR + (L + 6) × N, Y, 0);
                        Y[COBSII + (5 + NPAR + L) × N] ≔ 1
                     <u>end</u>;
                  NPAR ≔ NPAR + EXTRA; EXTRA ≔ 0;
                  X ≔ TOBS[II-1]; EVALUATE JACOBIAN; NNPAR ≔ N × NPAR;
                  <u>goto</u> NEW START
               <u>end</u>
            <u>end</u>
         <u>end</u> STEP;

      RETURN:
      <u>if</u> SAVE[-2] &gt; MAX <u>then</u> MAX ≔ SAVE[-2];
      FUNCT ≔ SAVE[-1] &LessSlantEqual; 40 ∧ SAVE[-3] = 0;
      <u>if</u> ¬FIRST <u>then</u>
        MONITOR(1, NCOL, NROW, PAR, RES, WEIGHT, NIS)
   <u>end</u> FUNCT;
   I ≔ -39;
   <u>for</u> C ≔ 1, 1, 9, 4, 0, 2/3, 1, 1/3, 36, 20·25, 1, 6/11,
     1, 6/11, 1/11, 84·028, 53·778, 0·25, ·48, 1, ·7, ·2, ·02,
     156·25, 108·51, ·027778, 120/274, 1, 225/274,
     85/274, 15/274, 1/274, 0, 187·69, ·0047361
     <u>do</u> <u>begin</u> I ≔ I + 1; SAVE[I] ≔ C <u>end</u>;

   DATA(NOBS, TOBS, OBS, COBS); WEIGHT ≔ 1;
   FIRST ≔ SEC ≔ <u>false</u>; CLEAN ≔ NBP &gt; 0;
   AUX[2] ≔ &#9192;-12; EPS ≔ IN[2]; EPS1 ≔ &#9192;10;
   XEND ≔ TOBS[NOBS]; OUT[1] ≔ 0; BP[0] ≔ MAX ≔ 0;

   <u>comment</u> SMOOTH INTEGRATION WITHOUT BREAK-POINTS;
   <u>if</u> ¬FUNCT(NOBS, M, PAR, RES) <u>then</u> <u>goto</u> ESCAPE;
   RES1 ≔ SQRT(VECVEC(1, NOBS, 0, RES, RES)); NFE ≔ 1;
   <u>if</u> IN[5] = 1 <u>then</u>
   <u>begin</u> OUT[1] ≔ 1; <u>goto</u> ESCAPE <u>end</u>;

   <u>if</u> CLEAN <u>then</u>
   <u>begin</u> FIRST ≔ <u>true</u>; CLEAN ≔ <u>false</u>;
      FAC3 ≔ SQRT(SQRT(IN[3]/RES1)); FAC4 ≔ SQRT(SQRT(IN[4]/RES1));
      EPS1 ≔ RES1 × FAC4;
      <u>if</u> ¬FUNCT(NOBS, M, PAR, RES) <u>then</u> <u>goto</u> ESCAPE;
      FIRST ≔ <u>false</u>
   <u>end</u> <u>else</u> NFE ≔ 0;

   NCOL ≔ M + NBP; NROW ≔ NOBS + NBP;
   SEC ≔ <u>true</u>;
   IN3 ≔ IN[3]; IN4 ≔ IN[4]; IN[3] ≔ RES1;

   <u>begin</u> <u>real</u> W; <u>array</u> AID[1:NCOL, 1:NCOL];
      WEIGHT ≔ AWAY ≔ 0;
      OUT[4] ≔ OUT[5] ≔ W ≔ 0;
      <u>for</u> WEIGHT ≔ (SQRT(WEIGHT) + 1)⭡2 <u>while</u>
        WEIGHT ≠ 16 ∧ NBP &gt; 0 <u>do</u>

         <u>begin</u> <u>if</u> AWAY = 0 ∧ W ≠ 0 <u>then</u>
            <u>begin</u> <u>comment</u> IF NO BREAK-POINTS WERE OMITTED THEN ONE
                 FUNCTION EVALUATION IS SAVED;
               W ≔ WEIGHT/W;
               <u>for</u> I ≔ NOBS + 1 <u>step</u> 1 <u>until</u> NROW <u>do</u>
                  <u>begin</u> <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> NCOL <u>do</u>
                          YP[I, J] ≔ W × YP[I, J];
                     RES[I] ≔ W × RES[I]
                  <u>end</u>; SEC ≔ <u>true</u>; NFE ≔ NFE-1
            <u>end</u>;

            IN[3] ≔ IN[3] × FAC3 × WEIGHT; IN[4] ≔ EPS1;
            MONITOR(2, NCOL, NROW, PAR, RES, WEIGHT, NIS);
            MARQUARDT(NROW, NCOL, PAR, RES, AID, FUNCT, JAC DYDP, IN, OUT);
            <u>if</u> OUT[1] &gt; 0 <u>then</u> <u>goto</u> ESCAPE;

            <u>comment</u> THE RELATIVE STARTING VALUE OF LAMBDA IS
              ADJUSTED TO THE LAST VALUE OF LAMBDA USED;
            AWAY ≔ OUT[4]-OUT[5]-1;
            IN[6] ≔ IN[6] × 5⭡AWAY × 2⭡(AWAY-OUT[5]);

            NFE ≔ NFE + OUT[4];
            W ≔ WEIGHT; EPS1 ≔ (SQRT(WEIGHT) + 1)⭡2 × IN[4] × FAC4;
            AWAY ≔ 0;

            <u>comment</u> USELESS BREAK-POINTS ARE OMITTED;
            <u>for</u> J ≔ 1 <u>step</u> 1 <u>until</u> NBP <u>do</u>
               <u>begin</u> <u>if</u> ABS(OBS[BP[J]] + RES[BP[J]]-PAR[J + M]) &lt; EPS1
                    <u>then</u>
                  <u>begin</u> NBP ≔ NBP-1; DUPVEC(J, NBP, 1, BP, BP);
                     DUPVEC(J + M, NBP + M, 1, PAR, PAR);
                     J ≔ J-1; AWAY ≔ AWAY + 1; BP[NBP + 1] ≔ 0
                  <u>end</u>
               <u>end</u>;
            NCOL ≔ NCOL-AWAY; NROW ≔ NROW-AWAY
         <u>end</u>;

      IN[3] ≔ IN3; IN[4] ≔ IN4; NBP ≔ 0; WEIGHT ≔ 1;
      MONITOR(2, M, NOBS, PAR, RES, WEIGHT, NIS);
      MARQUARDT(NOBS, M, PAR, RES, JTJINV, FUNCT, JAC DYDP, IN, OUT);
      NFE ≔ OUT[4] + NFE
   <u>end</u>;
   ESCAPE: <u>if</u> OUT[1] = 3 <u>then</u> OUT[1] ≔ 2 <u>else</u>
   <u>if</u> OUT[1] = 4 <u>then</u> OUT[1] ≔ 6;
   <u>if</u> SAVE[-3] ≠ 0 <u>then</u> OUT[1] ≔ SAVE[-3];
   OUT[3] ≔ RES1;
   OUT[4] ≔ NFE;
   OUT[5] ≔ MAX
<u>end</u> PEIDE;
<u>comment</u> ================== 33300 ================= ;
<u>procedure</u> FEM LAG SYM(X, Y, N, P, R, F, ORDER, E);
   <u>integer</u> N, ORDER;
     <u>real</u> <u>procedure</u> P, R, F;
     <u>array</u> X, Y, E;
<u>begin</u> <u>integer</u> L, L1;
   <u>real</u> XL1, XL, H, A12, B1, B2, TAU1, TAU2, CH, TL, G, YL, PP,
     P1, P2, P3, P4, R1, R2, R3, R4, F1, F2, F3, F4,
     E1, E2, E3, E4, E5, E6;
   <u>array</u> T, SUB, CHI, GI[0:N-1];

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 1;
   <u>begin</u> <u>real</u>  H2;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> P2 ≔ P(XL1); R2 ≔ R(XL1); F2 ≔ F(XL1) <u>end</u>;
      P1 ≔ P2; P2 ≔ P(XL); R1 ≔ R2; R2 ≔ R(XL); F1 ≔ F2; F2 ≔ F(XL);
      H2 ≔ H/2; B1 ≔ H2 × F1; B2 ≔ H2 × F2; TAU1 ≔ H2 × R1; TAU2 ≔ H2 × R2;
      A12 ≔ -0·5 × (P1 + P2)/H
   <u>end</u> ELAN. M.V. EV.;

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 2;
   <u>begin</u> <u>real</u>  X2, H6, H15, B3, TAU3, C12, C32, A13, A22, A23;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> P3 ≔ P(XL1); R3 ≔ R(XL1); F3 ≔ F(XL1) <u>end</u>;
      X2 ≔ (XL1 + XL)/2; H6 ≔ H/6; H15 ≔ H/1·5;
      P1 ≔ P3; P2 ≔ P(X2); P3 ≔ P(XL);
      R1 ≔ R3; R2 ≔ R(X2); R3 ≔ R(XL);
      F1 ≔ F3; F2 ≔ F(X2); F3 ≔ F(XL);
      B1 ≔ H6 × F1; B2 ≔ H15 × F2; B3 ≔ H6 × F3;
      TAU1 ≔ H6 × R1; TAU2 ≔ H15 × R2; TAU3 ≔ H6 × R3;
      A12 ≔ -(2 × P1 + P3/1·5)/H; A13 ≔ (0·5 × (P1 + P3) - P2/1·5)/H;
      A22 ≔ (P1 + P3)/H/0·375 + TAU2; A23 ≔ -(P1/3 + P3) × 2/H;
      <u>comment</u> STATIC CONDENSATION;
      C12 ≔ - A12/A22; C32 ≔ - A23/A22; A12 ≔ A13 + C32 × A12;
      B1 ≔ B1 + C12 × B2; B2 ≔ B3 + C32 × B2;
      TAU1 ≔ TAU1 + C12 × TAU2; TAU2 ≔ TAU3 + C32 × TAU2
   <u>end</u> ELEMENT MAT VEC EVALUATION 2;

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 3;
   <u>begin</u> <u>real</u>  X2, X3, H12, H24, DET, C12, C13, C42, C43,
        A13, A14, A22, A23, A24, A33, A34, B3, B4, TAU3, TAU4;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> P4 ≔ P(XL1); R4 ≔ R(XL1); F4 ≔ F(XL1) <u>end</u>;
      X2 ≔ XL1 + 0·27639320225 × H; X3 ≔ XL - X2 + XL1;
      H12 ≔ H/12; H24 ≔ H/2·4;
      P1 ≔ P4; P2 ≔ P(X2); P3 ≔ P(X3); P4 ≔ P(XL);
      R1 ≔ R4; R2 ≔ R(X2); R3 ≔ R(X3); R4 ≔ R(XL);
      F1 ≔ F4; F2 ≔ F(X2); F3 ≔ F(X3); F4 ≔ F(XL);
      B1 ≔ H12 × F1; B2 ≔ H24 × F2; B3 ≔ H24 × F3; B4 ≔ H12 × F4;
      TAU1 ≔ H12 × R1; TAU2 ≔ H24 × R2; TAU3 ≔ H24 × R3; TAU4 ≔ H12 × R4;
      A12 ≔ -( + 4·04508497187450 × P1
        + 0·57581917135425 × P3
        + 0·25751416197911 × P4)/H;
      A13 ≔ ( + 1·5450849718747 × P1
        - 1·5075141619791 × P2
        + 0·6741808286458 × P4)/H;
      A14 ≔ ((P2 + P3)/2·4 - (P1 + P4)/2)/H;
      A22 ≔ (5·454237476562 × P1 + P3/·48 + ·79576252343762 × P4)/H + TAU2;
      A23 ≔ - (P1 + P4)/(H × 0·48);
      A24 ≔ ( + 0·67418082864575 × P1
        - 1·50751416197910 × P3
        + 1·54508497187470 × P4)/H;
      A33 ≔ (·7957625234376 × P1 + P2/·48 + 5·454237476562 × P4)/H + TAU3;
      A34 ≔ -( + 0·25751416197911 × P1
        + 0·57581917135418 × P2
        + 4·0450849718747 × P4)/H;
      <u>comment</u> STATIC CONDENSATION;
      DET ≔ A22 × A33 - A23 × A23;
      C12 ≔ (A13 × A23 - A12 × A33)/DET;
      C13 ≔ (A12 × A23 - A13 × A22)/DET;
      C42 ≔ (A23 × A34 - A24 × A33)/DET;
      C43 ≔ (A24 × A23 - A34 × A22)/DET;
      TAU1 ≔ TAU1 + C12 × TAU2 + C13 × TAU3;
      TAU2 ≔ TAU4 + C42 × TAU2 + C43 × TAU3;
      A12 ≔ A14 + C42 × A12 + C43 × A13;
      B1 ≔ B1 + C12 × B2 + C13 × B3;
      B2 ≔ B4 + C42 × B2 + C43 × B3
   <u>end</u> ELEMENT MAT VEC EVALUATION 3;

   <u>procedure</u> BOUNDARY CONDITIONS;
      <u>if</u> L = 1 ∧ E2 = 0 <u>then</u>
      <u>begin</u>  TAU1 ≔ 1; B1 ≔ E3/E1; B2 ≔ B2 - A12 × B1;
         TAU2 ≔ TAU2 - A12; A12 ≔ 0 <u>end</u>
        <u>else</u> <u>if</u> L = 1 ∧ E2 ≠ 0 <u>then</u>
      <u>begin</u> <u>real</u> AUX; AUX ≔ P1/E2; TAU1 ≔ TAU1 - AUX × E1 ;
         B1 ≔ B1 - E3 × AUX
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 = 0 <u>then</u>
      <u>begin</u> TAU2 ≔ 1; B2 ≔ E6/E4;
         B1 ≔ B1 - A12 × B2; TAU1 ≔ TAU1 - A12; A12 ≔ 0
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 ≠ 0 <u>then</u>
      <u>begin</u> <u>real</u> AUX; AUX ≔ P2/E5;
         TAU2 ≔ TAU2 + AUX × E4; B2 ≔ B2 + AUX × E6
      <u>end</u> B.C.1;

   <u>procedure</u> FORWARD BABUSHKA;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> CHI[0] ≔ CH ≔ TL ≔ TAU1; T[0] ≔ TL;
         GI[0] ≔  G ≔ YL ≔   B1; Y[0] ≔ YL;
         SUB[0] ≔ A12; PP ≔ A12/(CH - A12);
         CH ≔ TAU2 - CH × PP; G ≔ B2 - G × PP; TL ≔ TAU2; YL ≔ B2
      <u>end</u> <u>else</u>
      <u>begin</u> CHI[L1] ≔ CH ≔ CH + TAU1;
         GI[L1] ≔  G ≔  G + B1;
         SUB[L1] ≔ A12; PP ≔ A12/(CH - A12);
         CH ≔ TAU2 - CH × PP; G ≔ B2 - G × PP;
         T[L1] ≔ TL + TAU1; TL ≔ TAU2;
         Y[L1] ≔ YL +   B1; YL ≔   B2
      <u>end</u> FORWARD BABUSHKA 1;

   <u>procedure</u> BACKWARD BABUSHKA;
   <u>begin</u> PP ≔ YL; Y[N] ≔ G/CH;
      G ≔ PP; CH ≔ TL; L ≔ N;
      <u>for</u> L ≔ L - 1 <u>while</u> L &GreaterSlantEqual; 0 <u>do</u>
         <u>begin</u> PP ≔ SUB[L]; PP ≔ PP/(CH - PP);
            TL ≔ T[L]; CH ≔ TL - CH × PP;
            YL ≔ Y[L]; G ≔ YL - G × PP;
            Y[L] ≔ (GI[L] + G - YL)/(CHI[L] + CH - TL)
         <u>end</u>
   <u>end</u> BACKWARD BABUSHKA;

   L ≔ 0; XL ≔ X[0];
   E1 ≔ E[1]; E2 ≔ E[2]; E3 ≔ E[3]; E4 ≔ E[4]; E5 ≔ E[5]; E6 ≔ E[6];
   <u>for</u> L ≔ L + 1 <u>while</u> L &LessSlantEqual; N <u>do</u>
      <u>begin</u> L1 ≔ L - 1; XL1 ≔ XL; XL ≔ X[L]; H ≔ XL - XL1;
         <u>if</u> ORDER = 2 <u>then</u> ELEMENT MAT VEC EVALUATION 1 <u>else</u>
         <u>if</u> ORDER = 4 <u>then</u> ELEMENT MAT VEC EVALUATION 2 <u>else</u>
           ELEMENT MAT VEC EVALUATION 3;
         <u>if</u> L = 1 ∨ L = N <u>then</u> BOUNDARY CONDITIONS;
         FORWARD BABUSHKA
      <u>end</u>;
   BACKWARD BABUSHKA;
<u>end</u> FEM LAG SYM;
<u>comment</u> ================== 33301 ================= ;
<u>procedure</u> FEM LAG(X, Y, N, R, F, ORDER, E);
   <u>value</u> N, ORDER; <u>integer</u> N, ORDER;
     <u>real</u> <u>procedure</u> R, F;
     <u>array</u> X, Y, E;
<u>begin</u> <u>integer</u> L, L1;
   <u>real</u> XL1, XL, H, A12, B1, B2, TAU1, TAU2, CH, TL, G, YL, PP,
     E1, E2, E3, E4, E5, E6;
   <u>array</u> T, SUB, CHI, GI[0: N-1];

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 1;
   <u>begin</u> <u>own</u> <u>real</u> F2, R2; <u>real</u> R1, F1, H2;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> F2 ≔ F(XL1); R2 ≔ R(XL1) <u>end</u>;
      A12 ≔ - 1/H; H2 ≔ H/2;
      R1 ≔ R2; R2 ≔ R(XL); F1 ≔ F2; F2 ≔ F(XL);
      B1 ≔ H2 × F1; B2 ≔ H2 × F2; TAU1 ≔ H2 × R1; TAU2 ≔ H2 × R2
   <u>end</u> ELEMENT MAT VEC EVALUATION 1;
   <u>procedure</u> ELEMENT MAT VEC EVALUATION 2;
   <u>begin</u> <u>own</u> <u>real</u> R3, F3;
      <u>real</u> R1, R2, F1, F2, X2, H6, H15,
        B3, TAU3, C12, A13, A22, A23;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> R3 ≔ R(XL1); F3 ≔ F(XL1) <u>end</u>;
      X2 ≔ (XL1 + XL)/2; H6 ≔ H/6; H15 ≔ H/1·5;
      R1 ≔ R3; R2 ≔ R(X2); R3 ≔ R(XL);
      F1 ≔ F3; F2 ≔ F(X2); F3 ≔ F(XL);
      B1 ≔ H6 × F1; B2 ≔ H15 × F2; B3 ≔ H6 × F3;
      TAU1 ≔ H6 × R1; TAU2 ≔ H15 × R2; TAU3 ≔ R3 × H6;
      A12 ≔ A23 ≔ -8/H/3; A13 ≔ - A12/8; A22 ≔ -2 × A12 + TAU2;
      <u>comment</u> STATIC CONDENSATION;
      C12 ≔ - A12/A22; A12 ≔ A13 + C12 × A12;
      B2 ≔ C12 × B2; B1 ≔ B1 + B2; B2 ≔ B3 + B2;
      TAU2 ≔ C12 × TAU2; TAU1 ≔ TAU1 + TAU2; TAU2 ≔ TAU3 + TAU2
   <u>end</u> ELEMENT MAT VEC EVALUATION2;

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 3;
   <u>begin</u> <u>own</u> <u>real</u> R4, F4;
      <u>real</u> R1, R2, R3, F1, F2, F3, X2, X3, H12, H24,
        DET, C12, C13, C42, C43, A13, A14, A22, A23, A24,
        A33, A34, B3, B4, TAU3, TAU4;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> R4 ≔ R(XL1); F4 ≔ F(XL1) <u>end</u>;
      X2 ≔ XL1 + 0·27639320225 × H; X3 ≔ XL - X2 + XL1;
      R1 ≔ R4; R2 ≔ R(X2); R3 ≔ R(X3); R4 ≔ R(XL);
      F1 ≔ F4; F2 ≔ F(X2); F3 ≔ F(X3); F4 ≔ F(XL);
      H12 ≔ H/12; H24 ≔ H/2·4;
      B1 ≔ F1 × H12; B2 ≔ F2 × H24; B3 ≔ F3 × H24; B4 ≔ F4 × H12;
      TAU1 ≔ R1 × H12; TAU2 ≔ R2 × H24; TAU3 ≔ R3 × H24; TAU4 ≔ R4 × H12;
      A12 ≔ A34 ≔ -4·8784183052078/H; A13 ≔ A24 ≔ 0·7117516385412/H;
      A14 ≔ -0·16666666666667/H; A23 ≔ 25 × A14;
      A22 ≔ -2 × A23 + TAU2; A33 ≔ -2 × A23 + TAU3;
      <u>comment</u> STATIC CONDENSATION;
      DET ≔ A22 × A33 - A23 × A23;
      C12 ≔ (A13 × A23 - A12 × A33)/DET;
      C13 ≔ (A12 × A23 - A13 × A22)/DET;
      C42 ≔ (A23 × A34 - A24 × A33)/DET;
      C43 ≔ (A24 × A23 - A34 × A22)/DET;
      TAU1 ≔ TAU1 + C12 × TAU2 + C13 × TAU3;
      TAU2 ≔ TAU4 + C42 × TAU2 + C43 × TAU3;
      A12 ≔ A14 + C42 × A12 + C43 × A13;
      B1 ≔ B1 + C12 × B2 + C13 × B3;
      B2 ≔ B4 + C42 × B2 + C43 × B3
   <u>end</u> ELEMENT MAT VEC EVALUATION3;
   <u>procedure</u> BOUNDARY CONDITIONS;
      <u>if</u> L = 1 ∧ E2 = 0 <u>then</u>
      <u>begin</u> TAU1 ≔ 1; B1 ≔ E3/E1; B2 ≔ B2 - A12 × B1;
         TAU2 ≔ TAU2 - A12; A12 ≔ 0 <u>end</u>
        <u>else</u> <u>if</u> L = 1 ∧ E2 ≠ 0 <u>then</u>
      <u>begin</u> TAU1 ≔ TAU1 - E1/E2;
         B1 ≔ B1 - E3/E2
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 = 0 <u>then</u>
      <u>begin</u> TAU2 ≔ 1; B2 ≔ E6/E4; B1 ≔ B1 - A12 × B2;
         TAU1 ≔ TAU1 - A12; A12 ≔ 0
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 ≠ 0 <u>then</u>
      <u>begin</u> TAU2 ≔ TAU2 + E4/E5;
         B2 ≔ B2 + E6/E5
      <u>end</u> BOUNDARY CONDITIONS;

   <u>procedure</u> FORWARD BABUSHKA;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> CHI[0] ≔ CH ≔ TL ≔ TAU1; T[0] ≔ TL;
         GI[0] ≔ G ≔ YL ≔ B1; Y[0] ≔ YL;
         SUB[0] ≔ A12; PP ≔ A12/(CH - A12); CH ≔ TAU2 - CH × PP;
         G ≔ B2 - G × PP; TL ≔ TAU2; YL ≔ B2
      <u>end</u> <u>else</u>
      <u>begin</u> CHI[L1] ≔ CH ≔ CH + TAU1;
         GI[L1] ≔ G ≔ G + B1; SUB[L1] ≔ A12; PP ≔ A12/(CH - A12);
         CH ≔ TAU2 - CH × PP; G ≔ B2 - G × PP;
         T[L1] ≔ TL + TAU1; TL ≔ TAU2;
         Y[L1] ≔ YL +   B1; YL ≔   B2
      <u>end</u> FORWARD BABUSHKA 1;

   <u>procedure</u> BACKWARD BABUSHKA;
   <u>begin</u> PP ≔ YL; Y[N] ≔ G/CH;
      G ≔ PP; CH ≔ TL; L ≔ N;
      <u>for</u> L ≔ L - 1 <u>while</u> L &GreaterSlantEqual; 0 <u>do</u>
         <u>begin</u> PP ≔ SUB[L]; PP ≔ PP/(CH - PP);
            TL ≔ T[L]; CH ≔ TL - CH × PP;
            YL ≔ Y[L]; G ≔ YL - G × PP;
            Y[L] ≔ ((GI[L] + G) - YL)/((CHI[L] + CH) - TL)
         <u>end</u>
   <u>end</u> BACKWARD BABUSHKA;

   L ≔ 0; XL ≔ X[0];
   E1 ≔ E[1]; E2 ≔ E[2]; E3 ≔ E[3]; E4 ≔ E[4]; E5 ≔ E[5]; E6 ≔ E[6];
   <u>for</u> L ≔ L + 1 <u>while</u> L &LessSlantEqual; N <u>do</u>
      <u>begin</u> L1 ≔ L - 1; XL1 ≔ XL; XL ≔ X[L]; H ≔ XL - XL1;
         <u>if</u> ORDER = 2 <u>then</u> ELEMENT MAT VEC EVALUATION 1 <u>else</u>
         <u>if</u> ORDER = 4 <u>then</u> ELEMENT MAT VEC EVALUATION 2 <u>else</u>
           ELEMENT MAT VEC EVALUATION 3;
         <u>if</u> L = 1 ∨ L = N <u>then</u> BOUNDARY CONDITIONS;
         FORWARD BABUSHKA
      <u>end</u>;
   BACKWARD BABUSHKA;
<u>end</u> FEM LAGR;
<u>comment</u> ================== 33302 ================= ;
<u>procedure</u> FEM LAG SKEW(X, Y, N, Q, R, F, ORDER, E);
   <u>integer</u> N, ORDER;
     <u>real</u> <u>procedure</u> Q, R, F;
     <u>array</u> X, Y, E;
<u>begin</u> <u>integer</u> L, L1;
   <u>real</u> XL1, XL, H, A12, A21, B1, B2, TAU1, TAU2, CH, TL, G, YL, PP,
     E1, E2, E3, E4, E5, E6;
   <u>array</u> T, SUPER, SUB, CHI, GI[0:N-1];

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 1;
   <u>begin</u> <u>own</u> <u>real</u> Q2, R2, F2;
      <u>real</u> Q1, R1, F1, H2, S12;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> Q2 ≔ Q(XL1); R2 ≔ R(XL1); F2 ≔ F(XL1) <u>end</u>;
      H2 ≔ H/2; S12 ≔ - 1/H;
      Q1 ≔ Q2; Q2 ≔ Q(XL);
      R1 ≔ R2; R2 ≔ R(XL);
      F1 ≔ F2; F2 ≔ F(XL);
      B1 ≔ H2 × F1; B2 ≔ H2 × F2;
      TAU1 ≔ H2 × R1; TAU2 ≔ H2 × R2;
      A12 ≔ S12 + Q1/2; A21 ≔ S12 - Q2/2
   <u>end</u> ELEMENT MAT VEC EV.;

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 2;
   <u>begin</u> <u>own</u> <u>real</u> Q3, R3, F3;
      <u>real</u> Q1, Q2, R1, R2, F1, F2, S12, S13, S22, X2, H6, H15,
        C12, C32, A13, A31, A22, A23, A32, B3, TAU3;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> Q3 ≔ Q(XL1); R3 ≔ R(XL1); F3 ≔ F(XL1) <u>end</u>;

      X2 ≔ (XL1 + XL)/2; H6 ≔ H/6; H15 ≔ H/1·5;
      Q1 ≔ Q3; Q2 ≔ Q(X2); Q3 ≔ Q(XL);
      R1 ≔ R3; R2 ≔ R(X2); R3 ≔ R(XL);
      F1 ≔ F3; F2 ≔ F(X2); F3 ≔ F(XL);
      B1 ≔ H6 × F1; B2 ≔ H15 × F2; B3 ≔ H6 × F3;
      TAU1 ≔ H6 × R1; TAU2 ≔ H15 × R2; TAU3 ≔ H6 × R3;
      S12 ≔ - 1/H/0·375; S13 ≔ - S12/8; S22 ≔ - 2 × S12;
      A12 ≔ S12 + Q1/1·5; A13 ≔ S13 - Q1/6;
      A21 ≔ S12 - Q2/1·5; A23 ≔ S12 + Q2/1·5; A22 ≔ S22 + TAU2;
      A31 ≔ S13 + Q3/6; A32 ≔ S12 - Q3/1·5;
      <u>comment</u> STATIC CONDENSATION;
      C12 ≔ - A12/A22; C32 ≔ - A32/A22;
      A12 ≔ A13 + C12 × A23; A21 ≔ A31 + C32 × A21;
      B1 ≔ B1 + C12 × B2; B2 ≔ B3 + C32 × B2;
      TAU1 ≔ TAU1 + C12 × TAU2; TAU2 ≔ TAU3 + C32 × TAU2
   <u>end</u> ELEMENT MAT VEC EVALUATION 2;
   <u>procedure</u> ELEMENT MAT VEC EVALUATION 3;
   <u>begin</u> <u>own</u> <u>real</u> Q4, R4, F4;
      <u>real</u> Q1, Q2, Q3, R1, R2, R3, F1, F2, F3,
        S12, S13, S14, S22, S23, X2, X3, H12, H24,
        DET, C12, C13, C42, C43, A13, A14, A22, A23,
        A24, A31, A32, A33, A34, A41, A42, A43,
        B3, B4, TAU3, TAU4;

      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> Q4 ≔ Q(XL1); R4 ≔ R(XL1); F4 ≔ F(XL1) <u>end</u>;
      X2 ≔ XL1 + 0·27639320225 × H; X3 ≔ XL - X2 + XL1;
      H12 ≔ H/12; H24 ≔ H/2·4;
      Q1 ≔ Q4; Q2 ≔ Q(X2); Q3 ≔ Q(X3); Q4 ≔ Q(XL);
      R1 ≔ R4; R2 ≔ R(X2); R3 ≔ R(X3); R4 ≔ R(XL);
      F1 ≔ F4; F2 ≔ F(X2); F3 ≔ F(X3); F4 ≔ F(XL);
      S12 ≔ -4·8784183052080/H; S13 ≔ 0·7117516385414/H;
      S14 ≔ -·16666666666667/H; S23 ≔ 25 × S14; S22 ≔ -2 × S23;
      B1 ≔ H12 × F1; B2 ≔ H24 × F2; B3 ≔ H24 × F3; B4 ≔ H12 × F4;
      TAU1 ≔ H12 × R1; TAU2 ≔ H24 × R2; TAU3 ≔ H24 × R3; TAU4 ≔ H12 × R4;
      A12 ≔ S12 + 0·67418082864578 × Q1;
      A13 ≔ S13 - 0·25751416197912 × Q1;
      A14 ≔ S14 + Q1/12;
      A21 ≔ S12 - 0·67418082864578 × Q2;
      A22 ≔ S22 + TAU2;
      A23 ≔ S23 + 0·93169499062490 × Q2;
      A24 ≔ S13 - 0·25751416197912 × Q2;
      A31 ≔ S13 + 0·25751416197912 × Q3;
      A32 ≔ S23 - 0·93169499062490 × Q3;
      A33 ≔ S22 + TAU3;
      A34 ≔ S12 + 0·67418082864578 × Q3;
      A41 ≔ S14 - Q4/12;
      A42 ≔ S13 + 0·25751416197912 × Q4;
      A43 ≔ S12 - 0·67418082864578 × Q4;
      <u>comment</u> STATIC CONDENSATION;
      DET ≔ A22 × A33 - A23 × A32;
      C12 ≔ (A13 × A32 - A12 × A33)/DET;
      C13 ≔ (A12 × A23 - A13 × A22)/DET;
      C42 ≔ (A32 × A43 - A42 × A33)/DET;
      C43 ≔ (A42 × A23 - A43 × A22)/DET;
      TAU1 ≔ TAU1 + C12 × TAU2 + C13 × TAU3 ;
      TAU2 ≔ TAU4 + C42 × TAU2 + C43 × TAU3;
      A12 ≔ A14 + C12 × A24 + C13 × A34;
      A21 ≔ A41 + C42 × A21 + C43 × A31;
      B1 ≔ B1 + C12 × B2 + C13 × B3;
      B2 ≔ B4 + C42 × B2 + C43 × B3
   <u>end</u> ELEMENT MAT VEC EVALUATION 3;
   <u>procedure</u> BOUNDARY CONDITIONS;
      <u>if</u> L = 1 ∧ E2 = 0 <u>then</u>
      <u>begin</u> TAU1 ≔ 1; B1 ≔ E3/E1; A12 ≔ 0 <u>end</u>
        <u>else</u> <u>if</u> L = 1 ∧ E2 ≠ 0 <u>then</u>
      <u>begin</u> TAU1 ≔ TAU1 - E1/E2; B1 ≔ B1 - E3/E2
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 = 0 <u>then</u>
      <u>begin</u> TAU2 ≔ 1; A21 ≔ 0; B2 ≔ E6/E4;
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 ≠ 0 <u>then</u>
      <u>begin</u> TAU2 ≔ TAU2 + E4/E5; B2 ≔ B2 + E6/E5
      <u>end</u> B.C.1;

   <u>procedure</u> FORWARD BABUSKA;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> CHI[0] ≔ CH ≔ TL ≔ TAU1; T[0] ≔ TL;
         GI[0] ≔ G ≔ YL ≔ B1; Y[0] ≔ YL;
         SUB[0] ≔ A21; SUPER[0] ≔ A12;
         PP ≔ A21/(CH - A12); CH ≔ TAU2 - CH × PP;
         G ≔ B2 - G × PP; TL ≔ TAU2; YL ≔ B2
      <u>end</u> <u>else</u>
      <u>begin</u> CHI[L1] ≔ CH ≔ CH + TAU1;
         GI[L1] ≔ G ≔ G + B1;
         SUB[L1] ≔ A21; SUPER[L1] ≔ A12;
         PP ≔ A21/(CH - A12); CH ≔ TAU2 - CH × PP;
         G ≔ B2 - G × PP; T[L1] ≔ TL + TAU1; TL ≔ TAU2;
         Y[L1] ≔ YL +  B1; YL ≔ B2
      <u>end</u> FORWARD BABUSKA;

   <u>procedure</u> BACKWARD BABUSKA;
   <u>begin</u> PP ≔ YL; Y[N] ≔ G/CH;
      G ≔ PP; CH ≔ TL; L ≔ N;
      <u>for</u> L ≔ L - 1 <u>while</u> L &GreaterSlantEqual; 0 <u>do</u>
         <u>begin</u> PP ≔ SUPER[L]/(CH - SUB[L]);
            TL ≔ T[L]; CH ≔ TL - CH × PP;
            YL ≔ Y[L]; G ≔ YL - G × PP;
            Y[L] ≔ (GI[L] + G - YL)/(CHI[L] + CH - TL)  ;
         <u>end</u>
   <u>end</u> BACKWARD BABUSKA;

   L ≔ 0; XL ≔ X[0];
   E1 ≔ E[1]; E2 ≔ E[2]; E3 ≔ E[3]; E4 ≔ E[4]; E5 ≔ E[5]; E6 ≔ E[6];
   <u>comment</u> ELEMENTWISE ASSEMBLAGE OF MATRIX AND VECTOR
     COMBINED WITH FORWARD BABUSKA SUBSTITUTION;
   <u>for</u> L ≔ L + 1 <u>while</u> L &LessSlantEqual; N <u>do</u>
      <u>begin</u> XL1 ≔ XL; L1 ≔ L - 1; XL ≔ X[L]; H ≔ XL - XL1;
         <u>if</u> ORDER = 2 <u>then</u> ELEMENT MAT VEC EVALUATION 1 <u>else</u>
         <u>if</u> ORDER = 4 <u>then</u> ELEMENT MAT VEC EVALUATION 2 <u>else</u>
           ELEMENT MAT VEC EVALUATION 3;
         <u>if</u> L = 1 ∨ L = N <u>then</u> BOUNDARY CONDITIONS;
         FORWARD BABUSKA
      <u>end</u>;
   BACKWARD BABUSKA;
<u>end</u> FEM LAGR;
<u>comment</u> ================== 33303 ================= ;
<u>procedure</u>  FEM HERM SYM(X, Y, N, P, Q, R, F, ORDER, E);
   <u>value</u> N, ORDER; <u>integer</u> N, ORDER;
     <u>array</u> X, Y, E;
     <u>real</u> <u>procedure</u>  P, Q, R, F;
<u>begin</u> <u>integer</u> L, N2, V, W;
   <u>array</u> A[1:8 × (N - 1)], EM[2:3];
   <u>real</u> A11, A12, A13, A14, A22, A23, A24, A33, A34, A44,
     YA, YB, ZA, ZB,
     B1, B2, B3, B4, D1, D2, E1, R1, R2, XL1, XL;

   <u>procedure</u> CHLDECSOLBND(A, N, W, AUX, B); <u>code</u> 34333;

   <u>procedure</u> ELEMENTMATVECEVALUATION;
      <u>if</u> ORDER = 4 <u>then</u>
      <u>begin</u> <u>real</u> X2, H, H2, H3, P1, P2,
           Q1, Q2, R1, R2, F1, F2,
           B11, B12, B13, B14, B22, B23, B24, B33, B34, B44,
           S11, S12, S13, S14, S22, S23, S24, S33, S34, S44,
           M11, M12, M13, M14, M22, M23, M24, M33, M34, M44;
         <u>own</u> <u>real</u> P3, Q3, R3, F3;

         H ≔ XL - XL1; H2 ≔ H × H; H3 ≔ H × H2;
         X2 ≔ (XL1 + XL)/2;
         <u>if</u> L = 1 <u>then</u>
         <u>begin</u> P3 ≔ P(XL1); Q3 ≔ Q(XL1); R3 ≔ R(XL1); F3 ≔ F(XL1)
         <u>end</u>;

         <u>comment</u> ELEMENT BENDING MATRIX;
         P1 ≔ P3; P2 ≔ P(X2); P3 ≔ P(XL);
         B11 ≔ 6 × (P1 + P3); B12 ≔ 4 × P1 + 2 × P3;
         B13 ≔ - B11; B14 ≔ B11 - B12;
         B22 ≔ (4 × P1 + P2 + P3)/1·5; B23 ≔ - B12; B24 ≔ B12 - B22;
         B33 ≔ B11; B34 ≔ - B14; B44 ≔ B14 - B24;

         <u>comment</u> ELEMENT STIFFNESS MATRIX;
         Q1 ≔ Q3; Q2 ≔ Q(X2); Q3 ≔ Q(XL);
         S11 ≔ 1·5 × Q2; S12 ≔ Q2/4; S13 ≔ - S11; S14 ≔ S12;
         S24 ≔ Q2/24; S22 ≔ Q1/6 + S24; S23 ≔ - S12;
         S33 ≔ S11; S34 ≔ - S12; S44 ≔ S24 + Q3/6;

         <u>comment</u> ELEMENT MASS MATRIX;
         R1 ≔ R3; R2 ≔ R(X2); R3 ≔ R(XL);
         M11 ≔ (R1 + R2)/6; M12 ≔ R2/24; M13 ≔ R2/6; M14 ≔ - M12;
         M22 ≔ R2/96; M23 ≔ - M14; M24 ≔ - M22;
         M33 ≔ (R2 + R3)/6; M34 ≔ M14; M44 ≔ M22;

         <u>comment</u> ELEMENT LOAD VECTOR;
         F1 ≔ F3; F2 ≔ F(X2); F3 ≔ F(XL);
         B1 ≔ H × (F1 + 2 × F2)/6; B3 ≔ H × (F3 + 2 × F2)/6;
         B2 ≔ H2 × F2/12; B4 ≔ - B2;
         A11 ≔ B11/H3 + S11/H + M11 × H; A12 ≔ B12/H2 + S12 + M12 × H2;
         A13 ≔ B13/H3 + S13/H + M13 × H; A14 ≔ B14/H2 + S14 + M14 × H2;
         A22 ≔ B22/H + S22 × H + M22 × H3; A23 ≔ B23/H2 + S23 + M23 × H2;
         A24 ≔ B24/H + S24 × H + M24 × H3; A34 ≔ B34/H2 + S34 + M34 × H2;
         A33 ≔ B33/H3 + S33/H + M33 × H; A44 ≔ B44/H + S44 × H + M44 × H3
      <u>end</u> <u>else</u> <u>if</u> ORDER = 6 <u>then</u>
      <u>begin</u> <u>own</u> <u>real</u> P4, Q4, R4, F4;
         <u>real</u> H, H2, H3, X2, X3,
           P1, P2, P3, Q1, Q2, Q3,
           R1, R2, R3, F1, F2, F3,
           B11, B12, B13, B14, B15, B22, B23, B24, B25,
           B33, B34, B35, B44, B45, B55,
           S11, S12, S13, S14, S15, S22, S23, S24, S25,
           S33, S34, S35, S44, S45, S55,
           M11, M12, M13, M14, M15, M22, M23, M24, M25,
           M33, M34, M35, M44, M45, M55,
           A15, A25, A35, A45, A55, C1, C2, C3, C4, B5;
         <u>if</u> L = 1 <u>then</u>
         <u>begin</u> P4 ≔ P(XL1); Q4 ≔ Q(XL1); R4 ≔ R(XL1); F4 ≔ F(XL1)
         <u>end</u>;

         H ≔ XL - XL1; H2 ≔ H × H; H3 ≔ H × H2;
         X2 ≔ 0·27639320225 × H + XL1; X3 ≔ XL1 + XL - X2;

         <u>comment</u> ELEMENT BENDING MATRIX;
         P1 ≔ P4; P2 ≔ P(X2); P3 ≔ P(X3); P4 ≔ P(XL);
         B11 ≔ + 4·0333333333333&#9192;+1 × P1 + 1·1124913866738&#9192;-1 × P2
           + 1·4422084194664&#9192;+1 × P3 + 8·3333333333333&#9192;+0 × P4;
         B12 ≔ + 1·4666666666667&#9192;+1 × P1 - 3·3191425091659&#9192;-1 × P2
           + 2·7985809175818&#9192;+0 × P3 + 1·6666666666667&#9192;+0 × P4;
         B13 ≔ + 1·8333333333333&#9192;+1 × (P1 + P4)
           + 1·2666666666667&#9192;+0 × (P2 + P3);
         B15 ≔ - (B11 + B13); B14 ≔ - (B12 + B13 + B15/2);
         B22 ≔ + 5·3333333333333&#9192;+0 × P1 + 9·9027346441674&#9192;-1 × P2
           + 5·4305986891624&#9192;-1 × P3 + 3·3333333333333&#9192;-1 × P4;
         B23 ≔ + 6·6666666666667&#9192;+0 × P1 - 3·7791278464167&#9192;+0 × P2
           + 2·4579451308295&#9192;-1 × P3 + 3·6666666666667&#9192;+0 × P4;
         B25 ≔ - (B12 + B23); B24 ≔ - (B22 + B23 + B25/2);
         B33 ≔ + 8·3333333333333&#9192;+0 × P1 + 1·4422084194666&#9192;+1 × P2
           + 1·1124913866726&#9192;-1 × P3 + 4·0333333333333&#9192;+1 × P4;
         B35 ≔ - (B13 + B33); B34 ≔ - (B23 + B33 + B35/2);
         B45 ≔ - (B14 + B34); B44 ≔ - (B24 + B34 + B45/2);
         B55 ≔ - (B15 + B35);
         <u>comment</u> ELEMENT STIFFNESS MATRIX;
         Q1 ≔ Q4; Q2 ≔ Q(X2); Q3 ≔ Q(X3); Q4 ≔ Q(XL);
         S11 ≔ + 2·8844168389330&#9192;+0 × Q2 + 2·2249827733448&#9192;-2 × Q3;
         S12 ≔ + 2·5671051872498&#9192;-1 × Q2 + 3·2894812749994&#9192;-3 × Q3;
         S13 ≔ + 2·5333333333333&#9192;-1 × (Q2 + Q3);
         S14 ≔ - 3·7453559925005&#9192;-2 × Q2 - 2·2546440074988&#9192;-2 × Q3;
         S15 ≔ - (S13 + S11);
         S22 ≔ + 8·3333333333333&#9192;-2 × Q1 + 2·2847006554164&#9192;-2 × Q2
           + 4·8632677916445&#9192;-4 × Q3;
         S23 ≔ + 2·2546440075002&#9192;-2 × Q2 + 3·7453559924873&#9192;-2 × Q3;
         S24 ≔ - 3·3333333333333&#9192;-3 × (Q2 + Q3);
         S25 ≔ - (S12 + S23);
         S33 ≔ + 2·2249827733471&#9192;-2 × Q2 + 2·8844168389330&#9192;+0 × Q3;
         S34 ≔ - 3·2894812750127&#9192;-3 × Q2 - 2·5671051872496&#9192;-1 × Q3;
         S35 ≔ - (S13 + S33);
         S44 ≔ + 4·8632677916788&#9192;-4 × Q2
           + 2·2847006554161&#9192;-2 × Q3 + 8·3333333333338&#9192;-2 × Q4;
         S45 ≔ - (S14 + S34);
         S55 ≔ - (S15 + S35);

         <u>comment</u> ELEMENT MASS MATRIX;
         R1 ≔ R4; R2 ≔ R(X2); R3 ≔ R(X3); R4 ≔ R(XL);
         M11 ≔ + 8·3333333333333&#9192;-2 × R1 + 1·0129076086083&#9192;-1 × R2
           + 7·3759058058380&#9192;-3 × R3;
         M12 ≔ + 1·3296181273333&#9192;-2 × R2 + 1·3704853933353&#9192;-3 × R3;
         M13 ≔ - 2·7333333333333&#9192;-2 × (R2 + R3);
         M14 ≔ + 5·0786893258335&#9192;-3 × R2 + 3·5879773408333&#9192;-3 × R3;
         M15 ≔ + 1·3147987115999&#9192;-1 × R2 - 3·5479871159991&#9192;-2 × R3;
         M22 ≔ + 1·7453559925000&#9192;-3 × R2 + 2·5464400750059&#9192;-4 × R3;
         M23 ≔ - 3·5879773408336&#9192;-3 × R2 - 5·0786893258385&#9192;-3 × R3;
         M24 ≔ + 6·6666666666667&#9192;-4 × (R2 + R3);
         M25 ≔ + 1·7259029213333&#9192;-2 × R2 - 6·5923625466719&#9192;-3 × R3;
         M33 ≔ + 7·3759058058380&#9192;-3 × R2
           + 1·0129076086083&#9192;-1 × R3 + 8·3333333333333&#9192;-2 × R4;
         M34 ≔ - 1·3704853933333&#9192;-3 × R2 - 1·3296181273333&#9192;-2 × R3;
         M35 ≔ - 3·5479871159992&#9192;-2 × R2 + 1·3147987115999&#9192;-1 × R3;
         M44 ≔ + 2·5464400750008&#9192;-4 × R2 + 1·7453559924997&#9192;-3 × R3;
         M45 ≔ + 6·5923625466656&#9192;-3 × R2 - 1·7259029213330&#9192;-2 × R3;
         M55 ≔ + ·17066666666667&#9192;+0 × (R2 + R3);
         <u>comment</u> ELEMENT LOAD VECTOR;
         F1 ≔ F4; F2 ≔ F(X2); F3 ≔ F(X3); F4 ≔ F(XL);
         B1 ≔ + 8·3333333333333&#9192;-2 × F1 + 2·0543729868749&#9192;-1 × F2
           - 5·5437298687489&#9192;-2 × F3;
         B2 ≔ + 2·6967233145832&#9192;-2 × F2 - 1·0300566479175&#9192;-2 × F3;
         B3 ≔ - 5·5437298687489&#9192;-2 × F2
           + 2·0543729868749&#9192;-1 × F3 + 8·3333333333333&#9192;-2 × F4;
         B4 ≔ + 1·0300566479165&#9192;-2 × F2 - 2·6967233145830&#9192;-2 × F3;
         B5 ≔ + 2·6666666666667&#9192;-1 × (F2 + F3);

         A11 ≔ H2 × (H2 × M11 + S11) + B11; A12 ≔ H2 × (H2 × M12 + S12) + B12;
         A13 ≔ H2 × (H2 × M13 + S13) + B13; A14 ≔ H2 × (H2 × M14 + S14) + B14;
         A15 ≔ H2 × (H2 × M15 + S15) + B15; A22 ≔ H2 × (H2 × M22 + S22) + B22;
         A23 ≔ H2 × (H2 × M23 + S23) + B23; A24 ≔ H2 × (H2 × M24 + S24) + B24;
         A25 ≔ H2 × (H2 × M25 + S25) + B25; A33 ≔ H2 × (H2 × M33 + S33) + B33;
         A34 ≔ H2 × (H2 × M34 + S34) + B34; A35 ≔ H2 × (H2 × M35 + S35) + B35;
         A44 ≔ H2 × (H2 × M44 + S44) + B44; A45 ≔ H2 × (H2 × M45 + S45) + B45;
         A55 ≔ H2 × (H2 × M55 + S55) + B55;

         <u>comment</u> STATIC CONDENSATION;
         C1 ≔ A15/A55; C2 ≔ A25/A55; C3 ≔ A35/A55; C4 ≔ A45/A55;
         B1 ≔ (B1 - C1 × B5) × H; B2 ≔ (B2 - C2 × B5) × H2;
         B3 ≔ (B3 - C3 × B5) × H; B4 ≔ (B4 - C4 × B5) × H2;
         A11 ≔ (A11 - C1 × A15)/H3; A12 ≔ (A12 - C1 × A25)/H2;
         A13 ≔ (A13 - C1 × A35)/H3; A14 ≔ (A14 - C1 × A45)/H2;
         A22 ≔ (A22 - C2 × A25)/H; A23 ≔ (A23 - C2 × A35)/H2;
         A24 ≔ (A24 - C2 × A45)/H; A33 ≔ (A33 - C3 × A35)/H3;
         A34 ≔ (A34 - C3 × A45)/H2; A44 ≔ (A44 - C4 × A45)/H;
      <u>end</u> <u>else</u>
      <u>begin</u> <u>own</u> <u>real</u> P5, Q5, R5, F5;
         <u>real</u> X2, X3, X4, H, H2, H3,
           P1, P2, P3, P4, Q1, Q2, Q3, Q4,
           R1, R2, R3, R4, F1, F2, F3, F4,
           B11, B12, B13, B14, B15, B16, B22, B23, B24, B25, B26,
           B33, B34, B35, B36, B44, B45, B46, B55, B56, B66,
           S11, S12, S13, S14, S15, S16, S22, S23, S24, S25, S26,
           S33, S34, S35, S36, S44, S45, S46, S55, S56, S66,
           M11, M12, M13, M14, M15, M16, M22, M23, M24, M25, M26,
           M33, M34, M35, M36, M44, M45, M46, M55, M56, M66,
           C15, C16, C25, C26, C35, C36, C45, C46, B5, B6,
           A15, A16, A25, A26, A35, A36, A45, A46, A55, A56, A66, DET;
         <u>if</u> L = 1 <u>then</u>
         <u>begin</u> P5 ≔ P(XL1); Q5 ≔ Q(XL1); R5 ≔ R(XL1); F5 ≔ F(XL1)
         <u>end</u>;
         H ≔ XL - XL1; H2 ≔ H × H; H3 ≔ H × H2;
         X2 ≔ XL1 + H × ·172673164646; X3 ≔ XL1 + H/2; X4 ≔ XL1 + XL - X2;
         <u>comment</u> ELEMENT BENDING MATRIX;
         P1 ≔ P5; P2 ≔ P(X2); P3 ≔ P(X3); P4 ≔ P(X4); P5 ≔ P(XL);
         B11 ≔ + 105·8 × P1 + 9·8 × P5     + 7·3593121303513&#9192;-2 × P2
           + 2·2755555555556&#9192;+1 × P3 + 7·0565656088553&#9192;+0 × P4;
         B12 ≔ + 27·6 × P1  + 1·4 × P5     - 3·41554824811&#9192;-1 × P2
           + 2·8444444444444&#9192;+0 × P3 + 1·0113960946522&#9192;+0 × P4;
         B13 ≔ - 32·2 × (P1 + P5)        - 7·2063492063505&#9192;-1 × (P2 + P4)
           + 2·2755555555556&#9192;+1 × P3;
         B14 ≔ + 4·6 × P1 + 8·4 × P5       + 1·0328641222944&#9192;-1 × P2
           - 2·8444444444444&#9192;+0 × P3 - 3·3445562534992&#9192;+0 × P4;
         B15 ≔ - (B11 + B13); B16 ≔ - (B12 + B13 + B14 + B15/2);
         B22 ≔ + 7·2 × P1 + 0·2 × P5       + 1·5851984028581&#9192;+0 × P2
           + 3·5555555555556&#9192;-1 × P3 + 1·4496032730059&#9192;-1 × P4;
         B23 ≔ - 8·4 × P1 - 4·6 × P5       + 3·3445562534992&#9192;+0 × P2
           + 2·8444444444444&#9192;+0 × P3 - 1·0328641222944&#9192;-1 × P4;
         B24 ≔ + 1·2 × (P1 + P5)         - 4·7936507936508&#9192;-1 × (P2 + P4)
           - 3·5555555555556&#9192;-1 × P3;
         B25 ≔ - (B12 + B23); B26 ≔ - (B22 + B23 + B24 + B25/2);
         B33 ≔ + 7·0565656088553&#9192;+0 × P2 + 2·2755555555556&#9192;+1 × P3
           + 7·3593121303513&#9192;-2 × P4 + 105·8 × P5 + 9·8 × P1;
         B34 ≔ - 1·4 × P1 - 27·6 × P5      - 1·0113960946522&#9192;+0 × P2
           - 2·8444444444444&#9192;+0 × P3 + 3·4155482481100&#9192;-1 × P4;
         B35 ≔ - (B13 + B33); B36 ≔ - (B23 + B33 + B34 + B35/2);
         B44 ≔ + 7·2 × P5 + P1/5          + 1·4496032730059&#9192;-1 × P2
           + 3·5555555555556&#9192;-1 × P3 + 1·5851984028581&#9192;+0 × P4;
         B45 ≔ - (B14 + B34); B46 ≔ - (B24 + B34 + B44 + B45/2);
         B55 ≔ - (B15 + B35); B56 ≔ - (B16 + B36);
         B66 ≔ - (B26 + B36 + B46 + B56/2);

         <u>comment</u> ELEMENT STIFFNESS MATRIX;
         Q1 ≔ Q5; Q2 ≔ Q(X2); Q3 ≔ Q(X3); Q4 ≔ Q(X4); Q5 ≔ Q(XL);
         S11 ≔ + 3·0242424037951&#9192;+0 × Q2 + 3·1539909130065&#9192;-2 × Q4;
         S12 ≔ + 1·2575525581744&#9192;-1 × Q2 + 4·1767169716742&#9192;-3 × Q4;
         S13 ≔ - 3·0884353741496&#9192;-1 × (Q2 + Q4);
         S14 ≔ + 4·0899041243062&#9192;-2 × Q2 + 1·2842455355577&#9192;-2 × Q4;
         S15 ≔ - (S13 + S11);
         S16 ≔ + 5·9254861177068&#9192;-1 × Q2 + 6·0512612719116&#9192;-2 × Q4;
         S22 ≔ + 5·2292052865422&#9192;-3 × Q2 + 5·5310763862796&#9192;-4 × Q4 + Q1/20;
         S23 ≔ - 1·2842455355577&#9192;-2 × Q2 - 4·0899041243062&#9192;-2 × Q4;
         S24 ≔ + 1·7006802721088&#9192;-3 × (Q2 + Q4);
         S25 ≔ - (S12 + S23);
         S26 ≔ + 2·4639593097426&#9192;-2 × Q2 + 8·0134681270641&#9192;-3 × Q4;
         S33 ≔ + 3·1539909130065&#9192;-2 × Q2 + 3·0242424037951&#9192;+0 × Q4;
         S34 ≔ - 4·1767169716742&#9192;-3 × Q2 - 1·2575525581744&#9192;-1 × Q4;
         S35 ≔ - (S13 + S33);
         S36 ≔ - 6·0512612719116&#9192;-2 × Q2 - 5·9254861177068&#9192;-1 × Q4;
         S44 ≔ + 5·5310763862796&#9192;-4 × Q2 + 5·2292052865422&#9192;-3 × Q4 + Q5/20;
         S45 ≔ - (S14 + S34);
         S46 ≔ + 8·0134681270641&#9192;-3 × Q2 + 2·4639593097426&#9192;-2 × Q4;
         S55 ≔ - (S15 + S35); S56 ≔ -(S16 + S36);
         S66 ≔ + 1·1609977324263&#9192;-1 × (Q2 + Q4) + 3·5555555555556&#9192;-1 × Q3;
         <u>comment</u> ELEMENT MASS MATRIX;
         R1 ≔ R5; R2 ≔ R(X2); R3 ≔ R(X3); R4 ≔ R(X4); R5 ≔ R(XL);
         M11 ≔ + 9·7107020727310&#9192;-2 × R2 + 1·5810259199180&#9192;-3 × R4 + R1/20;
         M12 ≔ + 8·2354889460254&#9192;-3 × R2 + 2·1932154960071&#9192;-4 × R4;
         M13 ≔ + 1·2390670553936&#9192;-2 × (R2 + R4);
         M14 ≔ - 1·7188466249968&#9192;-3 × R2 - 1·0508326752939&#9192;-3 × R4;
         M15 ≔ + 5·3089789712119&#9192;-2 × R2 + 6·7741558661060&#9192;-3 × R4;
         M16 ≔ - 1·7377712856076&#9192;-2 × R2 + 2·2173630018466&#9192;-3 × R4;
         M22 ≔ + 6·9843846173145&#9192;-4 × R2 + 3·0424512029349&#9192;-5 × R4;
         M23 ≔ + 1·0508326752947&#9192;-3 × R2 + 1·7188466249936&#9192;-3 × R4;
         M24 ≔ - 1·4577259475206&#9192;-4 × (R2 + R4);
         M25 ≔ + 4·5024589679127&#9192;-3 × R2 + 9·3971790283374&#9192;-4 × R4;
         M26 ≔ - 1·4737756452780&#9192;-3 × R2 + 3·0759488725998&#9192;-4 × R4;
         M33 ≔ + 1·5810259199209&#9192;-3 × R2 + 9·7107020727290&#9192;-2 × R4 + R5/20;
         M34 ≔ - 2·1932154960131&#9192;-4 × R2 - 8·2354889460254&#9192;-3 × R4;
         M35 ≔ + 6·7741558661123&#9192;-3 × R2 + 5·3089789712112&#9192;-2 × R4;
         M36 ≔ - 2·2173630018492&#9192;-3 × R2 + 1·7377712856071&#9192;-2 × R4;
         M44 ≔ + 3·0424512029457&#9192;-5 × R2 + 6·9843846173158&#9192;-4 × R4;
         M45 ≔ - 9·3971790283542&#9192;-4 × R2 - 4·5024589679131&#9192;-3 × R4;
         M46 ≔ + 3·0759488726060&#9192;-4 × R2 - 1·4737756452778&#9192;-3 × R4;
         M55 ≔ + 2·9024943310657&#9192;-2 × (R2 + R4) + 3·5555555555556&#9192;-1 × R3;
         M56 ≔ + 9·5006428402050&#9192;-3 × (R4-R2);
         M66 ≔ + 3·1098153547125&#9192;-3 × (R2 + R4);

         <u>comment</u> ELEMENT LOAD VECTOR;
         F1 ≔ F5; F2 ≔ F(X2); F3 ≔ F(X3); F4 ≔ F(X4); F5 ≔ F(XL);
         B1 ≔ + 1·6258748099336&#9192;-1 × F2 + 2·0745852339969&#9192;-2 × F4 + F1/20;
         B2 ≔ + 1·3788780589233&#9192;-2 × F2 + 2·8778860774335&#9192;-3 × F4;
         B3 ≔ + 2·0745852339969&#9192;-2 × F2 + 1·6258748099336&#9192;-1 × F4 + F5/20;
         B4 ≔ - 2·8778860774335&#9192;-3 × F2 - 1·3788780589233&#9192;-2 × F4;
         B5 ≔ + (F2 + F4)/11·25       + 3·5555555555556&#9192;-1 × F3;
         B6 ≔ + 2·9095718698132&#9192;-2 × (F4-F2);

         A11 ≔ H2 × (H2 × M11 + S11) + B11; A12 ≔ H2 × (H2 × M12 + S12) + B12;
         A13 ≔ H2 × (H2 × M13 + S13) + B13; A14 ≔ H2 × (H2 × M14 + S14) + B14;
         A15 ≔ H2 × (H2 × M15 + S15) + B15; A16 ≔ H2 × (H2 × M16 + S16) + B16;
         A22 ≔ H2 × (H2 × M22 + S22) + B22; A23 ≔ H2 × (H2 × M23 + S23) + B23;
         A24 ≔ H2 × (H2 × M24 + S24) + B24; A25 ≔ H2 × (H2 × M25 + S25) + B25;
         A26 ≔ H2 × (H2 × M26 + S26) + B26; A33 ≔ H2 × (H2 × M33 + S33) + B33;
         A34 ≔ H2 × (H2 × M34 + S34) + B34; A35 ≔ H2 × (H2 × M35 + S35) + B35;
         A36 ≔ H2 × (H2 × M36 + S36) + B36; A44 ≔ H2 × (H2 × M44 + S44) + B44;
         A45 ≔ H2 × (H2 × M45 + S45) + B45; A46 ≔ H2 × (H2 × M46 + S46) + B46;
         A55 ≔ H2 × (H2 × M55 + S55) + B55; A56 ≔ H2 × (H2 × M56 + S56) + B56;
         A66 ≔ H2 × (H2 × M66 + S66) + B66;
         <u>comment</u> STATIC CONDENSATION;
         DET ≔ - A55 × A66 + A56 × A56;
         C15 ≔ (A15 × A66 - A16 × A56)/DET; C16 ≔ (A16 × A55 - A15 × A56)/DET;
         C25 ≔ (A25 × A66 - A26 × A56)/DET; C26 ≔ (A26 × A55 - A25 × A56)/DET;
         C35 ≔ (A35 × A66 - A36 × A56)/DET; C36 ≔ (A36 × A55 - A35 × A56)/DET;
         C45 ≔ (A45 × A66 - A46 × A56)/DET; C46 ≔ (A46 × A55 - A45 × A56)/DET;
         A11 ≔ (A11 + C15 × A15 + C16 × A16)/H3;
         A12 ≔ (A12 + C15 × A25 + C16 × A26)/H2;
         A13 ≔ (A13 + C15 × A35 + C16 × A36)/H3;
         A14 ≔ (A14 + C15 × A45 + C16 × A46)/H2;
         A22 ≔ (A22 + C25 × A25 + C26 × A26)/H;
         A23 ≔ (A23 + C25 × A35 + C26 × A36)/H2;
         A24 ≔ (A24 + C25 × A45 + C26 × A46)/H;
         A33 ≔ (A33 + C35 × A35 + C36 × A36)/H3;
         A34 ≔ (A34 + C35 × A45 + C36 × A46)/H2;
         A44 ≔ (A44 + C45 × A45 + C46 × A46)/H;
         B1 ≔ (B1 + C15 × B5 + C16 × B6) × H; B2 ≔ (B2 + C25 × B5 + C26 × B6) × H2;
         B3 ≔ (B3 + C35 × B5 + C36 × B6) × H; B4 ≔ (B4 + C45 × B5 + C46 × B6) × H2;
      <u>end</u> EL.MATVECEVAL.;
   L ≔ 1; W ≔ V ≔ 0; N2 ≔ N + N - 2; XL1 ≔ X[0]; XL ≔ X[1];
   YA ≔ E[1]; ZA ≔ E[2]; YB ≔ E[3]; ZB ≔ E[4];
   ELEMENTMATVECEVALUATION; EM[2] ≔ &#9192;-12;
   R1 ≔ B3 - A13 × YA - A23 × ZA; D1 ≔ A33; D2 ≔ A44;
   R2 ≔ B4 - A14 × YA - A24 × ZA; E1 ≔ A34;
   <u>for</u> L ≔ L + 1 <u>while</u> L &lt; N <u>do</u>
      <u>begin</u> XL1 ≔ XL; XL ≔ X[L];
         ELEMENTMATVECEVALUATION;
         A[W + 1] ≔ D1 + A11; A[W + 4] ≔ E1 + A12;
         A[W + 7] ≔ A13; A[W + 10] ≔ A14;
         A[W + 5] ≔ D2 + A22; A[W + 8] ≔ A23;
         A[W + 11] ≔ A24; A[W + 14] ≔ 0;
         Y[V + 1] ≔ R1 + B1; Y[V + 2] ≔ R2 + B2;
         R1 ≔ B3; R2 ≔ B4; V ≔ V + 2; W ≔ W + 8;
         D1 ≔ A33; D2 ≔ A44; E1 ≔ A34
      <u>end</u>;
   L ≔ N; XL1 ≔ XL; XL ≔ X[L]; ELEMENTMATVECEVALUATION;
   Y[N2      - 1] ≔ R1 + B1 - A13 × YB - A14 × ZB;
   Y[N2] ≔ R2 + B2 - A23 × YB - A24 × ZB;
   A[W + 1] ≔ D1 + A11; A[W + 4] ≔ E1 + A12; A[W + 5] ≔ D2 + A22;
   CHLDECSOLBND(A, N2, 3, EM, Y)
<u>end</u> FEMHERM;
<u>comment</u> ================== 34600 ================= ;
<u>procedure</u> QZIVAL(N, A, B, ALFR, ALFI, BETA, ITER, EM);
   <u>value</u> N; <u>integer</u> N; <u>array</u> A, B, ALFR, ALFI, BETA, EM;
     <u>integer</u> <u>array</u> ITER;
<u>begin</u> <u>real</u> DWARF, EPS, EPSA, EPSB;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>procedure</u> HSHDECMUL(N, A, B, DWARF); <u>code</u> 34602;
   <u>procedure</u> HESTGL2(N, A, B); <u>code</u> 34604;
   <u>procedure</u> HSH2ROW2(LA, LB, UA, UB, J, A1, A2, A, B); <u>code</u> 34608;
   <u>procedure</u> HSH3ROW2(LA, LB, U, J, A1, A2, A3, A, B); <u>code</u> 34610;
   <u>procedure</u> HSH2COL(LA, LB, U, I, A1, A2, A, B); <u>code</u> 34605;
   <u>procedure</u> HSH3COL(LA, LB, U, I, A1, A2, A3, A, B); <u>code</u> 34606;
   <u>procedure</u> CHSH2(A1R, A1I, A2R, A2I, C, SR, SI); <u>code</u> 34611;
   <u>procedure</u> HSHVECMAT(LR, UR, LC, UC, X, U, A); <u>code</u> 31070;
   <u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A); <u>code</u> 31073;
   <u>procedure</u> QZIT(N, A, B, EPS, EPSA, EPSB, ITER); <u>value</u> N, EPS;
      <u>real</u> EPS, EPSA, EPSB; <u>integer</u> N; <u>integer</u> <u>array</u> ITER; <u>array</u> A, B;
   <u>begin</u> <u>real</u> ANORM, BNORM, ANI, BNI, CONST, A10, A20, A30, B11,
        B22, B33, B44, A11, A12, A21, A22, A33, A34, A43, A44, B12, B34, OLD1, OLD2;
      <u>integer</u> I, Q, M, M1, Q1, J, K, K1, K2, K3, KM1; <u>Boolean</u> STATIONARY;
      ANORM ≔ BNORM ≔ 0; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> BNI ≔ 0; ITER[I] ≔ 0; ANI ≔ <u>if</u> I &gt; 1 <u>then</u> ABS(A[I, I-1]) <u>else</u> 0;
            <u>for</u> J ≔ I <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> ANI ≔ ANI + ABS(A[I, J]); BNI ≔ BNI + ABS(B[I, J])
               <u>end</u>; <u>if</u> ANI &gt; ANORM <u>then</u> ANORM ≔ ANI; <u>if</u> BNI &gt; BNORM <u>then</u>
              BNORM ≔ BNI
         <u>end</u>; <u>if</u> ANORM = 0 <u>then</u> ANORM ≔ EPS; <u>if</u> BNORM = 0 <u>then</u> BNORM ≔ EPS;
      EPSA ≔ EPS × ANORM; EPSB ≔ EPS × BNORM;
      <u>for</u> M ≔ N, M <u>while</u> M &GreaterSlantEqual; 3 <u>do</u>
         <u>begin</u>
            <u>for</u> I ≔ M + 1, I-1 <u>while</u> (<u>if</u> I &gt; 1 <u>then</u> ABS(A[I, I-1]) &gt; EPSA <u>else</u>
              <u>false</u>) <u>do</u> Q ≔ I-1;
            <u>if</u> Q &gt; 1 <u>then</u> A[Q, Q-1] ≔ 0;
            L: <u>if</u> Q &GreaterSlantEqual; M-1 <u>then</u> M ≔ Q-1 <u>else</u>
            <u>begin</u>
               <u>if</u> ABS(B[Q, Q]) &LessSlantEqual; EPSB <u>then</u>
               <u>begin</u> B[Q, Q] ≔ 0; Q1 ≔ Q + 1;
                  HSH2COL(Q, Q, M, Q, A[Q, Q], A[Q1, Q], A, B); A[Q1, Q] ≔ 0;
                  Q ≔ Q1; <u>goto</u> L
               <u>end</u> <u>else</u> M1 ≔ M-1; Q1 ≔ Q + 1; CONST ≔ 0·75; ITER[M] ≔ ITER[M] + 1;
               STATIONARY ≔ <u>if</u> ITER[M] = 1 <u>then</u> <u>true</u> <u>else</u>
                 ABS(A[M, M-1]) &GreaterSlantEqual; CONST × OLD1 ∧ ABS(A[M-1, M-2]) &GreaterSlantEqual; CONST × OLD2;
               <u>if</u> ITER[M] &gt; 30 ∧ STATIONARY <u>then</u>
               <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> ITER[I] ≔ -1;
                  <u>goto</u> OUT
               <u>end</u>;
               <u>if</u> ITER[M] = 10 ∧ STATIONARY <u>then</u>
               <u>begin</u> A10 ≔ 0; A20 ≔ 1; A30 ≔ 1·1605
               <u>end</u> <u>else</u>
               <u>begin</u> B11 ≔ B[Q, Q]; B22 ≔ <u>if</u> ABS(B[Q1, Q1]) &lt; EPSB <u>then</u> EPSB
                  <u>else</u> B[Q1, Q1];
                  B33 ≔ <u>if</u> ABS(B[M1, M1]) &lt; EPSB <u>then</u> EPSB <u>else</u> B[M1, M1];
                  B44 ≔ <u>if</u> ABS(B[M, M]) &lt; EPSB <u>then</u> EPSB <u>else</u> B[M, M] ;
                  A11 ≔ A[Q, Q]/B11; A12 ≔ A[Q, Q1]/B22; A21 ≔ A[Q1, Q]/B11;
                  A22 ≔ A[Q1, Q1]/B22; A33 ≔ A[M1, M1]/B33; A34 ≔ A[M1, M]/B44;
                  A43 ≔ A[M, M1]/B33; A44 ≔ A[M, M]/B44; B12 ≔ B[Q, Q1]/B22;
                  B34 ≔ B[M1, M]/B44;
                  A10 ≔ ((A33-A11) × (A44-A11)-A34 × A43 + A43 × B34 × A11)/A21
                    + A12-A11 × B12;
                  A20 ≔ (A22-A11-A21 × B12)-(A33-A11)-(A44-A11) + A43 × B34;
                  A30 ≔ A[Q + 2, Q1]/B22
               <u>end</u>; OLD1 ≔ ABS(A[M, M-1]); OLD2 ≔ ABS(A[M-1, M-2]);
               <u>for</u> K ≔ Q <u>step</u> 1 <u>until</u> M1 <u>do</u>
                  <u>begin</u> K1 ≔ K + 1; K2 ≔ K + 2; K3 ≔ <u>if</u> K + 3 &gt; M <u>then</u> M <u>else</u> K + 3;
                     KM1 ≔ <u>if</u> K-1 &lt; Q <u>then</u> Q <u>else</u> K-1;
                     <u>if</u> K ≠ M1 <u>then</u>
                     <u>begin</u> <u>if</u> K = Q <u>then</u>
                        <u>begin</u>
                           HSH3COL(KM1, KM1, M, K, A[K, KM1], A[K1, KM1], A[K2, KM1], A, B);
                           A[K1, KM1] ≔ A[K2, KM1] ≔ 0
                        <u>end</u>;
                        HSH3ROW2(Q, Q, K3, K, B[K2, K2], B[K2, K1], B[K2, K], A, B);
                        B[K2, K] ≔ B[K2, K1] ≔ 0 ;
                     <u>end</u> <u>else</u>
                     <u>begin</u> HSH2COL(KM1, KM1, M, K, A[K, KM1], A[K1, KM1], A, B);
                        A[K1, KM1] ≔ 0
                     <u>end</u>;
                     HSH2ROW2(Q, Q, K3, K3, K, B[K1, K1], B[K1, K], A, B); B[K1, K] ≔ 0
                  <u>end</u>
            <u>end</u>;
            OUT:
         <u>end</u>
   <u>end</u> QZIT;
<u>end</u> QZI;
<u>comment</u> ================== 34601 ================= ;
<u>procedure</u> QZI(N, A, B, X, ALFR, ALFI, BETA, ITER, EM);
   <u>value</u> N; <u>integer</u> N; <u>array</u> A, B, X, ALFR, ALFI, BETA, EM;
     <u>integer</u> <u>array</u> ITER;
<u>begin</u> <u>real</u> DWARF, EPS, EPSA, EPSB;
   <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> HSHDECMUL(N, A, B, DWARF); <u>code</u> 34602;
   <u>procedure</u> HESTGL3(N, A, B, X); <u>code</u> 34603;
   <u>procedure</u> HSH2ROW3(L, UA, UB, UX, J, A1, A2, A, B, X); <u>code</u> 34607;
   <u>procedure</u> HSH3ROW3(L, U, UX, J, A1, A2, A3, A, B, X); <u>code</u> 34609;
   <u>procedure</u> HSH2COL(LA, LB, U, I, A1, A2, A, B); <u>code</u> 34605;
   <u>procedure</u> HSH3COL(LA, LB, U, I, A1, A2, A3, A, B); <u>code</u> 34606;
   <u>procedure</u> CHSH2(A1R, A1I, A2R, A2I, C, SR, SI); <u>code</u> 34611;
   <u>procedure</u> COMDIV(XR, XI, YR, YI, ZR, ZI); <u>code</u> 34342;
   <u>procedure</u> QZIT(N, A, B, X, EPS, EPSA, EPSB, ITER); <u>value</u> N, EPS;
      <u>real</u> EPS, EPSA, EPSB; <u>integer</u> N; <u>integer</u> <u>array</u> ITER; <u>array</u> A, B, X;
   <u>begin</u> <u>real</u> ANORM, BNORM, ANI, BNI, CONST, A10, A20, A30, B11,
        B22, B33, B44, A11, A12, A21, A22, A33, A34, A43, A44, B12, B34, OLD1, OLD2;
      <u>integer</u> I, Q, M, M1, Q1, J, K, K1, K2, K3, KM1; <u>Boolean</u> STATIONARY;
      ANORM ≔ BNORM ≔ 0; <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> N <u>do</u>
         <u>begin</u> BNI ≔ 0; ITER[I] ≔ 0; ANI ≔ <u>if</u> I &gt; 1 <u>then</u> ABS(A[I, I-1]) <u>else</u> 0;
            <u>for</u> J ≔ I <u>step</u> 1 <u>until</u> N <u>do</u>
               <u>begin</u> ANI ≔ ANI + ABS(A[I, J]); BNI ≔ BNI + ABS(B[I, J])
               <u>end</u>; <u>if</u> ANI &gt; ANORM <u>then</u> ANORM ≔ ANI; <u>if</u> BNI &gt; BNORM <u>then</u>
              BNORM ≔ BNI
         <u>end</u>; <u>if</u> ANORM = 0 <u>then</u> ANORM ≔ EPS; <u>if</u> BNORM = 0 <u>then</u> BNORM ≔ EPS;
      EPSA ≔ EPS × ANORM; EPSB ≔ EPS × BNORM;
      <u>for</u> M ≔ N, M <u>while</u> M &GreaterSlantEqual; 3 <u>do</u>
         <u>begin</u>
            <u>for</u> I ≔ M + 1, I-1 <u>while</u> (<u>if</u> I &gt; 1 <u>then</u> ABS(A[I, I-1]) &gt; EPSA <u>else</u>
              <u>false</u>) <u>do</u> Q ≔ I-1;
            <u>if</u> Q &gt; 1 <u>then</u> A[Q, Q-1] ≔ 0;
            L: <u>if</u> Q &GreaterSlantEqual; M-1 <u>then</u> M ≔ Q-1 <u>else</u>
            <u>begin</u>
               <u>if</u> ABS(B[Q, Q]) &LessSlantEqual; EPSB <u>then</u>
               <u>begin</u> B[Q, Q] ≔ 0; Q1 ≔ Q + 1;
                  HSH2COL(Q, Q, N, Q, A[Q, Q], A[Q1, Q], A, B); A[Q1, Q] ≔ 0;
                  Q ≔ Q1; <u>goto</u> L
               <u>end</u> <u>else</u> M1 ≔ M-1; Q1 ≔ Q + 1; CONST ≔ 0·75; ITER[M] ≔ ITER[M] + 1;
               STATIONARY ≔ <u>if</u> ITER[M] = 1 <u>then</u> <u>true</u> <u>else</u>
                 ABS(A[M, M-1]) &GreaterSlantEqual; CONST × OLD1 ∧ ABS(A[M-1, M-2]) &GreaterSlantEqual; CONST × OLD2;
               <u>if</u> ITER[M] &gt; 30 ∧ STATIONARY <u>then</u>
               <u>begin</u> <u>for</u> I ≔ 1 <u>step</u> 1 <u>until</u> M <u>do</u> ITER[I] ≔ -1;
                  <u>goto</u> OUT
               <u>end</u>;
               <u>if</u> ITER[M] = 10 ∧ STATIONARY <u>then</u>
               <u>begin</u> A10 ≔ 0; A20 ≔ 1; A30 ≔ 1·1605
               <u>end</u> <u>else</u>
               <u>begin</u> B11 ≔ B[Q, Q]; B22 ≔ <u>if</u> ABS(B[Q1, Q1]) &lt; EPSB <u>then</u> EPSB
                  <u>else</u> B[Q1, Q1];
                  B33 ≔ <u>if</u> ABS(B[M1, M1]) &lt; EPSB <u>then</u> EPSB <u>else</u> B[M1, M1];
                  B44 ≔ <u>if</u> ABS(B[M, M]) &lt; EPSB <u>then</u> EPSB <u>else</u> B[M, M] ;
                  A11 ≔ A[Q, Q]/B11; A12 ≔ A[Q, Q1]/B22; A21 ≔ A[Q1, Q]/B11;
                  A22 ≔ A[Q1, Q1]/B22; A33 ≔ A[M1, M1]/B33; A34 ≔ A[M1, M]/B44;
                  A43 ≔ A[M, M1]/B33; A44 ≔ A[M, M]/B44; B12 ≔ B[Q, Q1]/B22;
                  B34 ≔ B[M1, M]/B44;
                  A10 ≔ ((A33-A11) × (A44-A11)-A34 × A43 + A43 × B34 × A11)/A21
                    + A12-A11 × B12;
                  A20 ≔ (A22-A11-A21 × B12)-(A33-A11)-(A44-A11) + A43 × B34;
                  A30 ≔ A[Q + 2, Q1]/B22
               <u>end</u>; OLD1 ≔ ABS(A[M, M-1]); OLD2 ≔ ABS(A[M-1, M-2]);
               <u>for</u> K ≔ Q <u>step</u> 1 <u>until</u> M1 <u>do</u>
                  <u>begin</u> K1 ≔ K + 1; K2 ≔ K + 2; K3 ≔ <u>if</u> K + 3 &gt; M <u>then</u> M <u>else</u> K + 3;
                     KM1 ≔ <u>if</u> K-1 &lt; Q <u>then</u> Q <u>else</u> K-1;
                     <u>if</u> K ≠ M1 <u>then</u>
                     <u>begin</u> <u>if</u> K = Q <u>then</u>
                          HSH3COL(KM1, KM1, N, K, A10, A20, A30, A, B) <u>else</u>
                        <u>begin</u>
                           HSH3COL(KM1, KM1, N, K, A[K, KM1], A[K1, KM1], A[K2, KM1], A, B);
                           A[K1, KM1] ≔ A[K2, KM1] ≔ 0
                        <u>end</u>;
                        HSH3ROW3(1, K3, N, K, B[K2, K2], B[K2, K1], B[K2, K], A, B, X);
                        B[K2, K] ≔ B[K2, K1] ≔ 0 ;
                     <u>end</u> <u>else</u>
                     <u>begin</u> HSH2COL(KM1, KM1, N, K, A[K, KM1], A[K1, KM1], A, B);
                        A[K1, KM1] ≔ 0
                     <u>end</u>;
                     HSH2ROW3(1, K3, K3, N, K, B[K1, K1], B[K1, K], A, B, X); B[K1, K] ≔ 0
                  <u>end</u>
            <u>end</u>
         <u>end</u>; OUT:
   <u>end</u> QZIT;
<u>end</u> QZI;
<u>procedure</u> QZVAL(N, A, B, X, EPSA, EPSB, ALFR, ALFI, BETA); <u>value</u> N;
   <u>real</u> EPSA, EPSB; <u>integer</u> N; <u>array</u> ALFR, ALFI, BETA, A, B, X;
<u>begin</u> <u>integer</u> M, L, J; <u>real</u> AN, BN, A11, A12, A21, A22, B11, B12, B22, E, C, D,
     ER, EI, A11R, A11I, A12R, A12I, A21R, A21I, A22R, A22I, CZ, SZR, SZI,
     CQ, SQR, SQI, SSR, SSI, TR, TI, BDR, BDI, R;
   <u>for</u> M ≔ N, M <u>while</u> M &gt; 0 <u>do</u>
        <u>if</u> (<u>if</u> M &gt; 1 <u>then</u> A[M, M-1] = 0 <u>else</u> <u>true</u>) <u>then</u>
      <u>begin</u> ALFR[M] ≔ A[M, M]; BETA[M] ≔ B[M, M]; ALFI[M] ≔ 0; M ≔ M-1
      <u>end</u> <u>else</u>
      <u>begin</u> L ≔ M-1; <u>if</u> ABS(B[L, L]) &LessSlantEqual; EPSB <u>then</u>
         <u>begin</u> B[L, L] ≔ 0; HSH2COL(L, L, N, L, A[L, L], A[M, L], A, B);
            A[M, L] ≔ B[M, L] ≔ 0; ALFR[L] ≔ A[L, L]; ALFR[M] ≔ A[M, M];
            BETA[L] ≔ B[L, L]; BETA[M] ≔ B[M, M]; ALFI[M] ≔ ALFI[L] ≔ 0;
         <u>end</u> <u>else</u> <u>if</u> ABS(B[M, M]) &LessSlantEqual; EPSB <u>then</u>
         <u>begin</u> B[M, M] ≔ 0; HSH2ROW3(1, M, M, N, L, A[M, M], A[M, L], A, B, X);
            A[M, L] ≔ B[M, L] ≔ 0; ALFR[L] ≔ A[L, L]; ALFR[M] ≔ A[M, M];
            BETA[L] ≔ B[L, L]; BETA[M] ≔ B[M, M]; ALFI[M] ≔ ALFI[L] ≔ 0;
         <u>end</u> <u>else</u>
         <u>begin</u>
            AN ≔ ABS(A[L, L]) + ABS(A[L, M]) + ABS(A[M, L]) + ABS(A[M, M]);
            BN ≔ ABS(B[L, L]) + ABS(B[L, M]) + ABS(B[M, M]);
            A11 ≔ A[L, L]/AN; A12 ≔ A[L, M]/AN; A21 ≔ A[M, L]/AN; A22 ≔ A[M, M]/AN;
            B11 ≔ B[L, L]/BN; B12 ≔ B[L, M]/BN; B22 ≔ B[M, M]/BN;
            E ≔ A11/B11;
            C ≔ ((A22-E × B22)/B22-(A21 × B12)/(B11 × B22))/2;
            D ≔ C × C + (A21 × (A12-E × B12))/(B11 × B22);
            <u>if</u> D &GreaterSlantEqual; 0 <u>then</u>
            <u>begin</u> E ≔ E + (<u>if</u> C &lt; 0 <u>then</u> C-SQRT(D) <u>else</u> C + SQRT(D));
               A11 ≔ A11-E × B11; A12 ≔ A12-E × B12; A22 ≔ A22-E × B22;
               <u>if</u> ABS(A11) + ABS(A12) &GreaterSlantEqual; ABS(A21) + ABS(A22) <u>then</u>
                 HSH2ROW3(1, M, M, N, L, A12, A11, A, B, X) <u>else</u>
                 HSH2ROW3(1, M, M, N, L, A22, A21, A, B, X);
               <u>if</u> AN &GreaterSlantEqual; ABS(E) × BN <u>then</u>
                 HSH2COL(L, L, N, L, B[L, L], B[M, L], A, B) <u>else</u>
                 HSH2COL(L, L, N, L, A[L, L], A[M, L], A, B);
               A[M, L] ≔ B[M, L] ≔ 0;
               ALFR[L] ≔ A[L, L]; ALFR[M] ≔ A[M, M]; BETA[L] ≔ B[L, L];
               BETA[M] ≔ B[M, M]; ALFI[M] ≔ ALFI[L] ≔ 0;
            <u>end</u> <u>else</u>
            <u>begin</u>
               ER ≔ E + C; EI ≔ SQRT(-D); A11R ≔ A11-ER × B11; A11I ≔ EI × B11;
               A12R ≔ A12-ER × B12; A12I ≔ EI × B12; A21R ≔ A21; A21I ≔ 0;
               A22R ≔ A22-ER × B22; A22I ≔ EI × B22;
               <u>if</u> ABS(A11R) + ABS(A11I) + ABS(A12R) + ABS(A12I) &GreaterSlantEqual;
                 ABS(A21R) + ABS(A22R) + ABS(A22I) <u>then</u>
                 CHSH2(A12R, A12I, -A11R, -A11I, CZ, SZR, SZI) <u>else</u>
                 CHSH2(A22R, A22I, -A21R, -A21I, CZ, SZR, SZI);
               <u>if</u> AN &GreaterSlantEqual; (ABS(ER) + ABS(EI)) × BN <u>then</u>
                 CHSH2(CZ × B11 + SZR × B12, SZI × B12, SZR × B22, SZI × B22, CQ, SQR, SQI)
               <u>else</u> CHSH2(CZ × A11 + SZR × A12, SZI × A12, CZ × A21 + SZR × A22, SZI × A22,
                 CQ, SQR, SQI); SSR ≔ SQR × SZR + SQI × SZI; SSI ≔ SQR × SZI-SQI × SZR;
               TR ≔ CQ × CZ × A11 + CQ × SZR × A12 + SQR × CZ × A21 + SSR × A22;
               TI ≔ CQ × SZI × A12-SQI × CZ × A21 + SSI × A22;
               BDR ≔ CQ × CZ × B11 + CQ × SZR × B12 + SSR × B22;
               BDI ≔ CQ × SZI × B12 + SSI × B22;
               R ≔ SQRT(BDR × BDR + BDI × BDI); BETA[L] ≔ BN × R;
               ALFR[L] ≔ AN × (TR × BDR + TI × BDI)/R;
               ALFI[L] ≔ AN × (TR × BDI-TI × BDR)/R;
               TR ≔ SSR × A11-SQR × CZ × A12-CQ × SZR × A21 + CQ × CZ × A22;
               TI ≔ -SSI × A11-SQI × CZ × A12 + CQ × SZI × A21;
               BDR ≔ SSR × B11-SQR × CZ × B12 + CQ × CZ × B22;
               BDI ≔ -SSI × B11-SQI × CZ × B12;
               R ≔ SQRT(BDR × BDR + BDI × BDI); BETA[M] ≔ BN × R;
               ALFR[M] ≔ AN × (TR × BDR + TI × BDI)/R;
               ALFI[M] ≔ AN × (TR × BDI-TI × BDR)/R;
            <u>end</u>
         <u>end</u>; M ≔ M-2
      <u>end</u>
<u>end</u> QZVAL;
<u>comment</u> ================== 34602 ================= ;
<u>procedure</u> HSHDECMUL(N, A, B, DWARF); <u>value</u> N, DWARF; <u>integer</u> N;
     <u>real</u> DWARF; <u>array</u> A, B;
<u>begin</u>  <u>array</u> V[1:N]; <u>integer</u> J, K, K1, N1; <u>real</u> R, T, C;
   <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>procedure</u> HSHVECMAT(LR, UR, LC, UC, X, U, A); <u>code</u> 31070;
   K ≔ 1; N1 ≔ N + 1;
   <u>for</u> K1 ≔ 2 <u>step</u> 1 <u>until</u> N1 <u>do</u>
      <u>begin</u> R ≔ TAMMAT(K1, N, K, K, B, B);
         <u>if</u> R &gt; DWARF <u>then</u>
         <u>begin</u> R ≔ <u>if</u> B[K, K] &lt; 0 <u>then</u> -SQRT(R + B[K, K] × B[K, K])
            <u>else</u> SQRT(R + B[K, K] × B[K, K]); T ≔ B[K, K] + R; C ≔ -T/R;
            B[K, K] ≔ -R; V[K] ≔ 1;
            <u>for</u> J ≔ K1 <u>step</u> 1 <u>until</u> N <u>do</u> V[J] ≔ B[J, K]/T;
            HSHVECMAT(K, N, K1, N, C, V, B); HSHVECMAT(K, N, 1, N, C, V, A)
         <u>end</u>; K ≔ K1
      <u>end</u>
<u>end</u> HSHDECMUL;
<u>comment</u> ================== 34603 ================= ;
<u>procedure</u> HESTGL3(N, A, B, X); <u>value</u> N; <u>integer</u> N; <u>array</u> A, B, X;
<u>begin</u> <u>integer</u> NM1, K, L, K1, L1;
   <u>procedure</u> HSH2COL(LA, LB, U, I, A1, A2, A, B); <u>code</u> 34605;
   <u>procedure</u> HSH2ROW3(L, UA, UB, UX, J, A1, A2, A, B, X); <u>code</u> 34607;
   <u>if</u> N &gt; 2 <u>then</u>
   <u>begin</u> <u>for</u> K ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
           <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> K-1 <u>do</u> B[K, L] ≔ 0;
      NM1 ≔ N-1; K ≔ 1;
      <u>for</u> K1 ≔ 2 <u>step</u> 1 <u>until</u> NM1 <u>do</u>
         <u>begin</u> L1 ≔ N;
            <u>for</u> L ≔ N-1 <u>step</u> -1 <u>until</u> K1 <u>do</u>
               <u>begin</u>
                  HSH2COL(K, L, N, L, A[L, K], A[L1, K], A, B); A[L1, K] ≔ 0;
                  HSH2ROW3(1, N, L1, N, L, B[L1, L1], B[L1, L], A, B, X);
                  B[L1, L] ≔ 0; L1 ≔ L
               <u>end</u>; K ≔ K1
         <u>end</u>
   <u>end</u>
<u>end</u> HESTGL3;
<u>comment</u> ================== 34604 ================= ;
<u>procedure</u> HESTGL2(N, A, B); <u>value</u> N; <u>integer</u> N; <u>array</u> A, B;
<u>begin</u> <u>integer</u> NM1, K, L, K1, L1;
   <u>procedure</u> HSH2COL(LA, LB, U, I, A1, A2, A, B); <u>code</u> 34605;
   <u>procedure</u> HSH2ROW2(LA, LB, UA, UB, A1, A2, A, B); <u>code</u> 34608;
   <u>if</u> N &gt; 2 <u>then</u>
   <u>begin</u> <u>for</u> K ≔ 2 <u>step</u> 1 <u>until</u> N <u>do</u>
           <u>for</u> L ≔ 1 <u>step</u> 1 <u>until</u> K-1 <u>do</u> B[K, L] ≔ 0;
      NM1 ≔ N-1; K ≔ 1;
      <u>for</u> K1 ≔ 2 <u>step</u> 1 <u>until</u> NM1 <u>do</u>
         <u>begin</u> L1 ≔ N;
            <u>for</u> L ≔ N-1 <u>step</u> -1 <u>until</u> K1 <u>do</u>
               <u>begin</u>
                  HSH2COL(K, L, N, L, A[L, K], A[L1, K], A, B); A[L1, K] ≔ 0;
                  HSH2ROW2(1, 1, N, L1, L, B[L1, L1], B[L1, L], A, B);
                  B[L1, L] ≔ 0; L1 ≔ L
               <u>end</u>; K ≔ K1
         <u>end</u>
   <u>end</u>
<u>end</u> HESTGL2;
<u>comment</u> ================== 34605 ================= ;
<u>procedure</u> HSH2COL(LA, LB, U, I, A1, A2, A, B); <u>value</u> LA, LB, U, I, A1, A2;
   <u>integer</u> LA, LB, U, I; <u>real</u> A1, A2; <u>array</u> A, B;
   <u>if</u> A2 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>array</u> V[I:I + 1];
      <u>procedure</u> HSHVECMAT(LR, UR, LC, UC, X, U, A); <u>code</u> 31070;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2) <u>else</u> SQRT(A1 × A1 + A2 × A2);
      T ≔ A1 + R; C ≔ -T/R; V[I] ≔ 1; V[I + 1] ≔ A2/T;
      HSHVECMAT(I, I + 1, LA, U, C, V, A); HSHVECMAT(I, I + 1, LB, U, C, V, B)
   <u>end</u> HSH2COL;
<u>comment</u> ================== 34606 ================= ;
<u>procedure</u> HSH3COL(LA, LB, U, I, A1, A2, A3, A, B);
   <u>value</u> LA, LB, U, I, A1, A2, A3; <u>integer</u> LA, LB, I, U; <u>real</u> A1, A2, A3; <u>array</u> A, B;
   <u>if</u> A2 ≠ 0 ∨ A3 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>array</u> V[I:I + 2];
      <u>procedure</u> HSHVECMAT(LR, UR, LC, UC, X, U, A); <u>code</u> 31070;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2 + A3 × A3)
      <u>else</u> SQRT(A1 × A1 + A2 × A2 + A3 × A3);
      T ≔ A1 + R; C ≔ -T/R; V[I] ≔ 1; V[I + 1] ≔ A2/T; V[I + 2] ≔ A3/T;
      HSHVECMAT(I, I + 2, LA, U, C, V, A); HSHVECMAT(I, I + 2, LB, U, C, V, B)
   <u>end</u> HSH3COL;
<u>comment</u> ================== 34607 ================= ;
<u>procedure</u> HSH2ROW3(L, UA, UB, UX, J, A1, A2, A, B, X); <u>value</u> L, UA, UB, UX,
     J, A1, A2; <u>integer</u> L, UA, UB, UX, J; <u>real</u> A1, A2; <u>array</u> A, B, X;
   <u>if</u> A2 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>integer</u> K; <u>array</u> V[J:J + 1];
      <u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A); <u>code</u> 31073;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2) <u>else</u> SQRT(A1 × A1 + A2 × A2);
      T ≔ A1 + R; C ≔ -T/R; V[J + 1] ≔ 1; V[J] ≔ A2/T;
      HSHVECTAM(L, UA, J, J + 1, C, V, A); HSHVECTAM(L, UB, J, J + 1, C, V, B);
      HSHVECTAM(1, UX, J, J + 1, C, V, X)
   <u>end</u> HSH2ROW3;
<u>comment</u> ================== 34608 ================= ;
<u>procedure</u> HSH2ROW2(LA, LB, UA, UB, J, A1, A2, A, B); <u>value</u> LA, LB, UA, UB,
     J, A1, A2; <u>integer</u> LA, LB, UA, UB, J; <u>real</u> A1, A2; <u>array</u> A, B;
   <u>if</u> A2 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>integer</u> K; <u>array</u> V[J:J + 1];
      <u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A); <u>code</u> 31073;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2) <u>else</u> SQRT(A1 × A1 + A2 × A2);
      T ≔ A1 + R; C ≔ -T/R; V[J + 1] ≔ 1; V[J] ≔ A2/T;
      HSHVECTAM(LA, UA, J, J + 1, C, V, A); HSHVECTAM(LB, UB, J, J + 1, C, V, B)
   <u>end</u> HSH2ROW2;
<u>comment</u> ================== 34609 ================= ;
<u>procedure</u> HSH3ROW3(L, U, UX, J, A1, A2, A3, A, B, X);
   <u>value</u> L, U, UX, J, A1, A2, A3; <u>integer</u> L, J, U, UX; <u>real</u> A1, A2, A3; <u>array</u> A, B, X;
   <u>if</u> A2 ≠ 0 ∨ A3 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>array</u> V[J:J + 2]; <u>integer</u> K;
      <u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A); <u>code</u> 31073;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2 + A3 × A3)
      <u>else</u> SQRT(A1 × A1 + A2 × A2 + A3 × A3);
      T ≔ A1 + R; C ≔ -T/R; V[J + 2] ≔ 1; V[J + 1] ≔ A2/T; V[J] ≔ A3/T;
      HSHVECTAM(L, U, J, J + 2, C, V, A); HSHVECTAM(L, U, J, J + 2, C, V, B);
      HSHVECTAM(L, UX, J, J + 2, C, V, X)
   <u>end</u> HSH3ROW3;
<u>comment</u> ================== 34610 ================= ;
<u>procedure</u> HSH3ROW2(LA, LB, U, J, A1, A2, A3, A, B);
   <u>value</u> LA, LB, U, J, A1, A2, A3; <u>integer</u> LA, LB, U, J; <u>real</u> A1, A2, A3; <u>array</u> A, B;
   <u>if</u> A2 ≠ 0 ∨ A3 ≠ 0 <u>then</u>
   <u>begin</u> <u>real</u> R, T, C; <u>array</u> V[J:J + 2];
      <u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A); <u>code</u> 31073;
      R ≔ <u>if</u> A1 &lt; 0 <u>then</u> -SQRT(A1 × A1 + A2 × A2 + A3 × A3)
      <u>else</u> SQRT(A1 × A1 + A2 × A2 + A3 × A3);
      T ≔ A1 + R; C ≔ -T/R; V[J + 2] ≔ 1; V[J + 1] ≔ A2/T; V[J] ≔ A3/T;
      HSHVECTAM(LA, U, J, J + 2, C, V, A); HSHVECTAM(LB, U, J, J + 2, C, V, B)
   <u>end</u> HSH3ROW2;
<u>comment</u> ================== 31070 ================= ;
<u>procedure</u> HSHVECMAT(LR, UR, LC, UC, X, U, A);
   <u>value</u> LR, UR, LC, UC, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> TAMVEC(L, U, I, A, B); <u>code</u> 34012;
   <u>procedure</u> ELMCOLVEC(L, U, I, A, B, X); <u>code</u> 34022;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
        ELMCOLVEC(LR, UR, LC, A, U, TAMVEC(LR, UR, LC, A, U) × X)
<u>end</u>;
<u>comment</u> ================== 31071 ================= ;
<u>procedure</u> HSHCOLMAT(LR, UR, LC, UC, I, X, U, A);
   <u>value</u> LR, UR, LC, UC, I, X; <u>integer</u> LR, UR, LC, UC, I;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> TAMMAT(L, U, I, J, A, B); <u>code</u> 34014;
   <u>procedure</u> ELMCOL(L, U, I, J, A, B, X); <u>code</u> 34023;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
        ELMCOL(LR, UR, LC, I, A, U, TAMMAT(LR, UR, LC, I, A, U) × X)
<u>end</u>;
<u>comment</u> ================== 31072 ================= ;
<u>procedure</u> HSHROWMAT(LR, UR, LC, UC, I, X, U, A);
   <u>value</u> LR, UR, LC, UC, I, X; <u>integer</u> LR, UR, LC, UC, I;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> ELMCOLROW(L, U, I, J, A, B, X); <u>code</u> 34029;
   <u>for</u> LC ≔ LC <u>step</u> 1 <u>until</u> UC <u>do</u>
        ELMCOLROW(LR, UR, LC, I, A, U, MATMAT(LR, UR, I, LC, U, A) × X)
<u>end</u>;
<u>comment</u> ================== 31073 ================= ;
<u>procedure</u> HSHVECTAM(LR, UR, LC, UC, X, U, A);
   <u>value</u> LR, UR, LC, UC, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> MATVEC(L, U, I, A, B); <u>code</u> 34011;
   <u>procedure</u> ELMROWVEC(L, U, I, A, B, X); <u>code</u> 34027;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        ELMROWVEC(LC, UC, LR, A, U, MATVEC(LC, UC, LR, A, U) × X)
<u>end</u>;
<u>comment</u> ================== 31074 ================= ;
<u>procedure</u> HSHCOLTAM(LR, UR, LC, UC, I, X, U, A);
   <u>value</u> LR, UR, LC, UC, I, X; <u>integer</u> LR, UR, LC, UC, I;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> MATMAT(L, U, I, J, A, B); <u>code</u> 34013;
   <u>procedure</u> ELMROWCOL(L, U, I, J, A, B, X); <u>code</u> 34028;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        ELMROWCOL(LC, UC, LR, I, A, U, MATMAT(LC, UC, LR, I, A, U) × X)
<u>end</u>;
<u>comment</u> ================== 31075 ================= ;
<u>procedure</u> HSHROWTAM(LR, UR, LC, UC, I, X, U, A);
   <u>value</u> LR, UR, LC, UC, I, X; <u>integer</u> LR, UR, LC, UC, I;
     <u>real</u> X; <u>array</u> U, A;
<u>begin</u> <u>real</u> <u>procedure</u> MATTAM(L, U, I, J, A, B); <u>code</u> 34015;
   <u>procedure</u> ELMROW(L, U, I, J, A, B, X); <u>code</u> 34024;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
        ELMROW(LC, UC, LR, I, A, U, MATTAM(LC, UC, LR, I, A, U) × X)
<u>end</u>;
<u>comment</u> ================== 30006 ================= ;
<u>real</u> <u>procedure</u> PI;
   PI ≔ 3·14159265358979;
<u>comment</u> ================== 30007 ================= ;
<u>real</u> <u>procedure</u> E;
   E ≔ 2·71828182845905;
<u>comment</u> ================== 34410 ================= ;
<u>procedure</u> LNGVECVEC(L, U, SHIFT, A, B, C, CC, D, DD);
   <u>value</u> L, U, SHIFT, C, CC; <u>integer</u> L, U, SHIFT;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[L], B[L + SHIFT], E, EE);
         LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGVECVEC;
<u>comment</u> ================== 34411 ================= ;
<u>procedure</u> LNGMATVEC(L, U, I, A, B, C, CC, D, DD);
   <u>value</u> L, U, I, C, CC; <u>integer</u> L, U, I;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[I, L], B[I], E, EE); LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGMATVEC;
<u>comment</u> ================== 34412 ================= ;
<u>procedure</u> LNGTAMVEC(L, U, I, A, B, C, CC, D, DD);
   <u>value</u> L, U, I, C, CC; <u>integer</u> L, U, I;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[L, I], B[I], E, EE); LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGTAMVEC;
<u>comment</u> ================== 34413 ================= ;
<u>procedure</u> LNGMATMAT(L, U, I, J, A, B, C, CC, D, DD);
   <u>value</u> L, U, I, J, C, CC; <u>integer</u> L, U, I, J;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[I, L], B[L, J], E, EE); LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGMATMAT;
<u>comment</u> ================== 34414 ================= ;
<u>procedure</u> LNGTAMMAT(L, U, I, J, A, B, C, CC, D, DD);
   <u>value</u> L, U, I, J, C, CC; <u>integer</u> L, U, I, J;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[L, I], B[L, J], E, EE); LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGTAMMAT;
<u>comment</u> ================== 34415 ================= ;
<u>procedure</u> LNGMATTAM(L, U, I, J, A, B, C, CC, D, DD);
   <u>value</u> L, U, I, J, C, CC; <u>integer</u> L, U, I, J;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[I, L], B[J, L], E, EE); LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGMATTAM;
<u>comment</u> ================== 34416 ================= ;
<u>procedure</u> LNGSEQVEC(L, U, IL, SHIFT, A, B, C, CC, D, DD);
   <u>value</u> L, U, IL, SHIFT, C, CC; <u>integer</u> L, U, IL, SHIFT;
     <u>real</u> C, CC, D, DD; <u>array</u> A, B;
<u>begin</u> <u>real</u> E, EE;
   <u>procedure</u> DPMUL(A, B, C, CC); <u>code</u> 31103;
   <u>procedure</u> LNGADD(A, AA, B, BB, C, CC); <u>code</u> 31105;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> DPMUL(A[IL], B[L + SHIFT], E, EE); IL ≔ IL + L;
         LNGADD(C, CC, E, EE, C, CC)
      <u>end</u>;
   D ≔ C; DD ≔ CC
<u>end</u> LNGSEQVEC;
<u>comment</u> ================== 31507 ================= ;
<u>procedure</u> LNGFULSYMMATVEC(LR, UR, LC, UC, A, B, C);
   <u>value</u> LR, UR, LC, UC, B; <u>integer</u> LR, UR, LC, UC;
     <u>array</u> A, B, C;
<u>begin</u> <u>real</u> D, DD;
   <u>procedure</u> LNGSYMMATVEC(L, U, I, A, B, C, CC, D, DD);
      <u>code</u> 34418;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
      <u>begin</u> LNGSYMMATVEC(LC, UC, LR, A, B, 0, 0, D, DD);
         C[LR] ≔ D + DD
      <u>end</u>
<u>end</u> LNGFULSYMMATVEC;
<u>comment</u> ================== 31508 ================= ;
<u>procedure</u> LNGRESVEC(LR, UR, LC, UC, A, B, C, X);
   <u>value</u> LR, UR, LC, UC, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> A, B, C;
<u>begin</u> <u>real</u> D, DD, E, EE;
   <u>procedure</u> DPMUL(X, Y, E, EE); <u>code</u> 31103;
   <u>procedure</u> LNGMATVEC(L, U, I, A, B, C, CC, D, DD); <u>code</u> 34411;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
      <u>begin</u> DPMUL(C[LR], X, E, EE);
         LNGMATVEC(LC, UC, LR, A, B, E, EE, D, DD); C[LR] ≔ D + DD
      <u>end</u>
<u>end</u> LNGRESVEC;
<u>comment</u> ================== 31509 ================= ;
<u>procedure</u> LNGSYMRESVEC(LR, UR, LC, UC, A, B, C, X);
   <u>value</u> LR, UR, LC, UC, B, X; <u>integer</u> LR, UR, LC, UC;
     <u>real</u> X; <u>array</u> A, B, C;
<u>begin</u> <u>real</u> D, DD, E, EE;
   <u>procedure</u> DPMUL(X, Y, E, EE); <u>code</u> 31103;
   <u>procedure</u> LNGSYMMATVEC(L, U, I, A, B, C, CC, D, DD);
      <u>code</u> 34418;
   <u>for</u> LR ≔ LR <u>step</u> 1 <u>until</u> UR <u>do</u>
      <u>begin</u> DPMUL(C[LR], X, E, EE);
         LNGSYMMATVEC(LC, UC, LR, A, B, E, EE, D, DD); C[LR] ≔ D + DD
      <u>end</u>
<u>end</u> LNGSYMRESVEC;
<u>comment</u> ================== 34357 ================= ;
<u>procedure</u> ROTCOMCOL(L, U, I, J, AR, AI, CR, CI, S);
   <u>value</u> L, U, I, J, CR, CI, S; <u>integer</u> L, U, I, J;
     <u>real</u> CR, CI, S; <u>array</u> AR, AI;
<u>begin</u> <u>real</u> ARLI, AILI, ARLJ, AILJ;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> ARLI ≔ AR[L, I]; AILI ≔ AI[L, I]; ARLJ ≔ AR[L, J];
         AILJ ≔ AI[L, J];
         AR[L, I] ≔ CR × ARLI + CI × AILI - S × ARLJ;
         AI[L, I] ≔ CR × AILI - CI × ARLI - S × AILJ;
         AR[L, J] ≔ CR × ARLJ - CI × AILJ + S × ARLI;
         AI[L, J] ≔ CR × AILJ + CI × ARLJ + S × AILI;
      <u>end</u>
<u>end</u> ROTCOMCOL;
<u>comment</u> ================== 34358 ================= ;
<u>procedure</u> ROTCOMROW(L, U, I, J, AR, AI, CR, CI, S);
   <u>value</u> L, U, I, J, CR, CI, S; <u>integer</u> L, U, I, J;
     <u>real</u> CR, CI, S; <u>array</u> AR, AI;
<u>begin</u> <u>real</u> ARIL, AIIL, ARJL, AIJL;
   <u>for</u> L ≔ L <u>step</u> 1 <u>until</u> U <u>do</u>
      <u>begin</u> ARIL ≔ AR[I, L]; AIIL ≔ AI[I, L]; ARJL ≔ AR[J, L];
         AIJL ≔ AI[J, L];
         AR[I, L] ≔ CR × ARIL + CI × AIIL + S × ARJL;
         AI[I, L] ≔ CR × AIIL - CI × ARIL + S × AIJL;
         AR[J, L] ≔ CR × ARJL - CI × AIJL - S × ARIL;
         AI[J, L] ≔ CR × AIJL + CI × ARJL - S × AIIL;
      <u>end</u>
<u>end</u> ROTCOMROW;
<u>comment</u> ================== 34611 ================= ;
<u>procedure</u> CHSH2(A1R, A1I, A2R, A2I, C, SR, SI);
   <u>value</u> A1R, A1I, A2R, A2I; <u>real</u> A1R, A1I, A2R, A2I, C, SR, SI;
<u>begin</u> <u>real</u> R;
   <u>if</u> A2R ≠ 0 ∨ A2I ≠ 0 <u>then</u>
   <u>begin</u> <u>if</u> A1R ≠ 0 ∨ A1I ≠ 0 <u>then</u>
      <u>begin</u> R ≔ SQRT(A1R × A1R + A1I × A1I); C ≔ R;
         SR ≔ (A1R × A2R + A1I × A2I)/R; SI ≔ (A1R × A2I-A1I × A2R)/R;
         R ≔ SQRT(C × C + SR × SR + SI × SI); C ≔ C/R; SR ≔ SR/R; SI ≔ SI/R
      <u>end</u> <u>else</u>
      <u>begin</u> SI ≔ C ≔ 0; SR ≔ 1 <u>end</u>
   <u>end</u> <u>else</u> <u>begin</u> C ≔ 1; SR ≔ SI ≔ 0 <u>end</u>
<u>end</u> CHSH2;
<u>comment</u> ================== 33314 ================= ;
<u>procedure</u> NONLIN FEM LAG SKEW(X, Y, N, F, FY, FZ, NC, E);
   <u>integer</u> N, NC;
     <u>real</u> <u>procedure</u> F, FY, FZ;
     <u>array</u> X, Y, E;
<u>begin</u> <u>integer</u> L, L1, IT;
   <u>real</u> XL1, XL, H, A12, A21, B1, B2, TAU1, TAU2, CH, TL, G, YL, PP,
     PLM, PRM, PL1, PL3, PL1PL2, PL1PL3, PL2PL2, PL2PL3,
     PR1PR2, PR1PR3, PR2PR3, PL1QL2, PL1QL3, PL2QL1, PL2QL2, PL2QL3,
     PL3QL1, PL3QL2, PR1QR2, PR1QR3, PR2QR1, PR2QR2, PR2QR3, PR3QR1,
     PR3QR2, H2RM, ZL1, ZL, E1, E2, E3, E4, E5, E6, EPS, RHO;
   <u>array</u> T, SUPER, SUB, CHI, GI[0:N-1], Z[0:N];

   <u>procedure</u> DUPVEC(L, U, S, A, B); <u>code</u> 31030;

   <u>procedure</u> ELEMENT MAT VEC EVALUATION 1;
   <u>begin</u> <u>real</u>  XM, VL, VR, WL, WR, PR, QM, RM, FM, XL12, XL1XL, XL2, ZM, ZACCM;
      <u>if</u> NC = 0 <u>then</u> VL ≔ VR ≔ 0·5 <u>else</u> <u>if</u> NC = 1 <u>then</u>
      <u>begin</u> VL ≔ (XL1 × 2 + XL)/6; VR ≔ (XL1 + XL × 2)/6 <u>end</u> <u>else</u>
      <u>begin</u> XL12 ≔ XL1 × XL1/12; XL1XL ≔ XL1 × XL/6; XL2 ≔ XL × XL/12;
         VL ≔ 3 × XL12 + XL1XL + XL2;
         VR ≔ 3 × XL2 + XL1XL + XL12
      <u>end</u>;
      WL ≔ H × VL; WR ≔ H × VR; PR ≔ VR/(VL + VR);
      XM ≔ XL1 + H × PR; ZM ≔ PR × ZL + (1 - PR) × ZL1;
      ZACCM ≔ (ZL - ZL1)/H ; QM ≔ FZ(XM, ZM, ZACCM);
      RM ≔ FY(XM, ZM, ZACCM); FM ≔ F(XM, ZM, ZACCM);
      TAU1 ≔ WL × RM; TAU2 ≔ WR × RM;
      B1 ≔ WL × FM - ZACCM × (VL + VR); B2 ≔ WR × FM + ZACCM × (VL + VR);
      A12 ≔ - (VL + VR)/H + VL × QM + (1 - PR) × PR × RM × (WL + WR);
      A21 ≔ - (VL + VR)/H - VR × QM + (1 - PR) × PR × RM × (WL + WR);
   <u>end</u> ELEM. M.V. EV.;
   <u>procedure</u> BOUNDARY CONDITIONS;
      <u>if</u> L = 1 ∧ E2 = 0 <u>then</u>
      <u>begin</u> TAU1 ≔ 1; B1 ≔ A12 ≔ 0 <u>end</u>
        <u>else</u> <u>if</u> L = 1 ∧ E2 ≠ 0 <u>then</u>
      <u>begin</u> TAU1 ≔ TAU1 - E1/E2
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 = 0 <u>then</u>
      <u>begin</u> TAU2 ≔ 1; B2 ≔ A21 ≔ 0
      <u>end</u> <u>else</u> <u>if</u> L = N ∧ E5 ≠ 0 <u>then</u>
      <u>begin</u> TAU2 ≔ TAU2 + E4/E5
      <u>end</u> B.C.1;

   <u>procedure</u> FORWARD BABUSKA;
      <u>if</u> L = 1 <u>then</u>
      <u>begin</u> CHI[0] ≔ CH ≔ TL ≔ TAU1; T[0] ≔ TL;
         GI[0] ≔ G ≔ YL ≔ B1; Y[0] ≔ YL;
         SUB[0] ≔ A21; SUPER[0] ≔ A12;
         PP ≔ A21/(CH - A12); CH ≔ TAU2 - CH × PP;
         G ≔ B2 - G × PP; TL ≔ TAU2; YL ≔ B2
      <u>end</u> <u>else</u>
      <u>begin</u> CHI[L1] ≔ CH ≔ CH + TAU1;
         GI[L1] ≔ G ≔ G + B1;
         SUB[L1] ≔ A21; SUPER[L1] ≔ A12;
         PP ≔ A21/(CH - A12); CH ≔ TAU2 - CH × PP;
         G ≔ B2 - G × PP; T[L1] ≔ TL + TAU1; TL ≔ TAU2;
         Y[L1] ≔ YL +  B1; YL ≔ B2
      <u>end</u> FORWARD BABUSKA;

   <u>procedure</u> BACKWARD BABUSKA;
   <u>begin</u> PP ≔ YL; Y[N] ≔ G/CH;
      G ≔ PP; CH ≔ TL; L ≔ N;
      <u>for</u> L ≔ L - 1 <u>while</u> L &GreaterSlantEqual; 0 <u>do</u>
         <u>begin</u> PP ≔ SUPER[L]/(CH - SUB[L]);
            TL ≔ T[L]; CH ≔ TL - CH × PP;
            YL ≔ Y[L]; G ≔ YL - G × PP;
            Y[L] ≔ (GI[L] + G - YL)/(CHI[L] + CH - TL)  ;
         <u>end</u>
   <u>end</u> BACKWARD BABUSKA;

   DUPVEC(0, N, 0, Z, Y);
   E1 ≔ E[1]; E2 ≔ E[2]; E3 ≔ E[3]; E4 ≔ E[4]; E5 ≔ E[5]; E6 ≔ E[6];
   <u>for</u> IT ≔ 1, IT + 1 <u>while</u> EPS &gt; RHO <u>do</u>
      <u>begin</u> L ≔ 0; XL ≔ X[0]; ZL ≔ Z[0];
         <u>for</u> L ≔ L + 1 <u>while</u> L &LessSlantEqual; N <u>do</u>
            <u>begin</u> XL1 ≔ XL; L1 ≔ L - 1; XL ≔ X[L]; H ≔ XL - XL1;
               ZL1 ≔ ZL; ZL ≔ Z[L];
               ELEMENT MAT VEC EVALUATION 1;
               <u>if</u> L = 1 ∨ L = N <u>then</u> BOUNDARY CONDITIONS;
               FORWARD BABUSKA
            <u>end</u>;
         BACKWARD BABUSKA;
         EPS ≔ 0; RHO ≔ 1;
         <u>for</u> L ≔ 0 <u>step</u> 1 <u>until</u> N <u>do</u>
            <u>begin</u> RHO ≔ RHO + ABS(Z[L]);
               EPS ≔ EPS + ABS(Y[L]); Z[L] ≔ Z[L] - Y[L]
            <u>end</u>;
         RHO ≔ &#9192;-14 × RHO
      <u>end</u>;
   DUPVEC(0, N, 0, Y, Z)
<u>end</u> NONLIN FEM LAG SKEW;

<u>eop</u>
</pre></body></html>
